

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="czk997">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合： 123String[] ss &#x3D; new String[10]; &#x2F;&#x2F; 可以持有10个String对象ss[0] &#x3D; &quot;Hello&quot;; &#x2F;&#x2F; 可以放入String对象String first &#x3D; ss[0];">
<meta property="og:type" content="article">
<meta property="og:title" content="集合基础">
<meta property="og:url" content="https://czk997.github.io/2022/01/05/Core/Java/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/">
<meta property="og:site_name" content="La La Land">
<meta property="og:description" content="概述在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合： 123String[] ss &#x3D; new String[10]; &#x2F;&#x2F; 可以持有10个String对象ss[0] &#x3D; &quot;Hello&quot;; &#x2F;&#x2F; 可以放入String对象String first &#x3D; ss[0];">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://czk997.github.io/2022/01/05/Core/Java/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/README.assets/image-20211222153755858.png">
<meta property="og:image" content="https://czk997.github.io/2022/01/05/Core/Java/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80.assets/image-20211222204919210.png">
<meta property="article:published_time" content="2022-01-05T14:01:38.515Z">
<meta property="article:modified_time" content="2022-01-05T14:01:38.519Z">
<meta property="article:author" content="czk997">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://czk997.github.io/2022/01/05/Core/Java/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/README.assets/image-20211222153755858.png">
  
  
  <title>集合基础 - La La Land</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"czk997.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="集合基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-05 22:01" pubdate>
        星期三, 一月 5日 2022, 10:01 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">集合基础</h1>
            
            <div class="markdown-body">
              <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span>[] ss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 可以持有10个String对象</span><br>ss[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 可以放入String对象</span><br><span class="hljs-keyword">String</span> first = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 可以获取String对象</span><br></code></pre></td></tr></table></figure>

<p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>
<ul>
<li>数组初始化后大小不可变；</li>
<li>数组只能按索引顺序存取。</li>
</ul>
<p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>
<ul>
<li>可变大小的顺序链表；</li>
<li>保证无重复元素的集合；</li>
<li>…</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
<li>还包括Queue等</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 只能放入String类型</span><br></code></pre></td></tr></table></figure>

<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>
</ul>
<p><img src="README.assets/image-20211222153755858.png" srcset="/img/loading.gif" lazyload alt="image-20211222153755858"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p>
<h2 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h2><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p>
<p><code>List</code>的行为和数组几乎完全相同：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从<code>0</code>开始。</p>
<p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;&#125;</code>中删除索引为<code>2</code>的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br>              │   │<br>          ┌───┘   │<br>          │   ┌───┘<br>          │   │<br>          ▼   ▼<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ D │ E │   │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>这个“删除”操作实际上是把<code>&#39;C&#39;</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p>
<p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个<code>ArrayList</code>拥有5个元素，实际数组大小为<code>6</code>（即有一个空位）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │   │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=6<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=6<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=7<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>
<p>我们考察<code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>但是，实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。在<code>LinkedList</code>中，它的内部每个元素都指向下一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐<br>HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │<br>        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘<br></code></pre></td></tr></table></figure>

<p>我们来比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td align="left">需要从头开始查找元素(越大越慢)</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td align="left">不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td align="left">较大(除了存储数据还需存储指针)</td>
</tr>
</tbody></table>
<p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p>
<h3 id="List的特点"><a href="#List的特点" class="headerlink" title="List的特点"></a>List的特点</h3><p>使用<code>List</code>时，我们要关注<code>List</code>接口的规范。<code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.add(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=2</span><br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// 允许重复添加元素，size=3</span><br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>List还允许添加null：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class Main &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// size=2</span><br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=3</span><br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">second</span> = list.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// null</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">second</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建List"><a href="#创建List" class="headerlink" title="创建List"></a>创建List</h3><p>除了使用<code>ArrayList</code>和<code>LinkedList</code>，我们还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>(java9:返回的是对象不可变列表,列表不可变,列表内的数据可能会变)：</p>
<p>在java8中的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>stringList = Collections.unmodifiableList(stringList);<span class="hljs-comment">//数据集不改变,数据可能会变</span><br></code></pre></td></tr></table></figure>

<p>java9中写法:返回不可变数据集</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">List</span>&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p>
<h3 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h3><p>和数组类型，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">String</span> s = list.<span class="hljs-built_in">get</span>(i);<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但这种方式并不推荐，一是代码复杂，二是因为**<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。**</p>
<p><strong>所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code><strong>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。</strong><code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</strong></p>
<p><strong>即对于不同List,迭代器对象具有最高访问效率的实现</strong></p>
<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;<span class="hljs-keyword">String</span>&gt; it = list.<span class="hljs-built_in">iterator</span>(); it.<span class="hljs-built_in">hasNext</span>(); ) &#123;<br>            <span class="hljs-keyword">String</span> s = it.<span class="hljs-built_in">next</span>();<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> s : list) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p>
<p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。</p>
<h3 id="List和Array转换"><a href="#List和Array转换" class="headerlink" title="List和Array转换"></a>List和Array转换</h3><p>把<code>List</code>变为<code>Array</code>有三种方法，第一种是调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        Object[] array = list.<span class="hljs-built_in">toArray</span>();<br>        <span class="hljs-keyword">for</span> (Object s : array) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这种方法会丢失类型信息，所以实际应用很少。</strong></p>
<p>第二种方式是给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>]);<br>        <span class="hljs-keyword">for</span> (Integer n : array) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意到这个<code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入<code>Number</code>类型的数组，返回的仍然是<code>Number</code>类型：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">import java.util.<span class="hljs-class">List;</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> class Main &#123;<br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>        List&lt;Integer&gt; list = List.of(12, 34, 56);<br>        Number[]<span class="hljs-built_in"> array </span>= list.toArray(new Number[3]);<br>        for (Number n<span class="hljs-keyword"> :</span> array) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p>
<p>如果我们传入的数组大小和<code>List</code>实际的元素个数不一致怎么办？根据<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray(T[])">List接口</a>的文档，我们可以知道：</p>
<p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；<strong>如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>(int填0)。</strong></p>
<p>实际上，最常用的是传入一个“恰好”大小的数组：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= list.toArray(new Integer[list.size()]);<br></code></pre></td></tr></table></figure>

<p><strong>最后一种更简洁的写法是通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法</strong>：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= list.toArray(Integer[]::new);<br></code></pre></td></tr></table></figure>

<p>这种函数式写法我们会在后续讲到。</p>
<p>反过来，把<code>Array</code>变为<code>List</code>就简单多了，通过<code>List.of(T...)</code>方法最简单：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= &#123; 1, 2, 3 &#125;;<br>List&lt;Integer&gt; list = List.of(array);<br></code></pre></td></tr></table></figure>

<p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p>
<p>要注意的是，List.of(array)返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        list.add(<span class="hljs-number">999</span>); <span class="hljs-comment">// UnsupportedOperationException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造从start到end的序列：</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = <span class="hljs-number">20</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 随机删除List中的一个元素:</span><br>        <span class="hljs-keyword">int</span> removed = list.remove((<span class="hljs-keyword">int</span>) (Math.random() * list.size()));<br>        <span class="hljs-keyword">int</span> found = findMissingNumber(start, end, list);<br>        System.out.println(list.toString());<br>        System.out.println(<span class="hljs-string">&quot;missing number: &quot;</span> + found);<br>        System.out.println(removed == found ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMissingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) != start) &#123;<br>                <span class="hljs-keyword">return</span> start;<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>增强版：和上述题目一样，但整数不再有序，试找出缺失的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造从start到end的序列：</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = <span class="hljs-number">20</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 洗牌算法shuffle可以随机交换List中的元素位置:</span><br>        Collections.shuffle(list);<br>        <span class="hljs-comment">// 随机删除List中的一个元素:</span><br>        <span class="hljs-keyword">int</span> removed = list.remove((<span class="hljs-keyword">int</span>) (Math.random() * list.size()));<br>        <span class="hljs-keyword">int</span> found = findMissingNumber(start, end, list);<br>        System.out.println(list.toString());<br>        System.out.println(<span class="hljs-string">&quot;missing number: &quot;</span> + found);<br>        System.out.println(removed == found ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO </span><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMissingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, List&lt;Integer&gt; list)</span> </span>&#123;<br>         <span class="hljs-keyword">while</span>(start &lt;= end)&#123;<br>            <span class="hljs-keyword">if</span>(list.contains(start))&#123;<br>                start++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//还有一种方法  用等差数列求和公式,算出原集合和之后集合的差值</span><br> <span class="hljs-keyword">int</span> sum = (start + end) * (end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>              <span class="hljs-keyword">int</span> all = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">for</span>(Integer i:list) &#123;<br>                  all += i;<br>              &#125;<br>              <span class="hljs-keyword">return</span> sum - all;<br></code></pre></td></tr></table></figure>

<p><img src="%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80.assets/image-20211222204919210.png" srcset="/img/loading.gif" lazyload alt="image-20211222204919210"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p>
<p>可以直接使用<code>for each</code>遍历<code>List</code>；</p>
<p><code>List</code>可以和<code>Array</code>相互转换。</p>
<h2 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h2><p>List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等，例如contains()方法可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> </span>&#123;<br>    Object[] elementData;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementData.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>因此，要正确使用List的contains()、indexOf()这些方法，放入的实例必须正确覆写equals()方法，否则，放进去的实例，查找不到。我们之所以能正常放入String、Integer这些对象，是因为Java标准库定义的这些类已经正确实现了equals()方法。<br>我们以Person对象为例，测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; list = List.of(<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Ming&quot;</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Hong&quot;</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>)<br>        );<br>        System.out.println(list.contains(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不出意外，虽然放入了new Person(“Bob”)，但是用另一个new Person(“Bob”)查询不到，原因就是Person类没有覆写equals()方法。</p>
<p>编写equals<br>如何正确编写equals()方法？equals()方法要求我们必须满足以下条件：</p>
<p><code>自反性（Reflexive）</code>：xex-&gt;xex  对于非null的x来说，x.equals(x)必须返回true,即；</p>
<p><code>对称性（Symmetric）</code>：xey-&gt;yex  对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true；</p>
<p><code>传递性（Transitive）</code>：xey,yez-&gt;xez   对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true；</p>
<p><code>一致性（Consistent）</code>：xey-&gt;xey   对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false；<br>对null的比较：即x.equals(null)永远返回false。</p>
<p>上述规则看上去似乎非常复杂，但其实代码实现equals()方法是很简单的，我们以Person类为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先，我们要定义“相等”的逻辑含义。对于Person类，如果name相等，并且age相等，我们就认为两个Person实例相等。</p>
<p>因此，编写equals()方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用==。</p>
<p>如果this.name为null，那么equals()方法会报错，因此，需要继续改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">boolean</span> nameEquals = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name == <span class="hljs-keyword">null</span> &amp;&amp; p.name == <span class="hljs-keyword">null</span>) &#123;<br>            nameEquals = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name != <span class="hljs-keyword">null</span>) &#123;<br>            nameEquals = <span class="hljs-keyword">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nameEquals &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果Person有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用Objects.equals()静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(<span class="hljs-keyword">this</span>.name, p.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因此，我们总结一下equals()方法的正确编写方法：</p>
<p>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；<br>用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；<br>对引用类型用Objects.equals()比较，对基本类型直接用==比较。<br>使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。</p>
<p>如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。</p>
<p>注:lombok equalsAndHash注解会重写equals()和hashCode()</p>
<h2 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h2><p>重复放入key-value并不会有任何问题，但是一个key只能关联一个value。在上面的代码中，一开始我们把key对象”apple”映射到Integer对象123，然后再次调用put()方法把”apple”映射到789，这时，原来关联的value对象123就被“冲掉”了。实际上，put()方法的签名是V put(K key, V value)，如果放入的key已经存在，put()方法会返回被删除的旧的value，否则，返回null。</p>
<p> 始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。<br>此外，在一个Map中，虽然key不能重复，但value是可以重复的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">123</span>);<br>map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
<p>Map和List不同的是，Map存储的是key-value的映射关系，并且，它不保证顺序。在遍历的时候，遍历的顺序既不一定是put()时放入的key的顺序，也不一定是key的排序顺序。使用Map时，任何依赖顺序的逻辑都是不可靠的。以HashMap为例，假设我们放入”A”，”B”，”C”这3个key，遍历的时候，每个key会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！</p>
<p> 遍历Map时，不可假设输出的key是有序的！</p>
<p>注:想要有序用LinkedHashMap,它内部维护了一个双向链表</p>
<h2 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h2><p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p>
<p>以HashMap为例，观察下面的代码：</p>
<p>Map&lt;String, Person&gt; map = new HashMap&lt;&gt;();<br>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));<br>map.put(“c”, new Person(“Xiao Jun”));</p>
<p>map.get(“a”); // Person(“Xiao Ming”)<br>map.get(“x”); // null<br>HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引：</p>
<p>  ┌───┐<br>0 │   │<br>  ├───┤<br>1 │ ●─┼───&gt; Person(“Xiao Ming”)<br>  ├───┤<br>2 │   │<br>  ├───┤<br>3 │   │<br>  ├───┤<br>4 │   │<br>  ├───┤<br>5 │ ●─┼───&gt; Person(“Xiao Hong”)<br>  ├───┤<br>6 │ ●─┼───&gt; Person(“Xiao Jun”)<br>  ├───┤<br>7 │   │<br>  └───┘<br>如果key的值为”a”，计算得到的索引总是1，因此返回value为Person(“Xiao Ming”)，如果key的值为”b”，计算得到的索引总是5，因此返回value为Person(“Xiao Hong”)，这样，就不必遍历整个数组，即可直接读取key对应的value。</p>
<p>当我们使用key存取value的时候，就会引出一个问题：</p>
<p>我们放入Map的key是字符串”a”，但是，当我们获取Map的value时，传入的变量不一定就是放入的那个key对象。</p>
<p>换句话讲，两个key应该是内容相同，但不一定是同一个对象。测试代码如下：</p>
<p>import java.util.HashMap;<br>import java.util.Map;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String key1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(key1, <span class="hljs-number">123</span>);<br><br>        String key2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>);<br>        map.get(key2); <span class="hljs-comment">// 123</span><br><br>        System.out.println(key1 == key2); <span class="hljs-comment">// false</span><br>        System.out.println(key1.equals(key2)); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。</p>
<p>我们经常使用String作为key，因为String已经正确覆写了equals()方法。但如果我们放入的key是一个自己写的类，就必须保证正确覆写了equals()方法。</p>
<p>我们再思考一下HashMap为什么能通过key直接计算出value存储的索引。相同的key对象（使用equals()判断时返回true）必须要计算出相同的索引，否则，相同的key每次取出的value就不一定对。</p>
<p>通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。</p>
<p>因此，正确使用Map必须保证：</p>
<p>作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true；</p>
<p>作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：</p>
<p>如果两个对象相等，则两个对象的hashCode()必须相等；<br>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。<br>即对应两个实例a和b：</p>
<p>如果a和b相等，那么a.equals(b)一定为true，则a.hashCode()必须等于b.hashCode()；<br>如果a和b不相等，那么a.equals(b)一定为false，则a.hashCode()和b.hashCode()尽量不要相等。<br>上述第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。</p>
<p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。</p>
<p>正确编写equals()的方法我们已经在编写equals方法一节中讲过了，以Person类为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String firstName;<br>    String lastName;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>把需要比较的字段找出来：</p>
<p>firstName<br>lastName<br>age<br>然后，引用类型使用Objects.equals()比较，基本类型使用==比较。</p>
<p>在正确实现equals()的基础上，我们还需要正确实现hashCode()，即上述3个字段分别相同的实例，hashCode()返回的int必须相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String firstName;<br>    String lastName;<br>    <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>        h = <span class="hljs-number">31</span> * h + firstName.hashCode();<br>        h = <span class="hljs-number">31</span> * h + lastName.hashCode();<br>        h = <span class="hljs-number">31</span> * h + age;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意到String类已经正确实现了hashCode()方法，我们在计算Person的hashCode()时，反复使用31*h，这样做的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围。</p>
<p>和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.hash()来计算：</p>
<p>int hashCode() {<br>    return Objects.hash(firstName, lastName, age);<br>}<br>所以，编写equals()和hashCode()遵循的原则是：</p>
<p>equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。</p>
<p>另外注意，对于放入HashMap的value对象，没有任何要求。</p>
<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>既然HashMap内部使用了数组，通过计算key的hashCode()直接定位value所在的索引，那么第一个问题来了：hashCode()返回的int范围高达±21亿，先不考虑负数，HashMap内部使用的数组得有多大？</p>
<p>实际上HashMap初始化时默认的数组大小只有16，任何key，无论它的hashCode()有多大，都可以简单地通过：</p>
<p>int index = key.hashCode() &amp; 0xf; // 0xf = 15<br>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p>
<p>第二个问题：如果添加超过16个key-value到HashMap，数组不够用了怎么办？</p>
<p>添加超过一定数量的key-value时，HashMap会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。例如，对长度为32的数组计算hashCode()对应的索引，计算方式要改为：</p>
<p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31<br>由于扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大。如果我们确定要使用一个容量为10000个key-value的HashMap，更好的方式是创建HashMap时就指定容量：</p>
<p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);<br>虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。</p>
<p>最后一个问题：如果不同的两个key，例如”a”和”b”，它们的hashCode()恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求hashCode()尽量不相等），那么，当我们放入：</p>
<p>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));<br>时，由于计算出的数组索引相同，后面放入的”Xiao Hong”会不会把”Xiao Ming”覆盖了？</p>
<p>当然不会！使用Map的时候，只要key不相同，它们映射的value就互不干扰。但是，在HashMap内部，确实可能存在不同的key，映射到相同的hashCode()，即相同的数组索引上，肿么办？</p>
<p>我们就假设”a”和”b”这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是”a”的映射，一个是”b”的映射：</p>
<p>  ┌───┐<br>0 │   │<br>  ├───┤<br>1 │   │<br>  ├───┤<br>2 │   │<br>  ├───┤<br>3 │   │<br>  ├───┤<br>4 │   │<br>  ├───┤<br>5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;<br>  ├───┤<br>6 │   │<br>  ├───┤<br>7 │   │<br>  └───┘<br>在查找的时候，例如：</p>
<p>Person p = map.get(“a”);<br>HashMap内部通过”a”找到的实际上是List&lt;Entry&lt;String, Person&gt;&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是”a”，才能返回对应的Person实例。</p>
<p><code>我们把不同的key具有相同的hashCode()的情况称之为哈希冲突</code>。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二：</p>
<p> 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。<br>hashCode()方法编写得越好，HashMap工作的效率就越高。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>要正确使用HashMap，作为key的类必须正确覆写equals()和hashCode()方法；</p>
<p>一个类如果覆写了equals()，就必须覆写hashCode()，并且覆写规则是：</p>
<p>如果equals()返回true，则hashCode()返回值必须相等；</p>
<p>如果equals()返回false，则hashCode()返回值尽量不要相等。</p>
<p>实现hashCode()方法可以通过Objects.hashCode()辅助方法实现。</p>
<p>`<br>hashmap中依据key的hash值来确定value存储位置，所以一定要重写hashCode方法，而重写equals方法，是为了解决hash冲突，如果两个key的hash值相同，就会调用equals方法，比较key值是否相同，在存储时：如果equals结果相同就覆盖更新value值，如果不同就用List他们都存储起来。在取出来是：如果equals结果相同就返回当前value值，如果不同就遍历List中下一个元素。即要key与hash同时匹配才会认为是同一个key。</p>
<p>JDK中源码:if(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))){ops;}<br>`</p>
<h2 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h2><p>因为HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。</p>
<p>如果作为<code>key的对象是enum类型</code>，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。</p>
<p>我们以DayOfWeek这个枚举类型为例，为它做一个“翻译”功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.DayOfWeek;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;DayOfWeek, String&gt; map = <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);<br>        map.put(DayOfWeek.MONDAY, <span class="hljs-string">&quot;星期一&quot;</span>);<br>        map.put(DayOfWeek.TUESDAY, <span class="hljs-string">&quot;星期二&quot;</span>);<br>        map.put(DayOfWeek.WEDNESDAY, <span class="hljs-string">&quot;星期三&quot;</span>);<br>        map.put(DayOfWeek.THURSDAY, <span class="hljs-string">&quot;星期四&quot;</span>);<br>        map.put(DayOfWeek.FRIDAY, <span class="hljs-string">&quot;星期五&quot;</span>);<br>        map.put(DayOfWeek.SATURDAY, <span class="hljs-string">&quot;星期六&quot;</span>);<br>        map.put(DayOfWeek.SUNDAY, <span class="hljs-string">&quot;星期日&quot;</span>);<br>        System.out.println(map);<br>        System.out.println(map.get(DayOfWeek.MONDAY));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。</p>
<p>小结<br>如果Map的key是enum类型，推荐使用EnumMap，既保证速度，也不浪费空间。</p>
<p>使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。</p>
<h2 id="使用TreeMap"><a href="#使用TreeMap" class="headerlink" title="使用TreeMap"></a>使用TreeMap</h2><p>我们已经知道，HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。</p>
<p>还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。注意到SortedMap是接口，它的实现类是<code>TreeMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">       ┌───┐<br>       │Map│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>                ▲<br>                │<br>          ┌─────────┐<br>          │ TreeMap │<br>          └─────────┘<br><br></code></pre></td></tr></table></figure>
<p>SortedMap保证遍历时以Key的顺序来进行排序。例如，放入的Key是”apple”、”pear”、”orange”，遍历的顺序一定是”apple”、”orange”、”pear”，因为String默认按字母排序</p>
<p>使用TreeMap时，放入的Key必须实现<code>Comparable</code>接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。<code>作为Value的对象则没有任何要求</code>。</p>
<p><code>如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Person key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        <span class="hljs-comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span><br>        System.out.println(map.get(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    Person(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;Person: &quot;</span> + name + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意到Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果a&lt;b，则返回负数，通常是-1，如果a==b，则返回0，如果a&gt;b，则返回正数，通常是1。TreeMap内部根据比较结果对Key进行排序。</p>
<p>从上述代码执行结果可知，打印的Key确实是按照Comparator定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个new Person(“Bob”)作为Key，它会返回对应的Integer值2。</p>
<p>另外，注意到Person类并未覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。</p>
<p>我们来看一个稍微复杂的例子：这次我们定义了Student类，并用分数score进行排序，高分在前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Student, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">77</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">66</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">99</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Student key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        System.out.println(map.get(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">66</span>))); <span class="hljs-comment">// null?</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> score;<br>    Student(String name, <span class="hljs-keyword">int</span> score) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在for循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的Key：new Student(“Bob”, 66)进行查找时，结果为null！</p>
<p>这是怎么肥四？难道TreeMap有问题？遇到TreeMap工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p>
<p>在这个例子中，TreeMap出现问题，原因其实出在这个Comparator上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在p1.score和p2.score不相等的时候，它的返回值是正确的，但是，在p1.score和p2.score相等的时候，它并没有返回0！这就是为什么TreeMap工作不正常的原因：TreeMap在比较两个Key是否相等时，依赖Key的compareTo()方法或者Comparator.compare()方法。在两个Key相等时，必须返回0。因此，修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p1.score == p2.score) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者直接借助Integer.compare(int, int)也可以返回正确的比较结果。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>SortedMap在遍历时严格按照Key的顺序遍历，最常用的实现类是TreeMap；</p>
<p>作为SortedMap的Key必须实现Comparable接口，或者传入Comparator；</p>
<p>要严格按照compare()规范实现比较逻辑，否则，TreeMap将不能正常工作。</p>
<h2 id="使用Properties"><a href="#使用Properties" class="headerlink" title="使用Properties"></a>使用Properties</h2><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># 上次最后打开的文件:<br>last_open_file=/data/hello.txt<br># 自动保存文件的时间间隔:<br>auto_save_interval=<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>

<p>配置文件的特点是，它的Key-Value一般都是String-String类型的，因此我们完全可以用Map&lt;String, String&gt;来表示它。</p>
<p>因为配置文件非常常用，所以Java集合库提供了一个Properties来表示一组“配置”。<code>由于历史遗留原因</code>，Properties内部本质上是一个<code>Hashtable</code>，但我们只需要用到Properties自身关于读写配置的接口。</p>
<h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>用Properties读取配置文件非常简单。Java默认配置文件以.properties为扩展名，每行以key=value表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"># setting.properties<br>last_open_file=/data/hello.txt<br>auto_save_interval=<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>

<p>可以从文件系统读取这个.properties文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>String f = <span class="hljs-string">&quot;setting.properties&quot;</span>;<br>props.load(<span class="hljs-keyword">new</span> java.io.FileInputStream(f));<span class="hljs-comment">//从文件流加载配置文件</span><br><br>String filepath = props.getProperty(<span class="hljs-string">&quot;last_open_file&quot;</span>);<br>String interval = props.getProperty(<span class="hljs-string">&quot;auto_save_interval&quot;</span>, <span class="hljs-string">&quot;120&quot;</span>);<span class="hljs-comment">//默认值120s</span><br></code></pre></td></tr></table></figure>

<p>可见，用Properties读取配置文件，一共有三步：</p>
<p>1.创建Properties实例；<br>2.调用load()读取文件；<br>3.调用getProperty()获取配置。<br>4.调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p>
<p><code>也可以从classpath读取.properties文件，因为load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>试试从内存读取一个字节流(用ByteArrayStream,读取用input,输出用output)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// properties</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String settings = <span class="hljs-string">&quot;# test&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;course=Java&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;<br>        ByteArrayInputStream input = <span class="hljs-keyword">new</span> ByteArrayInputStream(settings.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>)); <span class="hljs-comment">//ByteArrayInputStream从内存中读取</span><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        props.load(input);<br><br>        System.out.println(<span class="hljs-string">&quot;course: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;course&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;last_open_date&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;last_open_file&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;auto_save&quot;</span>, <span class="hljs-string">&quot;60&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果有多个.properties文件，可以反复调用load()读取，后读取的key-value会覆盖已读取的key-value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br>props.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>上面的代码演示了Properties的一个常用用法：<code>可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</code></p>
<p>Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，<code>不要去调用这些从Hashtable继承下来的方法</code>。</p>
<h3 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h3><p>如果通过setProperty()修改了Properties实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.setProperty(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;http://www.liaoxuefeng.com&quot;</span>);<br>props.setProperty(<span class="hljs-string">&quot;language&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>props.store(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="hljs-string">&quot;这是写入的properties注释&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>早期版本的Java规定.properties文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用name=\u4e2d\u6587来表示，非常别扭。从<code>JDK9</code>开始，Java的.properties文件可以使用UTF-8编码了。</p>
<p>不过，需要注意的是，由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法load(Reader)读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure>

<p>就可以正常读取中文。<code>InputStream和Reader的区别是一个是字节流，一个是字符流。</code>字符流在内存中已经以char类型表示了，不涉及编码问题。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Java集合库提供的Properties用于读写配置文件.properties。.properties文件可以使用UTF-8编码。</p>
<p>可以从文件系统、classpath或其他任何地方读取.properties文件。</p>
<p>读写Properties时，注意仅使用getProperty()和setProperty()方法，不要调用继承而来的get()和put()等方法。</p>
<h2 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h2><p>我们知道，Map用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写equals()方法，还要正确覆写hashCode()方法。</p>
<p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。</p>
<p>Set用于存储不重复的元素集合，它主要提供以下几个方法：<br>将元素添加进Set<E>：boolean add(E e)<br>将元素从Set<E>删除：boolean remove(Object e)<br>判断是否包含元素：boolean contains(Object e)<br>我们来看几个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        System.out.println(set.add(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// false，添加失败，因为元素已存在</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// true，元素存在</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;XYZ&quot;</span>)); <span class="hljs-comment">// false，元素不存在</span><br>        System.out.println(set.remove(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// false，删除失败，因为元素不存在</span><br>        System.out.println(set.size()); <span class="hljs-comment">// 2，一共两个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。</p>
<p>因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。</p>
<p>最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 持有一个HashMap:</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 放入HashMap的value:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.remove(o) == PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Set接口并不保证有序，而SortedSet接口则保证元素是有序的：</p>
<p>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；<br>TreeSet是有序的，因为它实现了SortedSet接口。<br>用一张图表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">      ┌───┐<br>       │Set│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeSet │<br>          └─────────┘<br></code></pre></td></tr></table></figure>
<p>我们来看HashSet的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意输出的顺序既不是添加的顺序，也不是String排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p>
<p>把HashSet换成TreeSet，在遍历TreeSet时，输出就是有序的，这个顺序是元素的排序顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用TreeSet和使用TreeMap的要求一样，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象。</p>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用Set去除重复的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>            <span class="hljs-comment">// Arrays.asList生成的List用的是ArrayList in Arrays,不能增删和修改,也不能修改原数组,否则List数值会变</span><br><span class="hljs-comment">//            List&lt;Message&gt; received = Arrays.asList(</span><br><span class="hljs-comment">//                new Message(1, &quot;Hello!&quot;),</span><br><span class="hljs-comment">//                        new Message(2, &quot;发工资了吗？&quot;),</span><br><span class="hljs-comment">//                        new Message(2, &quot;发工资了吗？&quot;),</span><br><span class="hljs-comment">//                        new Message(3, &quot;去哪吃饭？&quot;),</span><br><span class="hljs-comment">//                        new Message(3, &quot;去哪吃饭？&quot;),</span><br><span class="hljs-comment">//                        new Message(4, &quot;Bye&quot;)</span><br><span class="hljs-comment">//            );</span><br>            List&lt;Message&gt; received = <span class="hljs-keyword">new</span> ArrayList&lt;Message&gt;()&#123;&#123;<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello!&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;发工资了吗？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;发工资了吗？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;去哪吃饭？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;去哪吃饭？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Bye&quot;</span>));<br>            &#125;&#125;;<br><br>            List&lt;Message&gt; displayMessages = process(received);<br>            <span class="hljs-keyword">for</span> (Message message : displayMessages) &#123;<br>                System.out.println(message.text);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Message&gt; <span class="hljs-title">process</span><span class="hljs-params">(List&lt;Message&gt; received)</span> </span>&#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 按sequence去除重复消息</span><br>            <span class="hljs-comment">// TreeSet默认加的是String,如果不写比较类,元素Message就要实现Comparable接口</span><br>            TreeSet&lt;Message&gt; msgTreeSet = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((o1, o2) -&gt; &#123;<br>                <span class="hljs-keyword">if</span>(o1.sequence == o2.sequence &amp;&amp; Objects.equals(o1.text,o2.text))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> o1.sequence &gt; o2.sequence? <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>            &#125;);<br><span class="hljs-comment">//            Iterator&lt;Message&gt; iterator = received.iterator();</span><br><span class="hljs-comment">//            while (iterator.hasNext())&#123;</span><br><span class="hljs-comment">//                Message msg = iterator.next();</span><br><span class="hljs-comment">//                if(!msgTreeSet.add(msg))&#123;</span><br><span class="hljs-comment">//                iterator.remove();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br>            msgTreeSet.addAll(received);<br>           <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(msgTreeSet);<br><span class="hljs-comment">//            return received;</span><br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Message&gt; <span class="hljs-title">process</span><span class="hljs-params">(List&lt;Message&gt; received)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 按sequence去除重复消息</span><br>        <span class="hljs-keyword">return</span> received;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sequence;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String text;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequence, String text)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sequence = sequence;<br>        <span class="hljs-keyword">this</span>.text = text;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>Set用于存储不重复的元素集合：</p>
<p>放入HashSet的元素与作为HashMap的key要求相同；<br>放入TreeSet的元素与作为TreeMap的Key要求相同；<br>利用Set可以去除重复元素；</p>
<p>遍历SortedSet按照元素的排序顺序遍历，也可以自定义排序算法。</p>
<h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><p>队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p>
<p>把元素添加到队列末尾；<br>从队列头部取出元素。<br>超市的收银台就是一个队列：</p>
<h3 id="Queue-头删尾插-java中通常用LinkedList实现"><a href="#Queue-头删尾插-java中通常用LinkedList实现" class="headerlink" title="Queue(头删尾插,java中通常用LinkedList实现)"></a>Queue(头删尾插,java中通常用LinkedList实现)</h3><p>在Java的标准库中，队列接口Queue定义了以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>：获取队列长度；</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E)</span>/<span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E)</span>：添加元素到队尾；</span><br><span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span>/E <span class="hljs-title">poll</span><span class="hljs-params">()</span>：获取队首元素并从队列中删除；</span><br><span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span>/E <span class="hljs-title">peek</span><span class="hljs-params">()</span>：获取队首元素但并不从队列中删除。</span><br><span class="hljs-function">对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</span><br><span class="hljs-function">throw Exception	返回<span class="hljs-keyword">false</span>或<span class="hljs-keyword">null</span></span><br><span class="hljs-function">添加元素到队尾	<span class="hljs-title">add</span><span class="hljs-params">(E e)</span>	<span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span><br><span class="hljs-function">取队首元素并删除	E <span class="hljs-title">remove</span><span class="hljs-params">()</span>	E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队首元素但不删除	E <span class="hljs-title">element</span><span class="hljs-params">()</span>	E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>


<p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    q.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们调用offer()方法来添加元素，当添加失败时，它不会抛异常，而是返回false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">if</span> (q.offer(<span class="hljs-string">&quot;Apple&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们需要从Queue中取出队首元素时，如果当前Queue是一个空队列，调用remove()方法，它会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    String s = q.remove();<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们调用poll()方法来取出队首元素，当获取失败时，它不会抛异常，而是返回null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br>String s = q.poll();<br><span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，两套方法可以根据需要来选择使用。</p>
<p>注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。</p>
<p>接下来我们以poll()和peek()为例来说说“获取并删除”与“获取但不删除”的区别。对于Queue来说，每次调用poll()，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 从队列取出元素:</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列是空的</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果用peek()，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 队首永远都是apple，因为peek()不会删除它:</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>从上面的代码中，我们还可以发现，LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个List:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-comment">// 这是一个Queue:</span><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>队列Queue实现了一个先进先出（FIFO）的数据结构：</p>
<p>通过add()/offer()方法将元素添加到队尾；<br>通过remove()/poll()从队首获取元素并删除；<br>通过element()/peek()从队首获取元素但不删除。<br>要避免把null添加到队列。</p>
<h2 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h2><p>我们知道，Queue是一个先进先出（FIFO）的队列。</p>
<p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p>
<p>可以每个人先取一个号，例如：A1、A2、A3……然后，按照号码顺序依次办理，实际上这就是一个Queue。</p>
<p>如果这时来了一个VIP客户，他的号码是V1，虽然当前排队的是A10、A11、A12……但是柜台下一个呼叫的客户号码却是V1。</p>
<p>这个时候，我们发现，要实现“VIP插队”的业务，用Queue就不行了，因为Queue会严格按FIFO的原则取出队首元素。我们需要的是优先队列：PriorityQueue。</p>
<p>PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。</p>
<p>要使用PriorityQueue，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看PriorityQueue的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们放入的顺序是”apple”、”pear”、”banana”，但是取出的顺序却是”apple”、”banana”、”pear”，这是因为从字符串的排序看，”apple”排在最前面，”pear”排在最后面。</p>
<p>因此，放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。</p>
<p>如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个PriorityQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> UserComparator());<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A10&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>        System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br>           <span class="hljs-keyword">if</span>( u1.number.length() == u2.number.length())&#123;<br>                <span class="hljs-keyword">return</span> u1.number.compareTo(u2.number) ;<br>             &#125;<br>                <span class="hljs-keyword">return</span> u1.number.length() &gt; u2.number.length() ? <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>            <span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现PriorityQueue的关键在于提供的UserComparator对象，它负责比较两个元素的大小（较小的在前）。UserComparator总是把V开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p>
<p>上面的UserComparator的比较逻辑其实还是有问题的，它会把A10排在A2的前面，请尝试修复该错误。</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>PriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</p>
<p>PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）。</p>
<h2 id="双端队列Deque（Double-Ended-Queue）"><a href="#双端队列Deque（Double-Ended-Queue）" class="headerlink" title="双端队列Deque（Double Ended Queue）"></a>双端队列Deque（Double Ended Queue）</h2><p>我们知道，Queue是队列，只能一头进，另一头出。</p>
<p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。</p>
<p>Java集合提供了接口Deque来实现一个双端队列，它的功能是：</p>
<p>既可以添加到队尾，也可以添加到队首；<br>既可以从队首获取，又可以从队尾获取。<br>我们来比较一下Queue和Deque出队和入队的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue	Deque<br>添加元素到队尾	add(E e) / offer(E e)	addLast(E e) / offerLast(E e)<br>取队首元素并删除	<span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span> / E <span class="hljs-title">poll</span><span class="hljs-params">()</span>	E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> / E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队首元素但不删除	E <span class="hljs-title">element</span><span class="hljs-params">()</span> / E <span class="hljs-title">peek</span><span class="hljs-params">()</span>	E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> / E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">添加元素到队首	无	<span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> / <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span><br><span class="hljs-function">取队尾元素并删除	无	E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> / E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队尾元素但不删除	无	E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> / E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">对于添加元素到队尾的操作，Queue提供了<span class="hljs-title">add</span><span class="hljs-params">()</span>/<span class="hljs-title">offer</span><span class="hljs-params">()</span>方法，而Deque提供了<span class="hljs-title">addLast</span><span class="hljs-params">()</span>/<span class="hljs-title">offerLast</span><span class="hljs-params">()</span>方法。添加元素到对首、取队尾元素的操作在Queue中不存在，在Deque中由<span class="hljs-title">addFirst</span><span class="hljs-params">()</span>/<span class="hljs-title">removeLast</span><span class="hljs-params">()</span>等方法提供。</span><br></code></pre></td></tr></table></figure>

<p>注意到Deque接口实际上扩展自Queue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>因此，Queue提供的add()/offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        deque.offerLast(<span class="hljs-string">&quot;A&quot;</span>); <span class="hljs-comment">// A</span><br>        deque.offerLast(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// A &lt;- B</span><br>        deque.offerFirst(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// C &lt;- A &lt;- B</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// C, 剩下A &lt;- B</span><br>        System.out.println(deque.pollLast()); <span class="hljs-comment">// B, 剩下A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如果直接写deque.offer()，我们就需要思考，offer()实际上是offerLast()，我们明确地写上offerLast()，不需要思考就能一眼看出这是添加到队尾。</p>
<p>因此，使用Deque，推荐总是明确调用offerLast()/offerFirst()或者pollFirst()/pollLast()方法。</p>
<p>Deque是一个接口，它的实现类有ArrayDeque和LinkedList。</p>
<p>我们发现LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>
<p>// 不推荐的写法:<br>LinkedList<String> d1 = new LinkedList&lt;&gt;();<br>d1.offerLast(“z”);<br>// 推荐的写法：<br>Deque<String> d2 = new LinkedList&lt;&gt;();<br>d2.offerLast(“z”);<br>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>Deque实现了一个双端队列（Double Ended Queue），它可以：</p>
<p>将元素添加到队尾或队首：addLast()/offerLast()/addFirst()/offerFirst()；<br>从队首／队尾获取元素并删除：removeFirst()/pollFirst()/removeLast()/pollLast()；<br>从队首／队尾获取元素但不删除：getFirst()/peekFirst()/getLast()/peekLast()；<br>总是调用xxxFirst()/xxxLast()以便与Queue的方法区分开；<br>避免把null添加到队列。</p>
<h2 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>
<p>什么是LIFO呢？我们先回顾一下Queue的特点FIFO：</p>
<div class="code-wrapper"><pre><code class="hljs">      ────────────────────────
</code></pre></div>
<p>  ((\      ((\    ((\    ((\      ((<br> (=’.’) ─&gt; (=’.’)  (=’.’)  (=’.’) ─&gt; (=’.’)<br>O(<em>“)”)   O(</em>“)”) O(<em>“)”) O(</em>“)”)   O(_”)”)<br>          ────────────────────────<br>所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进Stack的元素一定最早出Stack。如何做到这一点呢？只需要把队列的一端封死：</p>
<div class="code-wrapper"><pre><code class="hljs">       ───────────────────────────────┐
</code></pre></div>
<p>  ((\       ((\    ((\    ((\    ((\ │<br> (=’.’) &lt;─&gt; (=’.’)  (=’.’)  (=’.’)  (=’.’)│<br>O(<em>“)”)    O(</em>“)”) O(<em>“)”) O(</em>“)”) O(_”)”)│<br>           ───────────────────────────────┘<br>因此，Stack是这样一种数据结构：只能不断地往Stack中压入（push）元素，最后进去的必须最早弹出（pop）来：</p>
<p>Stack只有入栈和出栈的操作：</p>
<p>把元素压栈：<code>push(E)</code>；<br>把栈顶的元素“弹出”：<code>pop()</code>；<br>取栈顶元素但不弹出：<code>peek()</code>。<br>在Java中，我们用Deque可以实现Stack的功能：</p>
<p>把元素压栈：<code>push(E)/addFirst(E)</code>；<br>把栈顶的元素“弹出”：<code>pop()/removeFirst()</code>；<br>取栈顶元素但不弹出：<code>peek()/peekFirst()</code>。<br>为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。</p>
<p>当我们把Deque作为Stack使用时，注意只调用<code>push()/pop()/peek()</code>方法，不要调用<code>addFirst()/removeFirst()/peekFirst()</code>方法，这样代码更加清晰。</p>
<h3 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h3><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    foo(<span class="hljs-number">123</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">foo</span><span class="hljs-params">(x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;F-&quot;</span> + bar(x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p>
<p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发StackOverflowError：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试无限递归调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        increase(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">increase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> increase(x) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h3><p>我们再来看一个Stack的用途：对整数进行进制的转换就可以利用栈。</p>
<p>例如，我们要把一个int整数12500转换为十六进制表示的字符串，如何实现这个功能？</p>
<p>首先我们准备一个空栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后计算12500÷16=781…4，余数是4，把余数4压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算781÷16=48…13，余数是13，13的十六进制用字母D表示，把余数D压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算48÷16=3…0，余数是0，把余数0压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│ 0 │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>最后计算3÷16=0…3，余数是3，把余数3压栈：</p>
<p>│    │<br>│ 3 │<br>│    │<br>│ 0 │<br>│    │<br>│ D │<br>│    │<br>│ 4    │<br>└───┘<br>当商是0的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串30D4，这就是十进制整数12500的十六进制表示的字符串。</p>
<h3 id="计算中缀表达式"><a href="#计算中缀表达式" class="headerlink" title="计算中缀表达式"></a>计算中缀表达式</h3><p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：1 + 2 * (9 - 5)。</p>
<p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：1 2 9 5 - * +。</p>
<p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p>
<p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后我们依次扫描后缀表达式1 2 9 5 - * +，遇到数字1，就直接扔到栈里：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 1 │<br>└───┘<br>紧接着，遇到数字2，9，5，也扔到栈里：</p>
<p>│   │<br>│ 5 │<br>│   │<br>│ 9 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到减号时，弹出栈顶的两个元素，并计算9-5=4，把结果4压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│ 4 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到<em>号时，弹出栈顶的两个元素，并计算2</em>4=8，把结果8压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 8 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到+号时，弹出栈顶的两个元素，并计算1+8=9，把结果9压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 9 │<br>└───┘<br>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果9。</p>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>请利用Stack把一个给定的整数转换为十六进制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转十六进制</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String hex = toHex(<span class="hljs-number">12500</span>);<br>        <span class="hljs-keyword">if</span> (hex.equalsIgnoreCase(<span class="hljs-string">&quot;30D4&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试通过&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="进阶练习："><a href="#进阶练习：" class="headerlink" title="进阶练习："></a>进阶练习：</h3><p>请利用Stack把字符串中缀表达式编译为后缀表达式，然后再利用栈执行后缀表达式获得计算结果：</p>
<p>// 高难度练习，慎重选择！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String exp = <span class="hljs-string">&quot;1 + 2 * (9 - 5)&quot;</span>;<br>        SuffixExpression se = compile(exp);<br>        <span class="hljs-keyword">int</span> result = se.execute();<br>        System.out.println(exp + <span class="hljs-string">&quot; = &quot;</span> + result + <span class="hljs-string">&quot; &quot;</span> + (result == <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">9</span> - <span class="hljs-number">5</span>) ? <span class="hljs-string">&quot;✓&quot;</span> : <span class="hljs-string">&quot;✗&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> SuffixExpression <span class="hljs-title">compile</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuffixExpression();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuffixExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="进阶练习2："><a href="#进阶练习2：" class="headerlink" title="进阶练习2："></a>进阶练习2：</h3><p>请把带变量的中缀表达式编译为后缀表达式，执行后缀表达式时，传入变量的值并获得计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String exp = <span class="hljs-string">&quot;x + 2 * (y - 5)&quot;</span>;<br>        SuffixExpression se = compile(exp);<br>        Map&lt;String, Integer&gt; env = Map.of(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">9</span>);<br>        <span class="hljs-keyword">int</span> result = se.execute(env);<br>        System.out.println(exp + <span class="hljs-string">&quot; = &quot;</span> + result + <span class="hljs-string">&quot; &quot;</span> + (result == <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">9</span> - <span class="hljs-number">5</span>) ? <span class="hljs-string">&quot;✓&quot;</span> : <span class="hljs-string">&quot;✗&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> SuffixExpression <span class="hljs-title">compile</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuffixExpression();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuffixExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(Map&lt;String, Integer&gt; env)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p>
<p>把元素压栈：push(E)；<br>把栈顶的元素“弹出”：pop(E)；<br>取栈顶元素但不弹出：peek(E)。<br>在Java中，我们用Deque可以实现Stack的功能，注意只调用push()/pop()/peek()方法，避免调用Deque的其他方法。</p>
<p>最后，不要使用遗留类Stack。</p>
<h2 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h2><p>Java的集合类都可以使用for each循环，List、Set和Queue会迭代每个元素，Map会迭代每个key。以List为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际上，Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>     String s = it.next();<br>     System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们把这种通过Iterator对象遍历集合的模式称为迭代器。</p>
<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>
<p>例如，我们虽然知道ArrayList在内部是以数组形式存储元素，并且，它还提供了get(int)方法。虽然我们可以用for循环遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    Object value = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。</p>
<p><code>用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。</code></p>
<p>如果我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件：</p>
<p>集合类实现Iterable接口，该接口要求返回一个Iterator对象；<br>用Iterator对象迭代集合内部数据。</p>
<p>这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。</p>
<p>一个简单的Iterator示例如下，它总是以倒序遍历集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReverseList&lt;String&gt; rlist = <span class="hljs-keyword">new</span> ReverseList&lt;&gt;();<br>        rlist.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Orange&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Pear&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : rlist) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        list.add(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReverseIterator(list.size());<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> index;<br><br>        ReverseIterator(<span class="hljs-keyword">int</span> index) &#123;<br>            <span class="hljs-keyword">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            index--;<br>            <span class="hljs-keyword">return</span> ReverseList.<span class="hljs-keyword">this</span>.list.get(index);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然ReverseList和ReverseIterator的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按for each循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p>
<p>在编写Iterator的时候，我们通常可以用一个内部类来实现Iterator接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类ReverseIterator可以用ReverseList.this获得当前外部类的this引用，然后，通过这个this引用就可以访问ReverseList的所有字段和方法。</p>
<h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>Iterator是一种抽象的数据访问模型。使用Iterator模式进行迭代的好处有：</p>
<p>对任何集合都采用同一种访问模型；<br>调用者对集合内部结构一无所知；<br>集合类返回的Iterator对象知道如何迭代。<br>Java提供了标准的迭代器模型，即集合类实现java.util.Iterable接口，返回java.util.Iterator实例。</p>
<h2 id="使用Collections"><a href="#使用Collections" class="headerlink" title="使用Collections"></a>使用Collections</h2><p>Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
<p> 注意Collections结尾多了一个s，不是Collection！<br>我们一般看方法名和参数就可以确认Collections提供的该方法的功能。例如，对于以下静态方法：</p>
<p>public static boolean addAll(Collection&lt;? super T&gt; c, T… elements) { … }<br>addAll()方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。</p>
<h3 id="创建空集合-不可变集合"><a href="#创建空集合-不可变集合" class="headerlink" title="创建空集合(不可变集合)"></a>创建空集合(不可变集合)</h3><p>Collections提供了一系列方法来创建空集合：</p>
<p>创建空List：List<T> emptyList()<br>创建空Map：Map&lt;K, V&gt; emptyMap()<br>创建空Set：Set<T> emptySet()<br>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的of(T…)方法创建空集合。例如，以下创建空List的两个方法是等价的：</p>
<p>List<String> list1 = List.of();<br>List<String> list2 = Collections.emptyList();</p>
<h3 id="创建单元素集合-不可变"><a href="#创建单元素集合-不可变" class="headerlink" title="创建单元素集合(不可变)"></a>创建单元素集合(不可变)</h3><p>Collections提供了一系列方法来创建一个单元素集合：</p>
<p>创建一个元素的List：List<T> singletonList(T o)<br>创建一个元素的Map：Map&lt;K, V&gt; singletonMap(K key, V value)<br>创建一个元素的Set：Set<T> singleton(T o)<br>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的of(T…)方法创建单元素集合。例如，以下创建单元素List的两个方法是等价的：</p>
<p>List<String> list1 = List.of(“apple”);<br>List<String> list2 = Collections.singletonList(“apple”);<br>实际上，使用List.of(T…)更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>
<p>List<String> list1 = List.of(); // empty list<br>List<String> list2 = List.of(“apple”); // 1 element<br>List<String> list3 = List.of(“apple”, “pear”); // 2 elements<br>List<String> list4 = List.of(“apple”, “pear”, “orange”); // 3 elements</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> list = new ArrayList&lt;&gt;();<br>        list.add(“apple”);<br>        list.add(“pear”);<br>        list.add(“orange”);<br>        // 排序前:<br>        System.out.println(list);<br>        Collections.sort(list);<br>        // 排序后:<br>        System.out.println(list);<br>    }<br>}</p>
<h3 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h3><p>Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<Integer> list = new ArrayList&lt;&gt;();<br>        for (int i=0; i&lt;10; i++) {<br>            list.add(i);<br>        }<br>        // 洗牌前:<br>        System.out.println(list);<br>        Collections.shuffle(list);<br>        // 洗牌后:<br>        System.out.println(list);<br>    }<br>}</p>
<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>Collections还提供了一组方法把可变集合封装成不可变集合：</p>
<p>封装成不可变List：List<T> unmodifiableList(List&lt;? extends T&gt; list)<br>封装成不可变Set：Set<T> unmodifiableSet(Set&lt;? extends T&gt; set)<br>封装成不可变Map：Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)<br>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        immutable.add(“orange”); // UnsupportedOperationException!<br>    }<br>}</p>
<p>然而，继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        mutable.add(“orange”);<br>        System.out.println(immutable);<br>    }<br>}</p>
<p>因此，如果我们希望把一个可变List封装成不可变List，那么，返回不可变List后，最好立刻扔掉可变List的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”List变化了：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        // 立刻扔掉mutable的引用:<br>        mutable = null;<br>        System.out.println(immutable);<br>    }<br>}</p>
<h3 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h3><p>Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<p>变为线程安全的List：List<T> synchronizedList(List<T> list)<br>变为线程安全的Set：Set<T> synchronizedSet(Set<T> s)<br>变为线程安全的Map：Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)<br>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>
<h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>Collections类提供了一组工具方法来方便使用集合类：</p>
<p>创建空集合；<br>创建单元素集合；<br>创建不可变集合；<br>排序／洗牌等操作。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Core/">Core</a>
                    
                      <a class="hover-with-bg" href="/categories/Core/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Core/Java/6-%E9%9B%86%E5%90%88/">6.集合</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/05/Core/Java/6.%E9%9B%86%E5%90%88/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">常用集合工具类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/05/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E5%85%83%E6%B3%A8%E8%A7%A3/">
                        <span class="hidden-mobile">元注解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
