

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="czk997">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合： 123String[] ss &#x3D; new String[10]; &#x2F;&#x2F; 可以持有10个String对象ss[0] &#x3D; &quot;Hello&quot;; &#x2F;&#x2F; 可以放入String对象String first &#x3D; ss[0];">
<meta property="og:type" content="article">
<meta property="og:title" content="集合基础">
<meta property="og:url" content="https://czk997.github.io/2022/01/05/Base/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/">
<meta property="og:site_name" content="La La Land">
<meta property="og:description" content="概述在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合： 123String[] ss &#x3D; new String[10]; &#x2F;&#x2F; 可以持有10个String对象ss[0] &#x3D; &quot;Hello&quot;; &#x2F;&#x2F; 可以放入String对象String first &#x3D; ss[0];">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://czk997.github.io/2022/01/05/Base/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/README.assets/image-20211222153755858.png">
<meta property="og:image" content="https://czk997.github.io/2022/01/05/Base/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80.assets/image-20211222204919210.png">
<meta property="article:published_time" content="2022-01-05T10:14:15.918Z">
<meta property="article:modified_time" content="2022-01-05T10:14:15.918Z">
<meta property="article:author" content="czk997">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://czk997.github.io/2022/01/05/Base/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/README.assets/image-20211222153755858.png">
  
  
  <title>集合基础 - La La Land</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"czk997.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="集合基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-05 18:14" pubdate>
        星期三, 一月 5日 2022, 6:14 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">集合基础</h1>
            
            <div class="markdown-body">
              <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span>[] ss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 可以持有10个String对象</span><br>ss[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 可以放入String对象</span><br><span class="hljs-keyword">String</span> first = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 可以获取String对象</span><br></code></pre></td></tr></table></figure>

<p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>
<ul>
<li>数组初始化后大小不可变；</li>
<li>数组只能按索引顺序存取。</li>
</ul>
<p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>
<ul>
<li>可变大小的顺序链表；</li>
<li>保证无重复元素的集合；</li>
<li>…</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
<li>还包括Queue等</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 只能放入String类型</span><br></code></pre></td></tr></table></figure>

<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>
</ul>
<p><img src="README.assets/image-20211222153755858.png" srcset="/img/loading.gif" lazyload alt="image-20211222153755858"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p>
<h1 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h1><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p>
<p><code>List</code>的行为和数组几乎完全相同：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从<code>0</code>开始。</p>
<p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;&#125;</code>中删除索引为<code>2</code>的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br>              │   │<br>          ┌───┘   │<br>          │   ┌───┘<br>          │   │<br>          ▼   ▼<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ D │ E │   │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>这个“删除”操作实际上是把<code>&#39;C&#39;</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p>
<p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个<code>ArrayList</code>拥有5个元素，实际数组大小为<code>6</code>（即有一个空位）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │   │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=6<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=6<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=7<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure>

<p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>
<p>我们考察<code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>但是，实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。在<code>LinkedList</code>中，它的内部每个元素都指向下一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐<br>HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │<br>        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘<br></code></pre></td></tr></table></figure>

<p>我们来比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td align="left">需要从头开始查找元素(越大越慢)</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td align="left">不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td align="left">较大(除了存储数据还需存储指针)</td>
</tr>
</tbody></table>
<p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p>
<h3 id="List的特点"><a href="#List的特点" class="headerlink" title="List的特点"></a>List的特点</h3><p>使用<code>List</code>时，我们要关注<code>List</code>接口的规范。<code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.add(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=2</span><br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// 允许重复添加元素，size=3</span><br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>List还允许添加null：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class Main &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// size=2</span><br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=3</span><br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">second</span> = list.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// null</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">second</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建List"><a href="#创建List" class="headerlink" title="创建List"></a>创建List</h3><p>除了使用<code>ArrayList</code>和<code>LinkedList</code>，我们还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>(java9:返回的是对象不可变列表,列表不可变,列表内的数据可能会变)：</p>
<p>在java8中的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>stringList = Collections.unmodifiableList(stringList);<span class="hljs-comment">//数据集不改变,数据可能会变</span><br></code></pre></td></tr></table></figure>

<p>java9中写法:返回不可变数据集</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">List</span>&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p>
<h3 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h3><p>和数组类型，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">String</span> s = list.<span class="hljs-built_in">get</span>(i);<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但这种方式并不推荐，一是代码复杂，二是因为**<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。**</p>
<p><strong>所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code><strong>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。</strong><code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</strong></p>
<p><strong>即对于不同List,迭代器对象具有最高访问效率的实现</strong></p>
<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;<span class="hljs-keyword">String</span>&gt; it = list.<span class="hljs-built_in">iterator</span>(); it.<span class="hljs-built_in">hasNext</span>(); ) &#123;<br>            <span class="hljs-keyword">String</span> s = it.<span class="hljs-built_in">next</span>();<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> s : list) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p>
<p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。</p>
<h3 id="List和Array转换"><a href="#List和Array转换" class="headerlink" title="List和Array转换"></a>List和Array转换</h3><p>把<code>List</code>变为<code>Array</code>有三种方法，第一种是调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        Object[] array = list.<span class="hljs-built_in">toArray</span>();<br>        <span class="hljs-keyword">for</span> (Object s : array) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这种方法会丢失类型信息，所以实际应用很少。</strong></p>
<p>第二种方式是给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>]);<br>        <span class="hljs-keyword">for</span> (Integer n : array) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意到这个<code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入<code>Number</code>类型的数组，返回的仍然是<code>Number</code>类型：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">import java.util.<span class="hljs-class">List;</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> class Main &#123;<br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>        List&lt;Integer&gt; list = List.of(12, 34, 56);<br>        Number[]<span class="hljs-built_in"> array </span>= list.toArray(new Number[3]);<br>        for (Number n<span class="hljs-keyword"> :</span> array) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p>
<p>如果我们传入的数组大小和<code>List</code>实际的元素个数不一致怎么办？根据<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray(T[])">List接口</a>的文档，我们可以知道：</p>
<p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；<strong>如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>(int填0)。</strong></p>
<p>实际上，最常用的是传入一个“恰好”大小的数组：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= list.toArray(new Integer[list.size()]);<br></code></pre></td></tr></table></figure>

<p><strong>最后一种更简洁的写法是通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法</strong>：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= list.toArray(Integer[]::new);<br></code></pre></td></tr></table></figure>

<p>这种函数式写法我们会在后续讲到。</p>
<p>反过来，把<code>Array</code>变为<code>List</code>就简单多了，通过<code>List.of(T...)</code>方法最简单：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= &#123; 1, 2, 3 &#125;;<br>List&lt;Integer&gt; list = List.of(array);<br></code></pre></td></tr></table></figure>

<p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p>
<p>要注意的是，List.of(array)返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        list.add(<span class="hljs-number">999</span>); <span class="hljs-comment">// UnsupportedOperationException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造从start到end的序列：</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = <span class="hljs-number">20</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 随机删除List中的一个元素:</span><br>        <span class="hljs-keyword">int</span> removed = list.remove((<span class="hljs-keyword">int</span>) (Math.random() * list.size()));<br>        <span class="hljs-keyword">int</span> found = findMissingNumber(start, end, list);<br>        System.out.println(list.toString());<br>        System.out.println(<span class="hljs-string">&quot;missing number: &quot;</span> + found);<br>        System.out.println(removed == found ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMissingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) != start) &#123;<br>                <span class="hljs-keyword">return</span> start;<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>增强版：和上述题目一样，但整数不再有序，试找出缺失的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造从start到end的序列：</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = <span class="hljs-number">20</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 洗牌算法shuffle可以随机交换List中的元素位置:</span><br>        Collections.shuffle(list);<br>        <span class="hljs-comment">// 随机删除List中的一个元素:</span><br>        <span class="hljs-keyword">int</span> removed = list.remove((<span class="hljs-keyword">int</span>) (Math.random() * list.size()));<br>        <span class="hljs-keyword">int</span> found = findMissingNumber(start, end, list);<br>        System.out.println(list.toString());<br>        System.out.println(<span class="hljs-string">&quot;missing number: &quot;</span> + found);<br>        System.out.println(removed == found ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO </span><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMissingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, List&lt;Integer&gt; list)</span> </span>&#123;<br>         <span class="hljs-keyword">while</span>(start &lt;= end)&#123;<br>            <span class="hljs-keyword">if</span>(list.contains(start))&#123;<br>                start++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//还有一种方法  用等差数列求和公式,算出原集合和之后集合的差值</span><br> <span class="hljs-keyword">int</span> sum = (start + end) * (end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>              <span class="hljs-keyword">int</span> all = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">for</span>(Integer i:list) &#123;<br>                  all += i;<br>              &#125;<br>              <span class="hljs-keyword">return</span> sum - all;<br></code></pre></td></tr></table></figure>

<p><img src="%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80.assets/image-20211222204919210.png" srcset="/img/loading.gif" lazyload alt="image-20211222204919210"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p>
<p>可以直接使用<code>for each</code>遍历<code>List</code>；</p>
<p><code>List</code>可以和<code>Array</code>相互转换。</p>
<h1 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h1><h1 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h1><h1 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h1><h1 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h1><h1 id="使用TreeMap"><a href="#使用TreeMap" class="headerlink" title="使用TreeMap"></a>使用TreeMap</h1><h1 id="使用Properties"><a href="#使用Properties" class="headerlink" title="使用Properties"></a>使用Properties</h1><h1 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h1><h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><p>队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p>
<p>把元素添加到队列末尾；<br>从队列头部取出元素。<br>超市的收银台就是一个队列：</p>
<h3 id="Queue-头删尾插-java中通常用LinkedList实现"><a href="#Queue-头删尾插-java中通常用LinkedList实现" class="headerlink" title="Queue(头删尾插,java中通常用LinkedList实现)"></a>Queue(头删尾插,java中通常用LinkedList实现)</h3><p>在Java的标准库中，队列接口Queue定义了以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>：获取队列长度；</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E)</span>/<span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E)</span>：添加元素到队尾；</span><br><span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span>/E <span class="hljs-title">poll</span><span class="hljs-params">()</span>：获取队首元素并从队列中删除；</span><br><span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span>/E <span class="hljs-title">peek</span><span class="hljs-params">()</span>：获取队首元素但并不从队列中删除。</span><br><span class="hljs-function">对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</span><br><span class="hljs-function">throw Exception	返回<span class="hljs-keyword">false</span>或<span class="hljs-keyword">null</span></span><br><span class="hljs-function">添加元素到队尾	<span class="hljs-title">add</span><span class="hljs-params">(E e)</span>	<span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span><br><span class="hljs-function">取队首元素并删除	E <span class="hljs-title">remove</span><span class="hljs-params">()</span>	E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队首元素但不删除	E <span class="hljs-title">element</span><span class="hljs-params">()</span>	E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>


<p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    q.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们调用offer()方法来添加元素，当添加失败时，它不会抛异常，而是返回false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">if</span> (q.offer(<span class="hljs-string">&quot;Apple&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们需要从Queue中取出队首元素时，如果当前Queue是一个空队列，调用remove()方法，它会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    String s = q.remove();<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们调用poll()方法来取出队首元素，当获取失败时，它不会抛异常，而是返回null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br>String s = q.poll();<br><span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，两套方法可以根据需要来选择使用。</p>
<p>注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。</p>
<p>接下来我们以poll()和peek()为例来说说“获取并删除”与“获取但不删除”的区别。对于Queue来说，每次调用poll()，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 从队列取出元素:</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列是空的</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果用peek()，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 队首永远都是apple，因为peek()不会删除它:</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>从上面的代码中，我们还可以发现，LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个List:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-comment">// 这是一个Queue:</span><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>队列Queue实现了一个先进先出（FIFO）的数据结构：</p>
<p>通过add()/offer()方法将元素添加到队尾；<br>通过remove()/poll()从队首获取元素并删除；<br>通过element()/peek()从队首获取元素但不删除。<br>要避免把null添加到队列。</p>
<h2 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h2><p>我们知道，Queue是一个先进先出（FIFO）的队列。</p>
<p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p>
<p>可以每个人先取一个号，例如：A1、A2、A3……然后，按照号码顺序依次办理，实际上这就是一个Queue。</p>
<p>如果这时来了一个VIP客户，他的号码是V1，虽然当前排队的是A10、A11、A12……但是柜台下一个呼叫的客户号码却是V1。</p>
<p>这个时候，我们发现，要实现“VIP插队”的业务，用Queue就不行了，因为Queue会严格按FIFO的原则取出队首元素。我们需要的是优先队列：PriorityQueue。</p>
<p>PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。</p>
<p>要使用PriorityQueue，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看PriorityQueue的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们放入的顺序是”apple”、”pear”、”banana”，但是取出的顺序却是”apple”、”banana”、”pear”，这是因为从字符串的排序看，”apple”排在最前面，”pear”排在最后面。</p>
<p>因此，放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。</p>
<p>如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个PriorityQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> UserComparator());<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A10&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>        System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br>           <span class="hljs-keyword">if</span>( u1.number.length() == u2.number.length())&#123;<br>                <span class="hljs-keyword">return</span> u1.number.compareTo(u2.number) ;<br>             &#125;<br>                <span class="hljs-keyword">return</span> u1.number.length() &gt; u2.number.length() ? <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>            <span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现PriorityQueue的关键在于提供的UserComparator对象，它负责比较两个元素的大小（较小的在前）。UserComparator总是把V开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p>
<p>上面的UserComparator的比较逻辑其实还是有问题的，它会把A10排在A2的前面，请尝试修复该错误。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>PriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</p>
<p>PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）。</p>
<h2 id="双端队列Deque（Double-Ended-Queue）"><a href="#双端队列Deque（Double-Ended-Queue）" class="headerlink" title="双端队列Deque（Double Ended Queue）"></a>双端队列Deque（Double Ended Queue）</h2><p>我们知道，Queue是队列，只能一头进，另一头出。</p>
<p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。</p>
<p>Java集合提供了接口Deque来实现一个双端队列，它的功能是：</p>
<p>既可以添加到队尾，也可以添加到队首；<br>既可以从队首获取，又可以从队尾获取。<br>我们来比较一下Queue和Deque出队和入队的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue	Deque<br>添加元素到队尾	add(E e) / offer(E e)	addLast(E e) / offerLast(E e)<br>取队首元素并删除	<span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span> / E <span class="hljs-title">poll</span><span class="hljs-params">()</span>	E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> / E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队首元素但不删除	E <span class="hljs-title">element</span><span class="hljs-params">()</span> / E <span class="hljs-title">peek</span><span class="hljs-params">()</span>	E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> / E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">添加元素到队首	无	<span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> / <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span><br><span class="hljs-function">取队尾元素并删除	无	E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> / E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队尾元素但不删除	无	E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> / E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">对于添加元素到队尾的操作，Queue提供了<span class="hljs-title">add</span><span class="hljs-params">()</span>/<span class="hljs-title">offer</span><span class="hljs-params">()</span>方法，而Deque提供了<span class="hljs-title">addLast</span><span class="hljs-params">()</span>/<span class="hljs-title">offerLast</span><span class="hljs-params">()</span>方法。添加元素到对首、取队尾元素的操作在Queue中不存在，在Deque中由<span class="hljs-title">addFirst</span><span class="hljs-params">()</span>/<span class="hljs-title">removeLast</span><span class="hljs-params">()</span>等方法提供。</span><br></code></pre></td></tr></table></figure>

<p>注意到Deque接口实际上扩展自Queue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>因此，Queue提供的add()/offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        deque.offerLast(<span class="hljs-string">&quot;A&quot;</span>); <span class="hljs-comment">// A</span><br>        deque.offerLast(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// A &lt;- B</span><br>        deque.offerFirst(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// C &lt;- A &lt;- B</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// C, 剩下A &lt;- B</span><br>        System.out.println(deque.pollLast()); <span class="hljs-comment">// B, 剩下A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如果直接写deque.offer()，我们就需要思考，offer()实际上是offerLast()，我们明确地写上offerLast()，不需要思考就能一眼看出这是添加到队尾。</p>
<p>因此，使用Deque，推荐总是明确调用offerLast()/offerFirst()或者pollFirst()/pollLast()方法。</p>
<p>Deque是一个接口，它的实现类有ArrayDeque和LinkedList。</p>
<p>我们发现LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>
<p>// 不推荐的写法:<br>LinkedList<String> d1 = new LinkedList&lt;&gt;();<br>d1.offerLast(“z”);<br>// 推荐的写法：<br>Deque<String> d2 = new LinkedList&lt;&gt;();<br>d2.offerLast(“z”);<br>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Deque实现了一个双端队列（Double Ended Queue），它可以：</p>
<p>将元素添加到队尾或队首：addLast()/offerLast()/addFirst()/offerFirst()；<br>从队首／队尾获取元素并删除：removeFirst()/pollFirst()/removeLast()/pollLast()；<br>从队首／队尾获取元素但不删除：getFirst()/peekFirst()/getLast()/peekLast()；<br>总是调用xxxFirst()/xxxLast()以便与Queue的方法区分开；<br>避免把null添加到队列。</p>
<h2 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>
<p>什么是LIFO呢？我们先回顾一下Queue的特点FIFO：</p>
<div class="code-wrapper"><pre><code class="hljs">      ────────────────────────
</code></pre></div>
<p>  ((\      ((\    ((\    ((\      ((<br> (=’.’) ─&gt; (=’.’)  (=’.’)  (=’.’) ─&gt; (=’.’)<br>O(<em>“)”)   O(</em>“)”) O(<em>“)”) O(</em>“)”)   O(_”)”)<br>          ────────────────────────<br>所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进Stack的元素一定最早出Stack。如何做到这一点呢？只需要把队列的一端封死：</p>
<div class="code-wrapper"><pre><code class="hljs">       ───────────────────────────────┐
</code></pre></div>
<p>  ((\       ((\    ((\    ((\    ((\ │<br> (=’.’) &lt;─&gt; (=’.’)  (=’.’)  (=’.’)  (=’.’)│<br>O(<em>“)”)    O(</em>“)”) O(<em>“)”) O(</em>“)”) O(_”)”)│<br>           ───────────────────────────────┘<br>因此，Stack是这样一种数据结构：只能不断地往Stack中压入（push）元素，最后进去的必须最早弹出（pop）来：</p>
<p>Stack只有入栈和出栈的操作：</p>
<p>把元素压栈：<code>push(E)</code>；<br>把栈顶的元素“弹出”：<code>pop()</code>；<br>取栈顶元素但不弹出：<code>peek()</code>。<br>在Java中，我们用Deque可以实现Stack的功能：</p>
<p>把元素压栈：<code>push(E)/addFirst(E)</code>；<br>把栈顶的元素“弹出”：<code>pop()/removeFirst()</code>；<br>取栈顶元素但不弹出：<code>peek()/peekFirst()</code>。<br>为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。</p>
<p>当我们把Deque作为Stack使用时，注意只调用<code>push()/pop()/peek()</code>方法，不要调用<code>addFirst()/removeFirst()/peekFirst()</code>方法，这样代码更加清晰。</p>
<h3 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h3><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    foo(<span class="hljs-number">123</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">foo</span><span class="hljs-params">(x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;F-&quot;</span> + bar(x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p>
<p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发StackOverflowError：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试无限递归调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        increase(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">increase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> increase(x) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h3><p>我们再来看一个Stack的用途：对整数进行进制的转换就可以利用栈。</p>
<p>例如，我们要把一个int整数12500转换为十六进制表示的字符串，如何实现这个功能？</p>
<p>首先我们准备一个空栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后计算12500÷16=781…4，余数是4，把余数4压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算781÷16=48…13，余数是13，13的十六进制用字母D表示，把余数D压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算48÷16=3…0，余数是0，把余数0压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│ 0 │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>最后计算3÷16=0…3，余数是3，把余数3压栈：</p>
<p>│    │<br>│ 3 │<br>│    │<br>│ 0 │<br>│    │<br>│ D │<br>│    │<br>│ 4    │<br>└───┘<br>当商是0的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串30D4，这就是十进制整数12500的十六进制表示的字符串。</p>
<h3 id="计算中缀表达式"><a href="#计算中缀表达式" class="headerlink" title="计算中缀表达式"></a>计算中缀表达式</h3><p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：1 + 2 * (9 - 5)。</p>
<p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：1 2 9 5 - * +。</p>
<p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p>
<p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后我们依次扫描后缀表达式1 2 9 5 - * +，遇到数字1，就直接扔到栈里：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 1 │<br>└───┘<br>紧接着，遇到数字2，9，5，也扔到栈里：</p>
<p>│   │<br>│ 5 │<br>│   │<br>│ 9 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到减号时，弹出栈顶的两个元素，并计算9-5=4，把结果4压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│ 4 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到<em>号时，弹出栈顶的两个元素，并计算2</em>4=8，把结果8压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 8 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到+号时，弹出栈顶的两个元素，并计算1+8=9，把结果9压栈：</p>
<p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 9 │<br>└───┘<br>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果9。</p>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>请利用Stack把一个给定的整数转换为十六进制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转十六进制</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String hex = toHex(<span class="hljs-number">12500</span>);<br>        <span class="hljs-keyword">if</span> (hex.equalsIgnoreCase(<span class="hljs-string">&quot;30D4&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试通过&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="进阶练习："><a href="#进阶练习：" class="headerlink" title="进阶练习："></a>进阶练习：</h3><p>请利用Stack把字符串中缀表达式编译为后缀表达式，然后再利用栈执行后缀表达式获得计算结果：</p>
<p>// 高难度练习，慎重选择！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String exp = <span class="hljs-string">&quot;1 + 2 * (9 - 5)&quot;</span>;<br>        SuffixExpression se = compile(exp);<br>        <span class="hljs-keyword">int</span> result = se.execute();<br>        System.out.println(exp + <span class="hljs-string">&quot; = &quot;</span> + result + <span class="hljs-string">&quot; &quot;</span> + (result == <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">9</span> - <span class="hljs-number">5</span>) ? <span class="hljs-string">&quot;✓&quot;</span> : <span class="hljs-string">&quot;✗&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> SuffixExpression <span class="hljs-title">compile</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuffixExpression();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuffixExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="进阶练习2："><a href="#进阶练习2：" class="headerlink" title="进阶练习2："></a>进阶练习2：</h3><p>请把带变量的中缀表达式编译为后缀表达式，执行后缀表达式时，传入变量的值并获得计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String exp = <span class="hljs-string">&quot;x + 2 * (y - 5)&quot;</span>;<br>        SuffixExpression se = compile(exp);<br>        Map&lt;String, Integer&gt; env = Map.of(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">9</span>);<br>        <span class="hljs-keyword">int</span> result = se.execute(env);<br>        System.out.println(exp + <span class="hljs-string">&quot; = &quot;</span> + result + <span class="hljs-string">&quot; &quot;</span> + (result == <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">9</span> - <span class="hljs-number">5</span>) ? <span class="hljs-string">&quot;✓&quot;</span> : <span class="hljs-string">&quot;✗&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> SuffixExpression <span class="hljs-title">compile</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuffixExpression();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuffixExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(Map&lt;String, Integer&gt; env)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p>
<p>把元素压栈：push(E)；<br>把栈顶的元素“弹出”：pop(E)；<br>取栈顶元素但不弹出：peek(E)。<br>在Java中，我们用Deque可以实现Stack的功能，注意只调用push()/pop()/peek()方法，避免调用Deque的其他方法。</p>
<p>最后，不要使用遗留类Stack。</p>
<h2 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h2><p>Java的集合类都可以使用for each循环，List、Set和Queue会迭代每个元素，Map会迭代每个key。以List为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际上，Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>     String s = it.next();<br>     System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们把这种通过Iterator对象遍历集合的模式称为迭代器。</p>
<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>
<p>例如，我们虽然知道ArrayList在内部是以数组形式存储元素，并且，它还提供了get(int)方法。虽然我们可以用for循环遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    Object value = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。</p>
<p><code>用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。</code></p>
<p>如果我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件：</p>
<p>集合类实现Iterable接口，该接口要求返回一个Iterator对象；<br>用Iterator对象迭代集合内部数据。</p>
<p>这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。</p>
<p>一个简单的Iterator示例如下，它总是以倒序遍历集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReverseList&lt;String&gt; rlist = <span class="hljs-keyword">new</span> ReverseList&lt;&gt;();<br>        rlist.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Orange&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Pear&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : rlist) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        list.add(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReverseIterator(list.size());<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> index;<br><br>        ReverseIterator(<span class="hljs-keyword">int</span> index) &#123;<br>            <span class="hljs-keyword">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            index--;<br>            <span class="hljs-keyword">return</span> ReverseList.<span class="hljs-keyword">this</span>.list.get(index);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然ReverseList和ReverseIterator的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按for each循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p>
<p>在编写Iterator的时候，我们通常可以用一个内部类来实现Iterator接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类ReverseIterator可以用ReverseList.this获得当前外部类的this引用，然后，通过这个this引用就可以访问ReverseList的所有字段和方法。</p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>Iterator是一种抽象的数据访问模型。使用Iterator模式进行迭代的好处有：</p>
<p>对任何集合都采用同一种访问模型；<br>调用者对集合内部结构一无所知；<br>集合类返回的Iterator对象知道如何迭代。<br>Java提供了标准的迭代器模型，即集合类实现java.util.Iterable接口，返回java.util.Iterator实例。</p>
<h2 id="使用Collections"><a href="#使用Collections" class="headerlink" title="使用Collections"></a>使用Collections</h2><p>Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
<p> 注意Collections结尾多了一个s，不是Collection！<br>我们一般看方法名和参数就可以确认Collections提供的该方法的功能。例如，对于以下静态方法：</p>
<p>public static boolean addAll(Collection&lt;? super T&gt; c, T… elements) { … }<br>addAll()方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。</p>
<h3 id="创建空集合-不可变集合"><a href="#创建空集合-不可变集合" class="headerlink" title="创建空集合(不可变集合)"></a>创建空集合(不可变集合)</h3><p>Collections提供了一系列方法来创建空集合：</p>
<p>创建空List：List<T> emptyList()<br>创建空Map：Map&lt;K, V&gt; emptyMap()<br>创建空Set：Set<T> emptySet()<br>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的of(T…)方法创建空集合。例如，以下创建空List的两个方法是等价的：</p>
<p>List<String> list1 = List.of();<br>List<String> list2 = Collections.emptyList();</p>
<h3 id="创建单元素集合-不可变"><a href="#创建单元素集合-不可变" class="headerlink" title="创建单元素集合(不可变)"></a>创建单元素集合(不可变)</h3><p>Collections提供了一系列方法来创建一个单元素集合：</p>
<p>创建一个元素的List：List<T> singletonList(T o)<br>创建一个元素的Map：Map&lt;K, V&gt; singletonMap(K key, V value)<br>创建一个元素的Set：Set<T> singleton(T o)<br>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的of(T…)方法创建单元素集合。例如，以下创建单元素List的两个方法是等价的：</p>
<p>List<String> list1 = List.of(“apple”);<br>List<String> list2 = Collections.singletonList(“apple”);<br>实际上，使用List.of(T…)更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>
<p>List<String> list1 = List.of(); // empty list<br>List<String> list2 = List.of(“apple”); // 1 element<br>List<String> list3 = List.of(“apple”, “pear”); // 2 elements<br>List<String> list4 = List.of(“apple”, “pear”, “orange”); // 3 elements</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> list = new ArrayList&lt;&gt;();<br>        list.add(“apple”);<br>        list.add(“pear”);<br>        list.add(“orange”);<br>        // 排序前:<br>        System.out.println(list);<br>        Collections.sort(list);<br>        // 排序后:<br>        System.out.println(list);<br>    }<br>}</p>
<h3 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h3><p>Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<Integer> list = new ArrayList&lt;&gt;();<br>        for (int i=0; i&lt;10; i++) {<br>            list.add(i);<br>        }<br>        // 洗牌前:<br>        System.out.println(list);<br>        Collections.shuffle(list);<br>        // 洗牌后:<br>        System.out.println(list);<br>    }<br>}</p>
<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>Collections还提供了一组方法把可变集合封装成不可变集合：</p>
<p>封装成不可变List：List<T> unmodifiableList(List&lt;? extends T&gt; list)<br>封装成不可变Set：Set<T> unmodifiableSet(Set&lt;? extends T&gt; set)<br>封装成不可变Map：Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)<br>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        immutable.add(“orange”); // UnsupportedOperationException!<br>    }<br>}</p>
<p>然而，继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        mutable.add(“orange”);<br>        System.out.println(immutable);<br>    }<br>}</p>
<p>因此，如果我们希望把一个可变List封装成不可变List，那么，返回不可变List后，最好立刻扔掉可变List的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”List变化了：</p>
<p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        // 立刻扔掉mutable的引用:<br>        mutable = null;<br>        System.out.println(immutable);<br>    }<br>}</p>
<h3 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h3><p>Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<p>变为线程安全的List：List<T> synchronizedList(List<T> list)<br>变为线程安全的Set：Set<T> synchronizedSet(Set<T> s)<br>变为线程安全的Map：Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)<br>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>Collections类提供了一组工具方法来方便使用集合类：</p>
<p>创建空集合；<br>创建单元素集合；<br>创建不可变集合；<br>排序／洗牌等操作。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Base/">Base</a>
                    
                      <a class="hover-with-bg" href="/categories/Base/6-%E9%9B%86%E5%90%88/">6.集合</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/05/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/ControllerAdvice/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ControllerAdvice</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/05/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/">
                        <span class="hidden-mobile">Java核心类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
