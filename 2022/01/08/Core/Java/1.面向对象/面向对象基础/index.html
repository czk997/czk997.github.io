

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="czk997">
  <meta name="keywords" content="">
  
    <meta name="description" content="对象比较&#x3D;&#x3D;判断基本数据类型时,比较的是值 判断对象类型时,两个对象是否指向同一内存地址,和hashCode没有直接关系,只是恰好Object及其继承类的hashCode()方法返回的是内存地址    12345OverRideHashCode a &#x3D; new OverRideHashCode(1);OverRideHashCode b &#x3D; new OverRideHashCode(1);Syst">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象基础">
<meta property="og:url" content="https://czk997.github.io/2022/01/08/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/">
<meta property="og:site_name" content="La La Land">
<meta property="og:description" content="对象比较&#x3D;&#x3D;判断基本数据类型时,比较的是值 判断对象类型时,两个对象是否指向同一内存地址,和hashCode没有直接关系,只是恰好Object及其继承类的hashCode()方法返回的是内存地址    12345OverRideHashCode a &#x3D; new OverRideHashCode(1);OverRideHashCode b &#x3D; new OverRideHashCode(1);Syst">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://czk997.github.io/2022/01/08/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125145808108.png!%5Bimage-20211125150343680%5D(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125150343680.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/690292/201609/690292-20160923095944481-1758567758.png">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l">
<meta property="article:published_time" content="2022-01-07T22:15:05.544Z">
<meta property="article:modified_time" content="2022-01-07T22:15:05.544Z">
<meta property="article:author" content="czk997">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://czk997.github.io/2022/01/08/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125145808108.png!%5Bimage-20211125150343680%5D(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125150343680.png">
  
  
  <title>面向对象基础 - La La Land</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"czk997.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="面向对象基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-08 06:15" pubdate>
        星期六, 一月 8日 2022, 6:15 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面向对象基础</h1>
            
            <div class="markdown-body">
              <h1 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h1><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>判断基本数据类型时,比较的是值</p>
<p>判断对象类型时,两个对象是否指向同一内存地址,和hashCode没有直接关系,只是恰好Object及其继承类的hashCode()方法返回的是内存地址</p>
<!-- 
                <source src="https://ccm.91p52.com/358999.mp4?st=6dX3e0ya0njWeGIALSBPrA&f=ed08LJ7jxrtD3siJbLVA5QnVBHx2NHF/Y937gfcALELYsZQ4OxoLTI9HNGk6K7pCiKaORleJhB9CrfSSFOWPGqrXYkhVHQe+p/xp" type='video/mp4'>
                 -->


<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java">OverRideHashCode a = <span class="hljs-keyword">new</span> OverRideHashCode(<span class="hljs-number">1</span>);<br>OverRideHashCode b = <span class="hljs-keyword">new</span> OverRideHashCode(<span class="hljs-number">1</span>);<br>System.out.println(a == b); <span class="hljs-comment">//false</span><br>System.out.println(a.hashCode()); <span class="hljs-comment">//118 虽然哈希码相同但是内存地址不同</span><br>System.out.println(b.hashCode()); <span class="hljs-comment">//118</span><br></code></pre></td></tr></table></figure>

<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p><strong>hashCode()只是特征表示码,表示两个对象有同样的特征值,主要用来配合哈希表使用</strong></p>
<p>调用hashCode方法默认返回的值被称为<strong>identity hash code（标识哈希码）</strong>，接下来我们会用标识哈希码来区分重写hashCode方法。如果一个类重写了hashCode方法，那么通过调用<code>System.identityHashCode(Object o)</code>方法获得标识哈希码。</p>
<p>**Q:**hashCode()方法返回的到底是不是对象地址?</p>
<p><strong>A:</strong> 不一定,hashCode()是一个native方法,即非java实现的(c实现),有多种实现策略,在不同的jvm里有不同的实现,可能是内存地址,也有可能是通过当前状态值进行异或（XOR）运算得到的一个 hash 值</p>
<p>可以通过配置jvm启动参数 -XX:hashCode=N  N可以是0/1/2/3/4/5 </p>
<p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125145808108.png!%5Bimage-20211125150343680%5D(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125150343680.png" srcset="/img/loading.gif" lazyload alt="image-20211125145808108">Object里的hashCode默认为内存地址转为十进制</p>
<p><strong>注意 用了lombok注解@EqualsAndHashCode(@Data里面也包含)时,重写了hashCode()和equals(),导致内部值相同时,两个对象hashcode也相同,equals也成立</strong></p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>如果没有重写的话,比如在Object中,equals等效与==</p>
<p>如果重写了,比如在String中,equals表示一种逻辑上的相等,比较的是字符是否相同,与==不等效</p>
<hr>
<p>hashCode和equals两个方法是有语义关联的，它们需要满足：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>equals(B)==<span class="hljs-literal">true</span> ---&gt;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>hash<span class="hljs-constructor">Code()</span>==<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>hash<span class="hljs-constructor">Code()</span><br></code></pre></td></tr></table></figure>


<p>注意,如果重写了equals,必须要重写hashCode,保证equals认定为两个相同的对象,具有相同哈希值,保证逻辑上的一致性</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类创建实例时,通过构造方法初始化,构造方法名字和类名一样,可以任意传参,内部语句也可以任意编写,但是没有返回值(没有void)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FormBiz</span><span class="hljs-params">(RemoteActivitiService remoteActivitiService, RemoteTaskService remoteTaskService, IWbAppService appService, IWbAppManagerService wbAppManagerService, IWbOrgDeptService deptService, IWbDynamicFormService dynamicFormService, IWbDynamicFormDirectoryService dynamicFormDirectoryService, DynamicDataSource dynamicDataSource, FormPermissionProvider formPermissionProvider, FormManager formManager, UserProvider userProvider)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.remoteActivitiService = remoteActivitiService;<br>    <span class="hljs-keyword">this</span>.remoteTaskService = remoteTaskService;<br>    <span class="hljs-keyword">this</span>.appService = appService;<br>    <span class="hljs-keyword">this</span>.wbAppManagerService = wbAppManagerService;<br>    <span class="hljs-keyword">this</span>.deptService = deptService;<br>    <span class="hljs-keyword">this</span>.dynamicFormService = dynamicFormService;<br>    <span class="hljs-keyword">this</span>.dynamicFormDirectoryService = dynamicFormDirectoryService;<br>    <span class="hljs-keyword">this</span>.dynamicDataSource = dynamicDataSource;<br>    <span class="hljs-keyword">this</span>.formPermissionProvider = formPermissionProvider;<br>    <span class="hljs-keyword">this</span>.formManager = formManager;<br>    <span class="hljs-keyword">this</span>.userProvider = userProvider;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>如果一个类没有定义构造方法,那么会生成一个默认无参的构造方法,如果自定义构造方法,就会覆盖无参的方法</p>
<p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>; 也可以对字段进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>赋值时,先执行初始化赋值,再执行构造方法赋值</p>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<p>举个例子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p>
<ul>
<li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li>
<li><code>int indexOf(String str)</code>：根据字符串查找；</li>
<li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li>
<li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。]</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>定义Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义Student继承于Person</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 不要重复name和age字段/方法,</span><br>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span><br>    <span class="hljs-keyword">private</span> int score;<br><br>    public int getScore() &#123; … &#125;<br>    public void setScore(int score) &#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</strong></p>
<p>lombok  @AllArgsConstructor 无法获取全部父类构造器</p>
<h3 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h3><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────┐<br>│  Object   │<br>└───────────┘<br>      ▲<br>      │<br>┌───────────┐<br>│  Person   │<br>└───────────┘<br>      ▲<br>      │<br>┌───────────┐<br>│  Student  │<br>└───────────┘<br></code></pre></td></tr></table></figure>

<p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───────────┐<br>       │  Object   │<br>       └───────────┘<br>             ▲<br>             │<br>       ┌───────────┐<br>       │  Person   │<br>       └───────────┘<br>          ▲     ▲<br>          │     │<br>          │     │<br>┌───────────┐ ┌───────────┐<br>│  Student  │ │  Teacher  │<br>└───────────┘ └───────────┘<br></code></pre></td></tr></table></figure>

<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;<br>    <span class="hljs-keyword">private</span> int age;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    public <span class="hljs-type">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 编译错误：无法访问name字段</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> name;<br>    <span class="hljs-keyword">protected</span> int age;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    public <span class="hljs-type">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// OK!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    public <span class="hljs-type">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-keyword">super</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// super</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> Run</p>
<p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p>
<p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> int score;<br><br>    public <span class="hljs-type">Student</span>(<span class="hljs-type">String</span> name, int age, int score) &#123;<br>        <span class="hljs-keyword">super</span>(); <span class="hljs-comment">// 自动调用父类的构造方法</span><br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> int score;<br><br>    public <span class="hljs-type">Student</span>(<span class="hljs-type">String</span> name, int age, int score) &#123;<br>        <span class="hljs-keyword">super</span>(name, age); <span class="hljs-comment">// 调用父类的构造方法Person(String, int)</span><br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样就可以正常编译了！</p>
<p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
<p>这里还顺带引出了另一个问题：即子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p>
<h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p>
<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>
<p>例如，定义一个<code>Shape</code>类：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> sealed <span class="hljs-keyword">class</span> <span class="hljs-symbol">Shape</span> <span class="hljs-symbol">permits</span> <span class="hljs-symbol">Rect, <span class="hljs-symbol">Circle</span>, <span class="hljs-symbol">Triangle</span></span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。但是，如果定义一个<code>Ellipse</code>就会报错：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ellipse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125;<br><span class="hljs-comment">// Compile error: class is not allowed to extend sealed class: Shape</span><br></code></pre></td></tr></table></figure>

<p>原因是<code>Ellipse</code>并未出现在<code>Shape</code>的<code>permits</code>列表中。这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</p>
<p><code>sealed</code>类在Java 15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>如果一个引用变量的类型是<code>Student</code>，那么它可以指向一个<code>Student</code>类型的实例：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Student s</span> = new Student();<br></code></pre></td></tr></table></figure>

<p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Person p</span> = new Person();<br></code></pre></td></tr></table></figure>

<p>现在问题来了：如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能否指向<code>Student</code>类型的实例？</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(); <span class="hljs-comment">// ???</span><br></code></pre></td></tr></table></figure>

<p>测试一下就可以发现，这种指向是允许的！</p>
<p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p>
<p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p>
<p><strong>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">Student s = new Student();<br>Person p = s; <span class="hljs-regexp">//</span> upcasting, ok<br>Object o1 = p; <span class="hljs-regexp">//</span> upcasting, ok<br>Object o2 = s; <span class="hljs-regexp">//</span> upcasting, ok<br></code></pre></td></tr></table></figure>

<p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(); <span class="hljs-comment">// upcasting, ok</span><br>Person p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>Student s1 = (Student) p1; <span class="hljs-comment">// ok</span><br>Student s2 = (Student) p2; <span class="hljs-comment">// runtime error! ClassCastException!</span><br></code></pre></td></tr></table></figure>

<p>如果测试上面的代码，可以发现：</p>
<p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，<code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。在向下转型的时候，把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p>
<p>为了避免向下转型出错，Java提供了**<code>instanceof</code>**操作符，可以先判断一个实例究竟是不是某种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person();<br>System.out.println(p <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br>System.out.println(p <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span><br><br>Student s = <span class="hljs-keyword">new</span> Student();<br>System.out.println(s <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br>System.out.println(s <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// true</span><br><br>Student n = <span class="hljs-keyword">null</span>;<br>System.out.println(n <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p>
<p>利用<code>instanceof</code>，在向下转型前可以先判断：z</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Person p = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Student) &#123;<br>    <span class="hljs-comment">// 只有判断成功才会向下转型:</span><br>    Student s = (Student) p; <span class="hljs-comment">// 一定会成功</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">Object</span> obj = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">String</span>) &#123;<br>    <span class="hljs-keyword">String</span> s = (<span class="hljs-keyword">String</span>) obj;<br>    System.out.<span class="hljs-built_in">println</span>(s.toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// instanceof variable:</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object obj = <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;<br>            <span class="hljs-comment">// 可以直接使用变量s:</span><br>            System.out.println(s.toUpperCase());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p> Run</p>
<p>这种使用<code>instanceof</code>的写法更加简洁。</p>
<h3 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h3><p>在使用继承时，我们要注意逻辑一致性。</p>
<p>考察下面的<code>Book</code>类：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">class <span class="hljs-type">Book</span> &#123;<br>    protected <span class="hljs-type">String</span> name;<br>    public <span class="hljs-type">String</span> getName() <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-built_in">void</span> setName(<span class="hljs-type">String</span> name) <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个<code>Book</code>类也有<code>name</code>字段，那么，我们能不能让<code>Student</code>继承自<code>Book</code>呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> int score;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，从逻辑上讲，这是不合理的，<code>Student</code>不应该从<code>Book</code>继承，而应该从<code>Person</code>继承。</p>
<p>究其原因，是因为<code>Student</code>是<code>Person</code>的一种，它们是is关系，而<code>Student</code>并不是<code>Book</code>。实际上<code>Student</code>和<code>Book</code>的关系是has关系。</p>
<p>具有has关系不应该使用继承，而是使用组合，即<code>Student</code>可以持有一个<code>Book</code>实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Book</span> book;<br>    <span class="hljs-keyword">protected</span> int score;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，继承是is关系，组合是has关系。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Person p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>();<br>p.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 无法确定运行时究竟调用哪个run()方法</span><br></code></pre></td></tr></table></figure>

<p>有童鞋会问，从上面的代码一看就明白，肯定调用的是<code>Student</code>的<code>run()</code>方法啊。</p>
<p>但是，假设我们编写这样一个方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTwice</span><span class="hljs-params">(Person p)</span> </span>&#123;<br>    p.<span class="hljs-built_in">run</span>();<br>    p.<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p>
<p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p>
<p>我们还是来举栗子。</p>
<p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Income</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> income;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> income * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 税率10%</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public double getTax() &#123;<br>        <span class="hljs-keyword">if</span> (income &lt;= <span class="hljs-number">5000</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateCouncilSpecialAllowance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public double getTax() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">totalTax</span><span class="hljs-params">(Income... incomes)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Income income: incomes) &#123;<br>        total = total + income.<span class="hljs-built_in">getTax</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样,只有到实际执行的时候,才知道执行的是哪个方法,类似低代码平台的Control</p>
<p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>
<h3 id="覆写Object方法"><a href="#覆写Object方法" class="headerlink" title="覆写Object方法"></a>覆写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。</li>
</ul>
<p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 显示更有意义的字符串:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:name=&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">// 比较是否相等:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;<br>        <span class="hljs-comment">// 当且仅当o为Person类型:</span><br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            Person p = (Person) o;<br>            <span class="hljs-comment">// 并且name字段相同时，返回true:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算hash:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br>Student <span class="hljs-keyword">extends</span> Person &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的hello()方法:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.hello() + <span class="hljs-string">&quot;!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> final <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br>Student <span class="hljs-keyword">extends</span> Person &#123;<br>    <span class="hljs-comment">// compile error: 不允许覆写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">String</span> name;<br>&#125;<br><br><span class="hljs-comment">// compile error: 不允许继承自Person</span><br>Student <span class="hljs-keyword">extends</span> Person &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name = <span class="hljs-string">&quot;Unamed&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对<code>final</code>字段重新赋值会报错：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>p.name = <span class="hljs-string">&quot;New Name&quot;</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure>

<p><strong>可以在构造方法中初始化final字段：</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p>
<ul>
<li><code>final</code>修饰符有多种作用：<ul>
<li><code>final</code>修饰的方法可以阻止被覆写；</li>
<li><code>final</code>修饰的class可以阻止被继承；</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从<code>Person</code>类派生的<code>Student</code>和<code>Teacher</code>都可以覆写<code>run()</code>方法。</p>
<p>如果父类<code>Person</code>的<code>run()</code>方法没有实际意义，能否去掉方法的执行语句？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// Compile Error!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。</p>
<p>能不能去掉父类的<code>run()</code>方法？</p>
<p>答案还是不行，因为去掉父类的<code>run()</code>方法，就失去了多态的特性。例如，<code>runTwice()</code>就无法编译：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTwice</span><span class="hljs-params">(Person p)</span> </span>&#123;<br>    p.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// Person没有run()方法，会导致编译错误</span><br>    p.<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p>
<p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p>
<p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p>
<p>**使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类： 但可以实例化被继承的子类 **</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(); <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure>

<p>无法实例化的抽象类有什么用？</p>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>
<p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p>
<h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Person s</span> = new Student();<br><span class="hljs-attribute">Person t</span> = new Teacher();<br></code></pre></td></tr></table></figure>

<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 不关心Person变量的具体子类型:</span><br>s.<span class="hljs-built_in">run</span>();<br>t.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure>

<p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 同样不关心新的子类是如何实现run()方法的：</span><br>Person e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>();<br>e.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure>

<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>就可以把该抽象类改写为接口：<code>interface</code>。</p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Person, <span class="hljs-symbol">Hello</span></span> &#123; <span class="hljs-comment">// 实现了两个interface</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>注意区分术语：</p>
<p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">abstract class</th>
<th align="left">interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承</td>
<td align="left">只能extends一个class</td>
<td align="left">可以implements多个interface</td>
</tr>
<tr>
<td align="left">字段</td>
<td align="left">可以定义实例字段</td>
<td align="left">不能定义实例字段</td>
</tr>
<tr>
<td align="left">抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td align="left">可以定义抽象方法</td>
</tr>
<tr>
<td align="left">非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td align="left">可以定义default方法</td>
</tr>
</tbody></table>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><strong>抽象类可以不实现接口,留给子类去实现</strong></p>
<p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，<strong>公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。</strong>可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────────┐<br>│   Iterable    │<br>└───────────────┘<br>        ▲                ┌───────────────────┐<br>        │                │      Object       │<br>┌───────────────┐        └───────────────────┘<br>│  Collection   │                  ▲<br>└───────────────┘                  │<br>        ▲     ▲          ┌───────────────────┐<br>        │     └──────────│AbstractCollection │<br>┌───────────────┐        └───────────────────┘<br>│     List      │                  ▲<br>└───────────────┘                  │<br>              ▲          ┌───────────────────┐<br>              └──────────│   AbstractList    │<br>                         └───────────────────┘<br>                                ▲     ▲<br>                                │     │<br>                                │     │<br>                     ┌────────────┐ ┌────────────┐<br>                     │ ArrayList  │ │ LinkedList │<br>                     └────────────┘ └────────────┘<br></code></pre></td></tr></table></figure>

<p>在使用的时候，<strong>实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象</strong>：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">List list = new ArrayList(); <span class="hljs-regexp">//</span> 用List接口引用具体子类的实例<br>Collection coll = list; <span class="hljs-regexp">//</span> 向上转型为Collection接口<br>Iterable it = coll; <span class="hljs-regexp">//</span> 向上转型为Iterable接口<br></code></pre></td></tr></table></figure>

<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> interface<br></code></pre></td></tr></table></figure>

<p> Run</p>
<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段(<strong>注:接口中不能有实例字段,但可以有静态字段,默认是public static final的,修饰符可写可不写</strong>)，**<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段**。</p>
<h1 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h1><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p>
<p>还有一种字段，是用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>
<p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">// 定义静态字段number:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ascii">        ┌──────────────────┐<br>ming ──&gt;│Person instance   │<br>        ├──────────────────┤<br>        │name = &quot;Xiao Ming&quot;│<br>        │age = 12          │<br>        │number ───────────┼──┐    ┌─────────────┐<br>        └──────────────────┘  │    │Person class │<br>                              │    ├─────────────┤<br>                              ├───&gt;│number = 99  │<br>        ┌──────────────────┐  │    └─────────────┘<br>hong ──&gt;│Person instance   │  │<br>        ├──────────────────┤  │<br>        │name = &quot;Xiao Hong&quot;│  │<br>        │age = 15          │  │<br>        │number ───────────┼──┘<br>        └──────────────────┘<br></code></pre></td></tr></table></figure>

<p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，所有实例共享一个静态字段。</p>
<p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p>
<p>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>number = <span class="hljs-number">99</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>number);<br></code></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>有静态字段，就有静态方法。用<code>static</code>修饰的方法称为静态方法。</p>
<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> static method<br></code></pre></td></tr></table></figure>

<p> Run</p>
<p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p>
<p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p>
<p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p>
<p>静态方法经常用于工具类。例如：</p>
<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
<p>静态方法也经常用于辅助方法。注意到Java程序的入口<code>main()</code>也是静态方法。</p>
<h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MALE = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FEMALE = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Person</span> &#123;<br>    <span class="hljs-comment">// 编译器会自动加上public statc final:</span><br>    <span class="hljs-built_in">int</span> MALE = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> FEMALE = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会自动把该字段变为<code>public static final</code>类型。</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code></p>
<p><strong>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系.</strong></p>
<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">package_sample<br>└─ src<br>    ├─ hong<br>    │  └─ Person.java<br>    │  ming<br>    │  └─ Person.java<br>    └─ mr<br>       └─ jun<br>          └─ Arrays.java<br></code></pre></td></tr></table></figure>

<p>即所有Java文件对应的目录层次要和包的层次一致。</p>
<p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">package_sample<br>└─ bin<br>   ├─ hong<br>   │  └─ Person.class<br>   │  ming<br>   │  └─ Person.class<br>   └─ mr<br>      └─ jun<br>         └─ Arrays.class<br></code></pre></td></tr></table></figure>

<p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">javac -d ../bin ming/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>java hong/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>java mr/jun/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>java<br></code></pre></td></tr></table></figure>

<p>在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。</p>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 包作用域:</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Main</code>类也定义在<code>hello</code>包下面：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> hello;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>        p.hello(); <span class="hljs-comment">// 可以调用，因为Main和Person在同一个包</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        mr.jun.Arrays arrays = <span class="hljs-keyword">new</span> mr.jun.Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很显然，每次写完整类名比较痛苦。</p>
<p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入完整类名:</span><br><span class="hljs-keyword">import</span> mr.jun.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Arrays arrays = <span class="hljs-keyword">new</span> Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入mr.jun包的所有class:</span><br><span class="hljs-keyword">import</span> mr.jun.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Arrays arrays = <span class="hljs-keyword">new</span> Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>
<p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package main;<br><br><span class="hljs-comment">// 导入System类的所有静态字段和静态方法:</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 相当于调用System.out.println(…)</span><br>        out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>import static</code>很少使用。</p>
<p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<p><strong>编写class的时候，编译器会自动帮我们做两个import动作</strong>：</p>
<ul>
<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>
<li>默认自动<code>import java.lang.*</code>.</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和JDK常用类重名：</p>
<ul>
<li>java.util.List</li>
<li>java.text.Format</li>
<li>java.math.BigInteger</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在Java中，我们经常看到<code>public</code>、<code>protected</code>、<code>private</code>这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Main可以访问Hello</span><br>        Hello h = <span class="hljs-keyword">new</span> Hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的<code>hi()</code>方法是<code>public</code>，可以被其他类调用，前提是首先要能访问<code>Hello</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        Hello h = <span class="hljs-keyword">new</span> Hello();<br>        h.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// 不能被其他类调用:</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hi();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// private</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Inner i = <span class="hljs-keyword">new</span> Inner();<br>        i.hi();<br>    &#125;<br><br>    <span class="hljs-comment">// private方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;private hello!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 静态内部类:</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">hi</span>(<span class="hljs-params"></span>)</span> &#123;<br>            Main.hello();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> Run</p>
<p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p>
<h3 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// protected方法:</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的<code>protected</code>方法可以被继承的类访问：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    void foo() &#123;<br>        <span class="hljs-comment">// 可以访问protected方法:</span><br>        hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><span class="hljs-comment">// package权限的类:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// package权限的方法:</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</p>
<p><strong>注:一个.java文件中最多只能有一个public类,且类名与文件名相同,也可以没有public类,这样类名可以和.java文件名不同</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 可以访问package权限的类:</span><br>        Hello h = <span class="hljs-keyword">new</span> Hello();<br>        <span class="hljs-comment">// 可以调用package权限的方法:</span><br>        h.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123; <span class="hljs-comment">// ①</span><br>        <span class="hljs-keyword">String</span> s = name.<span class="hljs-built_in">toLowerCase</span>(); <span class="hljs-comment">// ②</span><br>        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// ③</span><br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// ④</span><br>            <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span> - len; <span class="hljs-comment">// ⑤</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">// ⑥</span><br>                System.out.<span class="hljs-built_in">println</span>(); <span class="hljs-comment">// ⑦</span><br>            &#125; <span class="hljs-comment">// ⑧</span><br>        &#125; <span class="hljs-comment">// ⑨</span><br>    &#125; <span class="hljs-comment">// ⑩</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们观察上面的<code>hi()</code>方法代码：</p>
<ul>
<li>方法参数name是局部变量，它的作用域是整个方法，即①～⑩；</li>
<li>变量s的作用域是定义处到方法结束，即②～⑩；</li>
<li>变量len的作用域是定义处到方法结束，即③～⑩；</li>
<li>变量p的作用域是定义处到if块结束，即⑤～⑨；</li>
<li>变量i的作用域是for循环，即⑥～⑧。</li>
</ul>
<p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p>
<h3 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h3><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p>
<p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-comment">// 无法被继承:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> i = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// 无法被覆写:</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        t = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p>
<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</p>
<p>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p>
<p><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</p>
<p>以上针对类和方法,针对成员变量则有下图</p>
<p><img src="https://images2015.cnblogs.com/blog/690292/201609/690292-20160923095944481-1758567758.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h3 id="内部类-Inner-Class"><a href="#内部类-Inner-Class" class="headerlink" title="内部类(Inner Class)"></a>内部类(Inner Class)</h3><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>        // 定义了一个<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">Class</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Main &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>(&quot;Nested&quot;); // 实例化一个<span class="hljs-keyword">Outer</span><br>        <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); // 实例化一个<span class="hljs-keyword">Inner</span><br>        <span class="hljs-keyword">inner</span>.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span> &#123;<br>    private String <span class="hljs-type">name</span>;<br><br>    <span class="hljs-keyword">Outer</span>(String <span class="hljs-type">name</span>) &#123;<br>        this.name = <span class="hljs-type">name</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>        <span class="hljs-type">void</span> hello() &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Hello, &quot; + <span class="hljs-keyword">Outer</span>.this.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察上述代码，要实例化一个<code>Inner</code>，我们必须首先创建一个<code>Outer</code>的实例，然后，调用<code>Outer</code>实例的<code>new</code>来创建<code>Inner</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer.Inner inner = outer.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>这是因为Inner Class除了有一个<code>this</code>指向它自己，还隐含地持有一个Outer Class实例，可以用<code>Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p>
<p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的<code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p>
<p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。x</p>
<h3 id="匿名类-Anonymous-Class"><a href="#匿名类-Anonymous-Class" class="headerlink" title="匿名类(Anonymous Class)"></a>匿名类(Anonymous Class)</h3><p><strong>接口不能实例化,所以实例化一个内部匿名接口时,必须实现它的所有方法</strong></p>
<p><strong>内部匿名类也可以是非接口,比如</strong></p>
<p><code>     HashMap&lt;String, String&gt; map2 = new HashMap&lt;&gt;() &#123;&#125;; // 匿名类!</code>     </p>
<p>后面的方括号表示static代码块,可以做一些初始化操作</p>
<p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Anonymous Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Outer outer = <span class="hljs-keyword">new</span> Outer(<span class="hljs-string">&quot;Nested&quot;</span>);<br>        outer.asyncHello();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">asyncHello</span><span class="hljs-params">()</span> </span>&#123;<br>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-keyword">this</span>.name);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Runnable r = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 实现必要的抽象方法...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p>
<p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p>
<p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// Anonymous Class</span><br><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">HashMap</span>;<br><br><span class="hljs-keyword">public</span> class Main &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="hljs-comment">// 匿名类!</span><br>        <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;() &#123;<br>            &#123;<br>                put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>                put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>            &#125;<br>        &#125;;<br>        System.out.<span class="hljs-built_in">println</span>(map3.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;A&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，<strong>并且添加了<code>static</code>代码块来初始化数据</strong>*<strong>注:中括号内即为static代码块</strong>。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p>
<h3 id="静态内部类-Static-Nested-Class"><a href="#静态内部类-Static-Nested-Class" class="headerlink" title="静态内部类(Static Nested Class)"></a>静态内部类(Static Nested Class)</h3><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Static Nested Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Outer.StaticNested sn = <span class="hljs-keyword">new</span> Outer.StaticNested();<br>        sn.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String NAME = <span class="hljs-string">&quot;OUTER&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNested</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.NAME);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种：</p>
<ul>
<li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer Class的<code>private</code>访问权限；</li>
<li>Static Nested Class是独立类，但拥有Outer Class的<code>private</code>访问权限。</li>
</ul>
<h1 id="classpath-类路径-和jar"><a href="#classpath-类路径-和jar" class="headerlink" title="classpath(类路径)和jar"></a>classpath(类路径)和jar</h1><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>在Java中，我们经常听到<code>classpath</code>这个东西。网上有很多关于“如何设置classpath”的文章，但大部分设置都不靠谱。</p>
<p>到底什么是<code>classpath</code>？</p>
<p>**<code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>**。</p>
<p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p>
<p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\w</span>ork<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in;C:<span class="hljs-symbol">\s</span>hared;&quot;D:<span class="hljs-symbol">\M</span>y Documents<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in&quot;<br></code></pre></td></tr></table></figure>

<p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>shared:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/</span>home<span class="hljs-regexp">/liaoxuefeng/</span>bin<br></code></pre></td></tr></table></figure>

<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li>&lt;当前目录&gt;\abc\xyz\Hello.class</li>
<li>C:\work\project1\bin\abc\xyz\Hello.class</li>
<li>C:\shared\abc\xyz\Hello.class</li>
</ul>
<p><strong>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</strong></p>
<p><code>classpath</code>的设定方法有两种：</p>
<p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p>
<p>在启动JVM时设置<code>classpath</code>变量，推荐。</p>
<p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在<strong>启动JVM</strong>时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -classpath .;C:<span class="hljs-symbol">\w</span>ork<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in;C:<span class="hljs-symbol">\s</span>hared abc.xyz.Hello<br></code></pre></td></tr></table></figure>

<p>或者使用<code>-cp</code>的简写：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -cp .;C:<span class="hljs-symbol">\w</span>ork<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in;C:<span class="hljs-symbol">\s</span>hared abc.xyz.Hello<br></code></pre></td></tr></table></figure>

<p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>abc.xyz.Hello<br></code></pre></td></tr></table></figure>

<p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p>
<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p>
<p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p>
<p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p>
<p> 不要把任何Java核心库添加到<code>classpath</code>中！JVM根本不依赖<code>classpath</code>加载核心库！</p>
<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>
<p>假设我们有一个编译后的<code>Hello.class</code>，它的包名是<code>com.example</code>，当前目录是<code>C:\work</code>，那么，目录结构必须如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">C:\work<br>└─ com<br>   └─ example<br>      └─ Hello.class<br></code></pre></td></tr></table></figure>

<p>运行这个<code>Hello.class</code>必须在当前目录下使用如下命令：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">C:</span>\work&gt; java -<span class="hljs-keyword">cp</span> . <span class="hljs-keyword">com</span>.example.Hello<br></code></pre></td></tr></table></figure>

<p>JVM根据classpath设置的<code>.</code>在当前目录下查找<code>com.example.Hello</code>，即实际搜索文件必须位于<code>com/example/Hello.class</code>。如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>
<p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>
<p>jar包实际上就是一个<code>zip</code>格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p>
<p><strong>注:jar包也可以当<code>classpath</code>用</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -cp ./hello<span class="hljs-selector-class">.jar</span> abc<span class="hljs-selector-class">.xyz</span>.Hello<br></code></pre></td></tr></table></figure>

<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>
<p>那么问题来了：如何创建jar包？</p>
<p><strong>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</strong></p>
<p>假设编译输出的目录结构是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">package_sample<br>└─ bin<br>   ├─ hong<br>   │  └─ Person.class<br>   │  ming<br>   │  └─ Person.class<br>   └─ mr<br>      └─ jun<br>         └─ Arrays.class<br></code></pre></td></tr></table></figure>

<p><strong>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</strong></p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l" srcset="/img/loading.gif" lazyload alt="hello.zip.ok"></p>
<p>如果长这样：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l" srcset="/img/loading.gif" lazyload alt="hello.zip.invalid"></p>
<p>说明打包打得有问题，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p>
<p>????</p>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<p><strong>即会自动去找main-class,可以直接用java -jar xxx.jar启动jar包</strong></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>hello.<span class="hljs-keyword">jar</span><br></code></pre></td></tr></table></figure>

<p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p>
<p><strong>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>，可以非常方便地创建jar包。</strong></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p>
<p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p>
<p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p>
<p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p>
<h1 id="模块-Java9"><a href="#模块-Java9" class="headerlink" title="模块(Java9)"></a>模块(Java9)</h1><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>从Java 9开始，JDK又引入了模块（Module）。</p>
<p>什么是模块？这要从Java 9之前的版本说起。</p>
<p>我们知道，<code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p>
<p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p>
<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main<br></code></pre></td></tr></table></figure>

<p> <strong>注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</strong></p>
<p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code>。</p>
<p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p>
<p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p>
<p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>
<p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p>
<h3 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h3><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ascii">oop-module<br>├── bin<br>├── build.sh<br>└── src<br>    ├── com<br>    │   └── itranswarp<br>    │       └── sample<br>    │           ├── Greeting.java<br>    │           └── Main.java<br>    └── module-info.java<br></code></pre></td></tr></table></figure>

<p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">module</span> hello.world &#123;<br>	<span class="hljs-keyword">requires</span> java.base; <span class="hljs-comment">// 可不写，任何模块都会自动引入java.base</span><br>	<span class="hljs-keyword">requires</span> java.xml;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>
<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itranswarp.sample;<br><br><span class="hljs-comment">// 必须引入java.xml模块后才能使用其中的类:</span><br><span class="hljs-keyword">import</span> javax.xml.XMLConstants;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Greeting g = <span class="hljs-keyword">new</span> Greeting();<br>		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p>
<p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p>
<p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java<br></code></pre></td></tr></table></figure>

<p>如果编译成功，现在项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">oop-module<br>├── bin<br>│   ├── com<br>│   │   └── itranswarp<br>│   │       └── sample<br>│   │           ├── Greeting.class<br>│   │           └── Main.class<br>│   └── module-info.class<br>└── src<br>    ├── com<br>    │   └── itranswarp<br>    │       └── sample<br>    │           ├── Greeting.java<br>    │           └── Main.java<br>    └── module-info.java<br></code></pre></td></tr></table></figure>

<p>注意到<code>src</code>目录下的<code>module-info.java</code>被编译到<code>bin</code>目录下的<code>module-info.class</code>。</p>
<p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .<br></code></pre></td></tr></table></figure>

<p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jmod create --class-path hello.jar hello.jmod<br></code></pre></td></tr></table></figure>

<p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p>
<h3 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java --module-path hello.jmod --module hello.world<br></code></pre></td></tr></table></figure>

<p>结果是一个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error occurred during initialization of boot layer<br>java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod<br></code></pre></td></tr></table></figure>

<p>原因是<code>.jmod</code>不能被放入<code>--module-path</code>中。换成<code>.jar</code>就没问题了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java --module-path hello.jar --module hello.world<br>Hello, xml!<br></code></pre></td></tr></table></figure>

<p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p>
<h3 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h3><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p>
<p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p>
<p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/<br></code></pre></td></tr></table></figure>

<p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p>
<p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jre/bin/java --module hello.world<br>Hello, xml!<br></code></pre></td></tr></table></figure>

<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p>
<p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p>
<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">module java.<span class="hljs-built_in">xml</span> &#123;<br>    exports java.<span class="hljs-built_in">xml</span>;<br>    exports javax.<span class="hljs-built_in">xml</span>.catalog;<br>    exports javax.<span class="hljs-built_in">xml</span>.datatype;<br>    <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;<br>    <span class="hljs-keyword">exports</span> com.itranswarp.sample;<br><br>    <span class="hljs-keyword">requires</span> java.base;<br>	<span class="hljs-keyword">requires</span> java.xml;<br>&#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Core/">Core</a>
                    
                      <a class="hover-with-bg" href="/categories/Core/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Core/Java/1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">1.面向对象</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/08/Core/Java/5.%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">泛型基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/08/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/@Configuration/">
                        <span class="hidden-mobile">@Configuration</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
