<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/06/hello-world/"/>
    <url>/2022/01/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Network/README/"/>
    <url>/2022/01/06/Core/Network/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据中台业务整合</title>
    <link href="/2022/01/06/Projects/LowCode/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%B8%9A%E5%8A%A1%E6%95%B4%E5%90%88/"/>
    <url>/2022/01/06/Projects/LowCode/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%B8%9A%E5%8A%A1%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
      <category>LowCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Projects/Yango/README/"/>
    <url>/2022/01/06/Projects/Yango/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
      <category>Yango</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/Docker/README/"/>
    <url>/2022/01/06/Tools/Docker/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/Git/README/"/>
    <url>/2022/01/06/Tools/Git/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/IDEA/README/"/>
    <url>/2022/01/06/Tools/IDEA/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/Jenkins/README/"/>
    <url>/2022/01/06/Tools/Jenkins/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes基础</title>
    <link href="/2022/01/06/Tools/Kubernetes/Kubernetes%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/06/Tools/Kubernetes/Kubernetes%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/Linux/README/"/>
    <url>/2022/01/06/Tools/Linux/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/Maven/README/"/>
    <url>/2022/01/06/Tools/Maven/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Tools/Ningx/README/"/>
    <url>/2022/01/06/Tools/Ningx/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Ningx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/7.IO/README/"/>
    <url>/2022/01/06/Core/Java/7.IO/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>7.IO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/8.%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/README/"/>
    <url>/2022/01/06/Core/Java/8.%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>8.日期与时间</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/9.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/README/"/>
    <url>/2022/01/06/Core/Java/9.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>9.单元测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/2022/01/06/Database/RDBMS/MongoDB/MongoDB/"/>
    <url>/2022/01/06/Database/RDBMS/MongoDB/MongoDB/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p><img src="MongoDB/image-20211228101540826.png" alt="image-20211228101540826"></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>RDBMS</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Database/RDBMS/Redis/README/"/>
    <url>/2022/01/06/Database/RDBMS/Redis/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>RDBMS</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Database/SQL/MySQL/README/"/>
    <url>/2022/01/06/Database/SQL/MySQL/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>SQL</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Untitled</title>
    <link href="/2022/01/06/Core/Java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Untitled/"/>
    <url>/2022/01/06/Core/Java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Untitled/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>15.网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Untitled</title>
    <link href="/2022/01/06/Core/Java/16.%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3/Untitled/"/>
    <url>/2022/01/06/Core/Java/16.%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3/Untitled/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>16.常见接口</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>元注解</title>
    <link href="/2022/01/06/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E5%85%83%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/01/06/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E5%85%83%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>4.注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2</title>
    <link href="/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/2.Set%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/2.Set%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>6.集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3</title>
    <link href="/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/3.Map%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/3.Map%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>6.集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/README/"/>
    <url>/2022/01/06/Core/Java/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>10.正则表达式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/11.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/README/"/>
    <url>/2022/01/06/Core/Java/11.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>11.加密与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch使用</title>
    <link href="/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/CountDownLatch%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/CountDownLatch%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>CountDownLatch概念</strong></p><p>CountDownLatch是一个同步工具类，用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。</p><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p><p><strong>CountDownLatch的用法</strong></p><p>CountDownLatch典型用法：1、某一线程在开始运行前等待n个线程执行完毕。将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p><p>CountDownLatch典型用法：2、实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的CountDownLatch(1)，将其计算器初始化为1，多个线程在开始执行任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。</p><p><strong>CountDownLatch的不足</strong></p><p>CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p><p><strong>CountDownLatch（倒计时计算器）使用说明</strong></p><p>方法说明</p><p>public void countDown()</p><p>　　递减锁存器的计数，如果计数到达零，则释放所有等待的线程。如果当前计数大于零，则将计数减少.</p><p>public boolean await(long timeout,TimeUnit unit) throws InterruptedException</p><p>　　使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。如果当前计数为零，则此方法立刻返回true值。</p><p>　　如果当前计数大于零，则出于线程调度目的，将禁用当前线程，且在发生以下三种情况之一前，该线程将一直出于休眠状态：</p><p>　　由于调用countDown()方法，计数到达零；或者其他某个线程中断当前线程；或者已超出指定的等待时间。</p><ul><li>如果计数到达零，则该方法返回true值。</li><li>如果当前线程，在进入此方法时已经设置了该线程的中断状态；或者在等待时被中断，则抛出InterruptedException，并且清除当前线程的已中断状态。</li><li>如果超出了指定的等待时间，则返回值为false。如果该时间小于等于零，则该方法根本不会等待。</li></ul><p>参数：</p><p>　　timeout-要等待的最长时间</p><p>　　unit-timeout 参数的时间单位</p><p>返回：</p><p>　　如果计数到达零，则返回true；如果在计数到达零之前超过了等待时间，则返回false</p><p>抛出：</p><p>　　InterruptedException-如果当前线程在等待时被中断</p><p>例子1：</p><p>　　主线程等待子线程执行完成在执行</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">package com.example.demo.CountDownLatchDemo;<br><br>import java.util.concurrent.CountDownLatch;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主线程等待子线程执行完成再执行</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> CountdownLatchTest1 &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ExecutorService service = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(3)</span>;<br>        final CountDownLatch latch = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(3)</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            Runnable runnable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>                @Override<br>                public void run<span class="hljs-literal">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;子线程&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;开始执行&quot;</span>);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep((long) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span><span class="hljs-operator"> * </span><span class="hljs-number">10000</span>));<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;子线程&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;执行完成&quot;</span>);<br>                        latch.count<span class="hljs-constructor">Down()</span>;<span class="hljs-comment">//当前线程调用此方法，则计数减一</span><br>                    &#125; catch (InterruptedException e) &#123;<br>                        e.print<span class="hljs-constructor">StackTrace()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            service.execute(runnable);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;等待子线程执行完成...&quot;</span>);<br>            latch.await<span class="hljs-literal">()</span>;<span class="hljs-comment">//阻塞当前线程，直到计数器的值为0</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;开始执行...&quot;</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子2：</p><p>　　百米赛跑，4名运动员选手到达场地等待裁判口令，裁判一声口令，选手听到后同时起跑，当所有选手到达终点，裁判进行汇总排名</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.example.demo.CountDownLatchDemo;<br><br>import java.util.concurrent.CountDownLatch;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br><br>public <span class="hljs-keyword">class</span> CountdownLatchTest2 &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ExecutorService service = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">CachedThreadPool()</span>;<br>        final CountDownLatch cdOrder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(1)</span>;<br>        final CountDownLatch cdAnswer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(4)</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            Runnable runnable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>                @Override<br>                public void run<span class="hljs-literal">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;选手&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;正在等待裁判发布口令&quot;</span>);<br>                        cdOrder.await<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;选手&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;已接受裁判口令&quot;</span>);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep((long) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span><span class="hljs-operator"> * </span><span class="hljs-number">10000</span>));<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;选手&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;到达终点&quot;</span>);<br>                        cdAnswer.count<span class="hljs-constructor">Down()</span>;<br>                    &#125; catch (InterruptedException e) &#123;<br>                        e.print<span class="hljs-constructor">StackTrace()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            service.execute(runnable);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep((long) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span><span class="hljs-operator"> * </span><span class="hljs-number">10000</span>));<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;裁判&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;即将发布口令&quot;</span>);<br>            cdOrder.count<span class="hljs-constructor">Down()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;裁判&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;已发送口令，正在等待所有选手到达终点&quot;</span>);<br>            cdAnswer.await<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;所有选手都到达终点&quot;</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;裁判&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;汇总成绩排名&quot;</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>        service.shutdown<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>12.多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FutureTask使用</title>
    <link href="/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/FutureTask%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/FutureTask%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>异步回调FutureTask</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>12.多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/README/"/>
    <url>/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>12.多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread</title>
    <link href="/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/Thread.join()%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/06/Core/Java/12.%E5%A4%9A%E7%BA%BF%E7%A8%8B/Thread.join()%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="java-线程方法join的简单总结"><a href="#java-线程方法join的简单总结" class="headerlink" title="java 线程方法join的简单总结"></a>java 线程方法join的简单总结</h1><p>虽然关于讨论线程join方法的博客已经很多了，不过个人感觉挺多都讨论得不够全面，所以我觉得有必要对其进行一个全面的总结。</p><p>　　一、作用</p><p>　　Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。具体看代码：</p><p><a href="www.baidu.com">测试链接使用</a></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadJoinTest t1 = <span class="hljs-keyword">new</span> ThreadJoinTest(<span class="hljs-string">&quot;小明&quot;</span>);<br>        ThreadJoinTest t2 = <span class="hljs-keyword">new</span> ThreadJoinTest(<span class="hljs-string">&quot;小东&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">/**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：</span><br><span class="hljs-comment">         程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕</span><br><span class="hljs-comment">         所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会</span><br><span class="hljs-comment">         */</span><br>        t1.join();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadJoinTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadJoinTest</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>            System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序结果是先打印完小明线程，在打印小东线程；　　</p><p>上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadJoinTest t1 = <span class="hljs-keyword">new</span> ThreadJoinTest(<span class="hljs-string">&quot;小明&quot;</span>);<br>        ThreadJoinTest t2 = <span class="hljs-keyword">new</span> ThreadJoinTest(<span class="hljs-string">&quot;小东&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">/**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，</span><br><span class="hljs-comment">         * main线程和t1线程之间执行顺序由串行执行变为普通的并行执行</span><br><span class="hljs-comment">         */</span><br>        t1.join(<span class="hljs-number">10</span>);<br>        t2.start();<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadJoinTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadJoinTest</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>            System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。</p><p>所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。</p><p>　　</p><p>　　二、join与start调用顺序问题</p><p>　　上面的讨论大概知道了join的作用了，那么，入股 join在start前调用，会出现什么后果呢？先看下面的测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadJoinTest t1 = <span class="hljs-keyword">new</span> ThreadJoinTest(<span class="hljs-string">&quot;小明&quot;</span>);<br>        ThreadJoinTest t2 = <span class="hljs-keyword">new</span> ThreadJoinTest(<span class="hljs-string">&quot;小东&quot;</span>);<br>        <span class="hljs-comment">/**join方法可以在start方法前调用时，并不能起到同步的作用</span><br><span class="hljs-comment">         */</span><br>        t1.join();<br>        t1.start();<br>        <span class="hljs-comment">//Thread.yield();</span><br>        t2.start();<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadJoinTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadJoinTest</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>            System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码执行结果是：小明和小东线程交替打印。</p><p>所以得到以下结论：join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。</p><p>　　三、join方法实现原理</p><p>　　有了上面的例子，我们大概知道join方法的作用了，那么，join方法实现的原理是什么呢？</p><p>　　其实，join方法是通过调用线程的wait方法来达到同步的目的的。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态，具体看下面的源码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function">    throws InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> base = System.<span class="hljs-built_in">currentTimeMillis</span>();<br>        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isAlive</span>()) &#123;<br>                <span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isAlive</span>()) &#123;<br>                <span class="hljs-keyword">long</span> delay = millis - now;<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">wait</span>(delay);<br>                now = System.<span class="hljs-built_in">currentTimeMillis</span>() - base;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>从源码中可以看到：join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>12.多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/13.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/README/"/>
    <url>/2022/01/06/Core/Java/13.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>13.函数式编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Java/14.XML%E4%B8%8EJSON/README/"/>
    <url>/2022/01/06/Core/Java/14.XML%E4%B8%8EJSON/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>14.XML与JSON</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/01/06/Core/Java/3.%E5%8F%8D%E5%B0%84/1.3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%8AInvocationHandler%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/06/Core/Java/3.%E5%8F%8D%E5%B0%84/1.3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%8AInvocationHandler%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>网上关于Java的动态代理，Proxy和InvocationHandler这些概念有讲解得非常高深的文章。其实这些概念没有那么复杂。现在咱们通过一个最简单的例子认识什么是InvocationHandler。值得一提的是，InvocationHandler在Spring框架实现中被广泛使用，这意味着我们吃透了InvocationHandler，就为将来的Spring源码学习打下一个坚实的基础。</p><p><img src="https://pic2.zhimg.com/80/v2-75cf544818c06ed83a90e46723ba196d_720w.jpg" alt="img"></p><p>开发一个接口，包含两个方法，可以向指定的人问候“你好”或者“再见”。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个简单的类，实现这个IHello接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helloimplements</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot; GoodBye!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费这个实现类，迄今为止没什么特别的。</p><p>现在假设我们接到了这个需求：老板要求在该实现类每次问候某人时，必须把问候的细节记录到日志文件里。为了简单起见，我们在问候前打印下面的一行语句来模拟日志记录的动作。</p><p>System.out.println(“问候之前的日志记录…”);</p><p>您也许会说，这还不简单？直接修改Helloimplements的对应方法，把这行日志插入到对应方法即可。</p><p><img src="https://pic1.zhimg.com/80/v2-2fb60bea5ca37e2f08e1cc246c53d434_720w.jpg" alt="img"></p><p>然而，老板的要求是：不允许你修改原来的Helloimplements类。在现实场景中，Helloimplements可能是第三方的jar包提供的，我们没有办法修改代码。</p><p>您也许会说，我们可以用设计模式里的代理模式，即创建一个新的Java类作为代理类，同样实现IHello接口，然后将Helloimplements类的实例传入代理类。我们虽然被要求不允许修改Helloimplements的代码，但是可以把日志记录代码写在代理类里。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHello</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> IHello iHello;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImpl</span><span class="hljs-params">(IHello impl)</span></span>&#123;<br><br>  <span class="hljs-keyword">this</span>.iHello = impl;<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>    iHello.sayHello(name);<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayGoogBye</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>     System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br><br>     iHello.sayGoogBye(name);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br><br>     Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br><br>     StaticProxy proxy = <span class="hljs-keyword">new</span> StaticProxy();<br><br>     proxy.setImpl(hello);<br><br>     proxy.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法能够实现需求：</p><p><img src="https://pic3.zhimg.com/80/v2-0cd0504320c08c6eb8352ce1bfa700d6_720w.jpg" alt="img"></p><p>下面我们再看如何用InvocationHandler实现同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">InvocationHandler是一个JDK提供的标准接口。看下面的代码：<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynaProxyHello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">bind</span><span class="hljs-params">(Object delegate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.delegate = delegate;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>        <span class="hljs-keyword">this</span>.delegate.getClass().getClassLoader(), <span class="hljs-keyword">this</span>.delegate<br>        .getClass().getInterfaces(), <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;问候之前的日志记录...&quot;</span>);<br>            <span class="hljs-comment">// JVM通过这条语句执行原来的方法(反射机制)</span><br>            result = method.invoke(<span class="hljs-keyword">this</span>.delegate, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码里的<a href="https://www.zhihu.com/search?q=bind%E6%96%B9%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:42516717%7D">bind方法</a>很想我之前代理类StaticProxy的setImpl方法，只不过这个bind方法的输入参数类型更加通用。日志记录的代码写在方法invoke里。</p><p>看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>    DynaProxyHello helloproxy = <span class="hljs-keyword">new</span> DynaProxyHello();<br>    Helloimplements hello = <span class="hljs-keyword">new</span> Helloimplements();<br>    IHello ihello = (IHello) helloproxy.bind(hello);<br>    ihello.sayHello(<span class="hljs-string">&quot;Jerry&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行效果和StaticProxy那种解决方案完全一致。</p><p>咱们先来调试一下。当bind方法执行时，方法Proxy.newProxyInstance被调用，Helloimplements类的实例被传入。</p><p><img src="https://pic1.zhimg.com/80/v2-81cc7441d1e99a478bff126c7ab5426c_720w.jpg" alt="img"></p><p>我们在调试器里观察IHello ihello = (IHello) <a href="https://www.zhihu.com/search?q=helloproxy.bind&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:42516717%7D">helloproxy.bind</a>(hello)这行语句返回的<a href="https://www.zhihu.com/search?q=ihello%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:42516717%7D">ihello变量</a>。虽然它的静态类型是IHello，但请注意，在调试器里观察它的实际类型，并不是Helloimplements的实例，而是JVM给我们加过工的，包含了我们在invoke方法里手写的那行日志记录代码。这个ihello类型为$Proxy0。</p><p><img src="https://pic2.zhimg.com/80/v2-07d0736deb036f03321c7b26b0353595_720w.jpg" alt="img"></p><p>当这个被JVM加过工的变量的sayHello方法被调用时，JVM自动将调用转交到DynaProxyHello.invoke去：</p><p><img src="https://pic1.zhimg.com/80/v2-07f35c7f15b7a7012f246cb453f5ad88_720w.jpg" alt="img"></p><p>于是，在invoke方法里，我们手写的日志记录代码被执行，然后通过Java反射执行原始的sayHello代码。</p><p>有的朋友可能会问，你这个InvocationHandler看起来比<a href="https://www.zhihu.com/search?q=%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86StaticProx&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:42516717%7D">静态代理StaticProx</a>y还复杂啊？有什么好处？</p><p>假设老板的需求又变了，在调用问候和说再见的方法里，要使用不同的日志记录策略。</p><p>看看用InvocationHandler如何优雅实现吧：</p><p><img src="https://pic3.zhimg.com/80/v2-4b79eca3b74d927fc4ebbd41aec878d2_720w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>3.反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解基础</title>
    <link href="/2022/01/06/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/06/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”</p><p><strong>注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// this is a component:</span><br><span class="hljs-meta">@Resource</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-meta">@Inject</span><br>    int n;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span> <span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        System.out.println(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</strong></p><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p><h4 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h4><p>Java的注解可以分为三类：</p><h5 id="编译期给编译器使用-Retention-RetentionPolicy-SOURCE"><a href="#编译期给编译器使用-Retention-RetentionPolicy-SOURCE" class="headerlink" title="编译期给编译器使用(@Retention(RetentionPolicy.SOURCE))"></a>编译期给编译器使用(@Retention(RetentionPolicy.SOURCE))</h5><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解<strong>不会</strong>被编译进入<code>.class</code>文件，它们在<strong>编译后就被编译器扔掉了</strong>。</p><h5 id="工具-ClassLoader-处理-class文件使用-Retention-RetentionPolicy-CLASS"><a href="#工具-ClassLoader-处理-class文件使用-Retention-RetentionPolicy-CLASS" class="headerlink" title="工具(ClassLoader?)处理.class文件使用(@Retention(RetentionPolicy.CLASS))"></a>工具(ClassLoader?)处理.class文件使用(@Retention(RetentionPolicy.CLASS))</h5><p>比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。<strong>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存(不会被加载进JVM)中</strong>。这类注解只被一些底层库使用，一般我们不必自己处理。</p><h5 id="程序运行期能够读取的注解-Retention-RetentionPolicy-RUNTIME"><a href="#程序运行期能够读取的注解-Retention-RetentionPolicy-RUNTIME" class="headerlink" title="程序运行期能够读取的注解(@Retention(RetentionPolicy.RUNTIME))"></a>程序运行期能够读取的注解(@Retention(RetentionPolicy.RUNTIME))</h5><p>它们在加载后一直存在于JVM中，这也是最常用的注解。例如，<strong>一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解?）</strong>。</p><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String类型；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组。</li></ul><p>因为配置参数<strong>必须是常量</strong>，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p><p>注解的配置参数可以有<code>默认值</code>，缺少某个配置参数时将使用默认值。</p><p>此外，<strong>大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数</strong>。</p><p>如果只写注解，相当于全部使用默认值。</p><p>举个栗子，对以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-meta">@Check(min=0, max=100, value=55)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> n;<br><br>    <span class="hljs-meta">@Check(value=99)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p;<br><br>    <span class="hljs-meta">@Check(99)</span> <span class="hljs-comment">// @Check(value=99)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> x;<br><br>    <span class="hljs-meta">@Check</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>注解（Annotation）是Java语言用于工具处理的标注：</p><p>注解可以配置参数，没有指定配置的参数使用默认值；</p><p><strong>如果参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</strong></p><h1 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h1><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> @<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Report</span> </span>&#123;<br>    int type() <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">String</span> level() <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    <span class="hljs-keyword">String</span> value() <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解的参数类似<strong>无参数方法</strong>，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p><h3 id="元注解-可以修饰其他注解的注解"><a href="#元注解-可以修饰其他注解的注解" class="headerlink" title="元注解(可以修饰其他注解的注解)"></a>元注解(可以修饰其他注解的注解)</h3><p><strong>有一些注解可以修饰其他注解</strong>，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="Target-定义注解使用目标"><a href="#Target-定义注解使用目标" class="headerlink" title="@Target(定义注解使用目标)"></a>@Target(定义注解使用目标)</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们**必须添加一个<code>@Target(ElementType.METHOD)</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为<strong>数组</strong><code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;<br>    ElementType.METHOD,<br>    ElementType.FIELD<br>&#125;)<br>public <span class="hljs-variable">@interface</span> Report &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法(多参数语法糖?)。</p><h4 id="Retention-保留-定义生命周期-不存在或不设置则默认为RetentionPolicy-CLASS"><a href="#Retention-保留-定义生命周期-不存在或不设置则默认为RetentionPolicy-CLASS" class="headerlink" title="@Retention(保留,定义生命周期,不存在或不设置则默认为RetentionPolicy.CLASS)"></a>@Retention(保留,定义生命周期,不存在或不设置则默认为RetentionPolicy.CLASS)</h4><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><p><strong>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Repeatable-可重复"><a href="#Repeatable-可重复" class="headerlink" title="@Repeatable(可重复)"></a>@Repeatable(可重复)</h4><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否**可重复(可在一个地方重复使用)**。这个注解应用不是特别广泛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(Reports.class)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//嵌套注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Reports &#123;<br>    Report[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Report(type=1, level=&quot;debug&quot;)</span><br><span class="hljs-meta">@Report(type=2, level=&quot;warning&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Inherited-子类继承父类注解-仅针对type注解有用-切仅对类有效-对接口无效"><a href="#Inherited-子类继承父类注解-仅针对type注解有用-切仅对类有效-对接口无效" class="headerlink" title="@Inherited(子类继承父类注解,仅针对type注解有用,切仅对类有效,对接口无效)"></a>@Inherited(子类继承父类注解,仅针对type注解有用,切仅对类有效,对接口无效)</h4><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。**<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>**类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用的时候，如果一个类用到了<code>@Report</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Report(type=1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>则它的子类默认也定义了该注解：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何定义Annotation"><a href="#如何定义Annotation" class="headerlink" title="如何定义Annotation"></a>如何定义Annotation</h3><p>我们总结一下定义<code>Annotation</code>的步骤：</p><h4 id="1-用-interface定义注解："><a href="#1-用-interface定义注解：" class="headerlink" title="1.用@interface定义注解："></a>1.用<code>@interface</code>定义注解：</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> @<span class="hljs-keyword">interface</span> <span class="hljs-symbol">Report</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-添加参数、默认值："><a href="#2-添加参数、默认值：" class="headerlink" title="2.添加参数、默认值："></a>2.添加参数、默认值：</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> @<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Report</span> </span>&#123;<br>    int type() <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">String</span> level() <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    <span class="hljs-keyword">String</span> value() <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p><h4 id="3-用元注解配置注解-一般必须配置-Target-Retention-："><a href="#3-用元注解配置注解-一般必须配置-Target-Retention-：" class="headerlink" title="3.用元注解配置注解(一般必须配置@Target,@Retention)**："></a>3.用元注解配置注解(一般必须配置@Target,@Retention)**：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，**必须设置<code>@Target</code>和<code>@Retention</code>**，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java使用<code>@interface</code>定义注解：</p><p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p><p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p><p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p><h1 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h1><h3 id="如何判断注解存在与获取注解"><a href="#如何判断注解存在与获取注解" class="headerlink" title="如何判断注解存在与获取注解"></a>如何判断注解存在与获取注解</h3><p><strong>Java的注解本身对代码逻辑没有任何影响</strong>。根据<code>@Retention</code>的配置：</p><ul><li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li><li><code>CLASS</code>类型的注解<strong>仅保存在class文件中，它们不会被加载进JVM</strong>；</li><li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们<strong>一般只使用，不编写</strong>。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p><p>因此，我们只讨论如何读取<code>RUNTIME</code>类型的注解。</p><p>因为<strong>注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</strong></p><p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p><ul><li><code>Class.isAnnotationPresent(Class)</code></li><li><code>Field.isAnnotationPresent(Class)</code></li><li><code>Method.isAnnotationPresent(Class)</code></li><li><code>Constructor.isAnnotationPresent(Class)</code></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断@Report是否存在于Person类:</span><br>Person.class.isAnnotationPresent(Report.class);<br></code></pre></td></tr></table></figure><p>使用反射API读取Annotation( getAnnotation(注解.class) )：</p><ul><li><code>Class.getAnnotation(Class)</code></li><li><code>Field.getAnnotation(Class)</code></li><li><code>Method.getAnnotation(Class)</code></li><li><code>Constructor.getAnnotation(Class)</code></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Person定义的@Report注解:</span><br>Report report = Person.class.getAnnotation(Report.class);<br><span class="hljs-comment">// 获取@Report注解属性</span><br><span class="hljs-keyword">int</span> type = report.type();<br>String level = report.level();<br></code></pre></td></tr></table></figure><h3 id="读取注解的两种写法"><a href="#读取注解的两种写法" class="headerlink" title="读取注解的两种写法"></a>读取注解的两种写法</h3><p>使用反射API读取<code>Annotation</code>有两种方法。方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls = Person.class;<br><span class="hljs-keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;<br>    Report report = cls.getAnnotation(Report.class);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls = Person.class;<br>Report report = cls.getAnnotation(Report.class);<br><span class="hljs-keyword">if</span> (report != <span class="hljs-keyword">null</span>) &#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读取方法注解-用二维数组-一次获取方法所有参数的注解"><a href="#读取方法注解-用二维数组-一次获取方法所有参数的注解" class="headerlink" title="读取方法注解(用二维数组 一次获取方法所有参数的注解)"></a>读取方法注解(用二维数组 一次获取方法所有参数的注解)</h4><p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">hello</span>(<span class="hljs-variable">@NotNull</span> <span class="hljs-variable">@Range</span>(max=<span class="hljs-number">5</span>) String name, <span class="hljs-variable">@NotNull</span> String prefix) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Method实例:</span><br>Method m = ...<br><span class="hljs-comment">// 获取所有参数的Annotation(二维数组):</span><br>Annotation[][] annos = m.getParameterAnnotations();<br><span class="hljs-comment">// 第一个参数（索引为0）的所有Annotation:</span><br>Annotation[] annosOfName = annos[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (Annotation anno : annosOfName) &#123;<br>    <span class="hljs-keyword">if</span> (anno <span class="hljs-keyword">instanceof</span> Range) &#123; <span class="hljs-comment">// @Range注解</span><br>        Range r = (Range) anno;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anno <span class="hljs-keyword">instanceof</span> NotNull) &#123; <span class="hljs-comment">// @NotNull注解</span><br>        NotNull n = (NotNull) anno;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用注解-1"><a href="#使用注解-1" class="headerlink" title="使用注解"></a>使用注解</h3><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p><p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.FIELD)<br>public <span class="hljs-variable">@interface</span> Range &#123;<br>    <span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">min</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">0</span>;<br>    <span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">max</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">255</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在某个JavaBean中，我们可以使用该注解：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Person &#123;<br>    @<span class="hljs-built_in">Range</span>(<span class="hljs-built_in">min</span>=<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-keyword">name</span>;<br><br>    @<span class="hljs-built_in">Range</span>(<span class="hljs-built_in">max</span>=<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">public</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，定义了注解，<strong>本身对程序逻辑没有任何影响</strong>。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(Person person)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;<br>    <span class="hljs-comment">// 遍历所有Field:</span><br>    <span class="hljs-keyword">for</span> (Field field : person.getClass().getFields()) &#123;<br>        <span class="hljs-comment">// 获取Field定义的@Range:</span><br>        Range range = field.getAnnotation(Range.class);<br>        <span class="hljs-comment">// 如果@Range存在:</span><br>        <span class="hljs-keyword">if</span> (range != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 获取Field的值:</span><br>            Object value = field.get(person);<br>            <span class="hljs-comment">// 如果值是String:</span><br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>                String s = (String) value;<br>                <span class="hljs-comment">// 判断值是否满足@Range的min/max:</span><br>                <span class="hljs-keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Invalid field: &quot;</span> + field.getName());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用<code>@Range</code>注解来检查Java Bean的字段。如果字段类型是<code>String</code>，就检查<code>String</code>的长度，如果字段是<code>int</code>，就检查<code>int</code>的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czk997.czk996;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br><br><br>    <span class="hljs-meta">@Range</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Range</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Range</span><br>    <span class="hljs-keyword">protected</span> Long id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validRange</span><span class="hljs-params">(Person p)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Class&lt;Range&gt; rangeClass = Range.class;<br>        Field[] fields = p.getClass().getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            Class&lt;?&gt; type = field.getType();<br>            System.out.println(field);<br><br>            <span class="hljs-keyword">if</span> (field.isAnnotationPresent(rangeClass)) &#123;<br>                Range range = field.getAnnotation(rangeClass);<br>                <span class="hljs-keyword">int</span> min = range.min();<br>                <span class="hljs-keyword">int</span> max = range.max();<br>                Object val = field.get(p);<br>                <span class="hljs-keyword">if</span> (type.isAssignableFrom(String.class)) &#123;<br>                    String s = (String) val;<br>                    <span class="hljs-keyword">int</span> length = s.length();<br>                    <span class="hljs-keyword">if</span> (length &lt; min || length &gt; max) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;字符串长度:&quot;</span> + length + <span class="hljs-string">&quot;不在指定范围 min:&quot;</span> + min + <span class="hljs-string">&quot;  max:&quot;</span> + max);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.isAssignableFrom(<span class="hljs-keyword">int</span>.class)) &#123;<br>                    <span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>) val;<br>                    <span class="hljs-keyword">if</span> (i &lt; min || i &gt; max) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;数字大小:&quot;</span> + i + <span class="hljs-string">&quot;不在指定范围 min:&quot;</span> + min + <span class="hljs-string">&quot;  max:&quot;</span> + max);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">55L</span>);<br>        validRange(person);<br>    &#125;<br><br>    <span class="hljs-meta">@Target(ElementType.FIELD)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br>    <span class="hljs-meta">@interface</span> Range &#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 1</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 10</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>可以在运行期通过反射读取<code>RUNTIME</code>类型的注解，注意千万不要漏写<code>@Retention(RetentionPolicy.RUNTIME)</code>，否则运行期无法读取到该注解。</p><p>可以通过程序处理注解来实现相应的功能：</p><ul><li>对JavaBean的属性值按规则进行检查；</li><li>JUnit会自动运行<code>@Test</code>标记的测试方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>4.注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0</title>
    <link href="/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/0.Iterator%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/0.Iterator%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="Iterator-1"><a href="#Iterator-1" class="headerlink" title="Iterator"></a>Iterator</h3><h3 id="ListIterator-1"><a href="#ListIterator-1" class="headerlink" title="ListIterator"></a>ListIterator</h3>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>6.集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/1.List%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/1.List%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>6.集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用集合工具类</title>
    <link href="/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>6.集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/2022/01/06/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E6%A1%86%E6%9E%B6%E6%B3%A8%E8%A7%A3/Lombok/"/>
    <url>/2022/01/06/Core/Java/4.%E6%B3%A8%E8%A7%A3/%E6%A1%86%E6%9E%B6%E6%B3%A8%E8%A7%A3/Lombok/</url>
    
    <content type="html"><![CDATA[<h2 id="Lombok-注解简介"><a href="#Lombok-注解简介" class="headerlink" title="Lombok 注解简介"></a>Lombok 注解简介</h2><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>@AllArgsConstructor为类中的每个字段生成一个带有1个参数的构造函数，标记为的字段@NonNull将对这些参数进行空检查。这里我们使用注解属性staticName来生成静态工厂方法，使用of作为静态工厂方法名。（注：of的静态工厂方法在jdk中越来越流行）编译后，查看反编译文件，如图:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成一个包含所有属性的构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AllArgsConstructor &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果设置了该属性，则生成的构造函数将被设置为 private，并增加一个静态的方法来创建实例，</span><br><span class="hljs-comment">     * 静态方法将包含构造函数的所有属性，静态方法的名称为 staticName 的属性值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">staticName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    AnyAnnotation[] onConstructor() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成构造函数的访问级别，默认是 PUBLIC</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">AccessLevel <span class="hljs-title">access</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> lombok.AccessLevel.PUBLIC</span>;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-meta">@Target(&#123;&#125;)</span><br>    <span class="hljs-meta">@interface</span> AnyAnnotation &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>@RequiredArgsConstructor为每个需要特殊处理的字段生成一个带有1个参数的构造函数。所有未初始化的final字段以及标有@NonNull注解的字段。对于标有@NonNull注解的字段，还将生成一个显式的null检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成一个包含所有 final 属性或有约束的属性【<span class="hljs-doctag">@NonNull</span>】的构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RequiredArgsConstructor &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果设置了该属性，则生成的构造函数将被设置为 private，并增加一个静态的方法来创建实例，</span><br><span class="hljs-comment">     * 静态方法将包含构造函数的所有属性，静态方法的名称为 staticName 的属性值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">staticName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    AnyAnnotation[] onConstructor() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成构造函数的访问级别，默认是 PUBLIC</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">AccessLevel <span class="hljs-title">access</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> lombok.AccessLevel.PUBLIC</span>;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-meta">@Target(&#123;&#125;)</span><br>    <span class="hljs-meta">@interface</span> AnyAnnotation &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>@NoArgsConstructor将生成没有参数的构造函数。如果一个类仅仅只需要一个无参的构造函数，那么完全没有必要使用@NoArgsConstructor注解，因为Java会在编译时，为没有构造函数的类自动生成一个无参的构造函数。所以@NoArgsConstructor注解需要在已经存在构造函数时使用，才显得有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 尝试生成一个无参数的构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NoArgsConstructor &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果设置了该属性，则生成的构造函数将被设置为 private，并增加一个静态的方法来创建实例，</span><br><span class="hljs-comment">     * 静态方法将包含构造函数的所有属性，静态方法的名称为 staticName 的属性值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">staticName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    AnyAnnotation[] onConstructor() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成构造函数的访问级别，默认是 PUBLIC</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">AccessLevel <span class="hljs-title">access</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> lombok.AccessLevel.PUBLIC</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果存在 final 属性，则无法生成无参数的构造函数【编译失败】，如果将 force 设置为 true，</span><br><span class="hljs-comment">     * 则所有的 final 属性将被初始化为默认值【0 / null / false】.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">force</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-meta">@Target(&#123;&#125;)</span><br>    <span class="hljs-meta">@interface</span> AnyAnnotation &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="@Getter"></a>@Getter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果该注解放置在目标属性上，则会为该属性生成一个标准的 get 方法，</span><br><span class="hljs-comment"> * 如果该注解放置在类上，则会为类中的每一个非静态属性生成一个标准的  get 方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Getter &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 get 方法的访问级别，默认是 PUBLIC</span><br><span class="hljs-comment">     */</span><br>    lombok.<span class="hljs-function">AccessLevel <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> lombok.AccessLevel.PUBLIC</span>;<br><br>    AnyAnnotation[] onMethod() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">lazy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-meta">@Target(&#123;&#125;)</span><br>    <span class="hljs-meta">@interface</span> AnyAnnotation &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Setter"><a href="#Setter" class="headerlink" title="@Setter"></a>@Setter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果该注解放置在目标属性上，则会为该属性生成一个标准的 set 方法，</span><br><span class="hljs-comment"> * 如果该注解放置在类上，则会为类中的每一个非静态属性生成一个标准的  set 方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Setter &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 set 方法的访问级别，默认是 PUBLIC</span><br><span class="hljs-comment">     */</span><br>    lombok.<span class="hljs-function">AccessLevel <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> lombok.AccessLevel.PUBLIC</span>;<br><br>    AnyAnnotation[] onMethod() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    AnyAnnotation[] onParam() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-meta">@Target(&#123;&#125;)</span><br>    <span class="hljs-meta">@interface</span> AnyAnnotation &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为所有的相关属性生成 hashCode 和 equals 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EqualsAndHashCode &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 hashCode 和 equals 方法时，需要排除的属性列表</span><br><span class="hljs-comment">     */</span><br>    String[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 显式列出需要包含的属性列表，通常非静态 static 和非瞬态 transient 的属性都作为比较目标</span><br><span class="hljs-comment">     */</span><br>    String[] of() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算 hashCode 值之前，首先调用父类的 hashCode 方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">callSuper</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认情况下，将调用 get 方法来读取属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">doNotUseGetters</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    AnyAnnotation[] onParam() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-meta">@Target(&#123;&#125;)</span><br>    <span class="hljs-meta">@interface</span> AnyAnnotation &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 只包含使用 <span class="hljs-doctag">@EqualsAndHashCode</span>.Include 注解标记的所有属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onlyExplicitlyIncluded</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 不包含此单个属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Target(ElementType.FIELD)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Exclude &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 包含此单个属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Include &#123;<br>        <span class="hljs-comment">/** Defaults to the method name of the annotated member. If on a method and the name equals the name of a default-included field, this member takes its place. */</span><br>        <span class="hljs-function">String <span class="hljs-title">replaces</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为所有的相关属性生成 toString() 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ToString &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * toString() 方法返回的字符串中是否包含属性名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">includeFieldNames</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 toString() 方法时，需要排除的属性列表</span><br><span class="hljs-comment">     */</span><br>    String[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 toString() 方法时，需要包含的属性列表</span><br><span class="hljs-comment">     */</span><br>    String[] of() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 toString() 方法时，是否优先调用父类的 toString()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">callSuper</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认情况下，将调用 get 方法来读取属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">doNotUseGetters</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 只包含使用 <span class="hljs-doctag">@ToString</span>.Include 注解标记的所有属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onlyExplicitlyIncluded</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 显式排除此属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Target(ElementType.FIELD)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Exclude &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 显式包含此属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Include &#123;<br>        <span class="hljs-comment">/** 更高的 rank 优先打印，相同 rank 的属性按照源代码中的声明顺序打印 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rank</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br><br>        <span class="hljs-comment">/** 输出的属性名称 */</span><br>        <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果该注解放置在参数上，则在构造函数或方法体执行前将会增加目标参数的 null 校验。</span><br><span class="hljs-comment"> * 如果该注解放置在属性上，则对该属性的写操作都将添加 null 校验。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.TYPE_USE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NonNull &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等价于 <span class="hljs-doctag">@Getter</span> <span class="hljs-doctag">@Setter</span> <span class="hljs-doctag">@RequiredArgsConstructor</span> <span class="hljs-doctag">@ToString</span> <span class="hljs-doctag">@EqualsAndHashCode</span>.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Data &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果设置了该属性，则生成的构造函数将被设置为 private，并增加一个静态的方法来创建实例，</span><br><span class="hljs-comment">     * 静态方法将包含构造函数的所有属性，静态方法的名称为 staticName 的属性值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">staticConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等价于 <span class="hljs-doctag">@Getter</span> <span class="hljs-doctag">@FieldDefaults</span>(makeFinal=true, level=AccessLevel.PRIVATE)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@AllArgsConstructor</span> <span class="hljs-doctag">@ToString</span> <span class="hljs-doctag">@EqualsAndHashCode</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Value &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果设置了该属性，则生成的构造函数将被设置为 private，并增加一个静态的方法来创建实例，</span><br><span class="hljs-comment">     * 静态方法将包含构造函数的所有属性，静态方法的名称为 staticName 的属性值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">staticConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * fluent build API</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;TYPE, METHOD, CONSTRUCTOR&#125;)</span><br><span class="hljs-meta">@Retention(SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Builder &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性的默认值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Target(FIELD)</span><br>    <span class="hljs-meta">@Retention(SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Default &#123;&#125;<br><br>    <span class="hljs-comment">/** 创建 builder 实例的方法名称 */</span><br>    <span class="hljs-function">String <span class="hljs-title">builderMethodName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;builder&quot;</span>;<br><br>    <span class="hljs-comment">/** 构建目标实例的方法名称 */</span><br>    <span class="hljs-function">String <span class="hljs-title">buildMethodName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;build&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * builder 类的名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">builderClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将此类的实例转换为 builder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">toBuilder</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 只有 toBuilder 为 true 时才有效。</span><br><span class="hljs-comment">     * 用于从目标实例中读取值，可以放置在属性、构造方法参数、静态方法上</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Target(&#123;FIELD, PARAMETER&#125;)</span><br>    <span class="hljs-meta">@Retention(SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ObtainVia &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> Tells lombok to obtain a value with the expression &#123;<span class="hljs-doctag">@code</span> this.value&#125;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">String <span class="hljs-title">field</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> Tells lombok to obtain a value with the expression &#123;<span class="hljs-doctag">@code</span> this.method()&#125;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">String <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> Tells lombok to obtain a value with the expression &#123;<span class="hljs-doctag">@code</span> SelfType.method(this)&#125;; requires &#123;<span class="hljs-doctag">@code</span> method&#125; to be set.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Singular"><a href="#Singular" class="headerlink" title="@Singular"></a>@Singular</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 与 Builder 注解共同使用，用于将单个元素添加到集合属性中【放置在集合属性上】</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;FIELD, PARAMETER&#125;)</span><br><span class="hljs-meta">@Retention(SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Singular &#123;<br>    <span class="hljs-comment">/** 添加单个元素的方法名称 */</span><br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lombok</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">all</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> User user = User.builder().addName(<span class="hljs-string">&quot;hello&quot;</span>).addName(<span class="hljs-string">&quot;world&quot;</span>).build();<br>        assertEquals(<span class="hljs-number">2</span>, user.names.size());<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Builder</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-meta">@Singular(&quot;addName&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; names;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a>@Cleanup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过 try-final 方式自动释放资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.LOCAL_VARIABLE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Cleanup &#123;<br>    <span class="hljs-comment">/** 释放资源的无参方法名称 */</span><br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;close&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将方法显示抛出的指定异常封装为 RuntimeException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SneakyThrows &#123;<br>    <span class="hljs-comment">/** 需要转换的异常类型列表 */</span><br>    Class&lt;? extends Throwable&gt;[] value() <span class="hljs-keyword">default</span> java.lang.Throwable.class;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lombok</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">all</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String hello = <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-keyword">final</span> String of = of(hello.getBytes(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        assertEquals(of, hello);<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">of</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes,String charsetName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> java.lang.String(bytes, charsetName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 synchronized 关键字修饰目标方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Synchronized &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要锁定的目标字段名称，不指定时默认使用 this【实例方法】或此类的 Class 实例【静态方法】</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="val"><a href="#val" class="headerlink" title="@val"></a>@val</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用在局部变量定义处，变量的类型根据赋值表达式进行推断，该变量被 final 修饰。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> val &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lombok</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">all</span><span class="hljs-params">()</span> </span>&#123;<br>        val name = <span class="hljs-string">&quot;hello&quot;</span>;<br>        assertEquals(name.getClass(), String.class);<br><br>        val list = Lists.newArrayList();<br>        assertEquals(list.getClass(), ArrayList.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FieldDefaults"><a href="#FieldDefaults" class="headerlink" title="@FieldDefaults"></a>@FieldDefaults</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 往此类中的每个字段添加修饰符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FieldDefaults &#123;<br>    <span class="hljs-function">AccessLevel <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AccessLevel.NONE</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">makeFinal</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UtilityClass"><a href="#UtilityClass" class="headerlink" title="@UtilityClass"></a>@UtilityClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于创建工具类的注解：</span><br><span class="hljs-comment"> * 1）类将被标记为 final</span><br><span class="hljs-comment"> * 2）类中不能有显式声明的构造函数否则编译出错，同时添加一个私有无参构造函数，此构造函数将抛出 UnsupportedOperationException 异常</span><br><span class="hljs-comment"> * 3）所有的属性、方法、内部类都被 static 修饰</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UtilityClass &#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>4.注解</category>
      
      <category>框架注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/01/06/Core/Java/3.%E5%8F%8D%E5%B0%84/1.1%E5%AD%97%E8%8A%82%E7%A0%81(.class)%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/01/06/Core/Java/3.%E5%8F%8D%E5%B0%84/1.1%E5%AD%97%E8%8A%82%E7%A0%81(.class)%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个Java开发者，对技术的追求而不仅仅停留在会用API，会写基本功能上，要想在技术上有更高的造诣，就需要深入到原理层面去认识代码运行的机制。因此，本文从class字节码文件的结构入手，一步步来解剖二进制字节码的内部工作原理，这对深入理解JVM的运行机制大有裨益，同时，对于想要使用BCEL来动态改变Class字节码指令的工作也很有帮助(示例：<a href="https://link.jianshu.com/?t=https://yq.aliyun.com/articles/7243">JVM Class字节码之三-使用BCEL改变类属性</a>)。</p><h2 id="什么是Class文件"><a href="#什么是Class文件" class="headerlink" title="什么是Class文件"></a>什么是Class文件</h2><p>Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。</p><p>Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><p>class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。</p><h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><p>一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分，用一个数据结构可以表示如下：</p><p><img src="http://static.zybuluo.com/Wind729/firt103iv1wox6jb2mrkpt4r/class_code.PNG" alt="class_code.PNG-21.1kB"></p><p>class_code.PNG-21.1kB</p><p>下面对class文件中的每一项进行详细的解释：</p><p>1、<strong>magic</strong><br> 在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： 0XCAFEBABE 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是0XCAFEBABE， 那么就说明它不是class文件， 不能被JVM识别。</p><p>2、<strong>minor_version 和 major_version</strong><br> 紧接着魔数的四个字节是class文件的此版本号和主版本号。<br> 随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。具体的版本号变迁这里不再讨论， 需要的读者自行查阅资料。</p><p>3、<strong>constant_pool</strong><br> 在class文件中， 位于版本号后面的就是常量池相关的数据项。 常量池是class文件中的一项非常重要的数据。 常量池中存放了文字字符串， 常量值， 当前类的类名， 字段名， 方法名， 各个字段和方法的描述符， 对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等。 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的this_class, super_class, field_info, attribute_info等， 另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。此外，常量池中各个项也会相互引用。</p><p>常量池是一个类的结构索引，其它地方对“对象”的引用可以通过索引位置来代替，我们知道在程序中一个变量可以不断地被调用，要快速获取这个变量常用的方法就是通过索引变量。这种索引我们可以直观理解为“内存地址的虚拟”。我们把它叫静态池的意思就是说这里维护着经过编译“梳理”之后的相对固定的数据索引，它是站在整个JVM（进程）层面的共享池。</p><p>class文件中的项constant_pool_count的值为1, 说明每个类都只有一个常量池。 常量池中的数据也是一项一项的， 没有间隙的依次排放。常量池中各个数据项通过索引来访问， 有点类似与数组， 只不过常量池中的第一项的索引为1, 而不为0, 如果class文件中的其他地方引用了索引为0的常量池项， 就说明它不引用任何常量池项。class文件中的每一种数据项都有自己的类型， 相同的道理，常量池中的每一种数据项也有自己的类型。 常量池中的数据项的类型如下表：</p><p><img src="http://static.zybuluo.com/Wind729/y0rw90a07nqpi1koeisr29bb/constant_pool.PNG" alt="constant_pool.PNG-25.4kB"></p><p>constant_pool.PNG-25.4kB</p><p>每个数据项叫做一个XXX_info项，比如，一个常量池中一个CONSTANT_Utf8类型的项，就是一个CONSTANT_Utf8_info 。除此之外， 每个info项中都有一个标志值（tag），这个标志值表明了这个常量池中的info项的类型是什么， 从上面的表格中可以看出，一个CONSTANT_Utf8_info中的tag值为1，而一个CONSTANT_Fieldref_info中的tag值为9 。</p><p>Java程序是动态链接的， 在动态链接的实现中， 常量池扮演者举足轻重的角色。 除了存放一些字面量之外， 常量池中还存放着以下几种符号引用：<br> （1） 类和接口的全限定名<br> （2） 字段的名称和描述符<br> （3） 方法的名称和描述符<br> 我们有必要先了解一下class文件中的特殊字符串， 因为在常量池中， 特殊字符串大量的出现，这些特殊字符串就是上面说的全限定名和描述符。对于常量池中的特殊字符串的了解，可以参考此文档：<a href="https://link.jianshu.com/?t=http://www.jb51.net/article/116313.htm">Java class文件格式之特殊字符串_动力节点Java学院整理</a></p><p>4、<strong>access_flag</strong> 保存了当前类的访问权限</p><p>5、<strong>this_cass</strong>  保存了当前类的全局限定名在常量池里的索引</p><p>6、<strong>super class</strong> 保存了当前类的父类的全局限定名在常量池里的索引</p><p>7、<strong>interfaces</strong> 保存了当前类实现的接口列表，包含两部分内容：interfaces_count 和interfaces[interfaces_count]<br> interfaces_count 指的是当前类实现的接口数目<br> interfaces[] 是包含interfaces_count个接口的全局限定名的索引的数组</p><p>8、<strong>fields</strong> 保存了当前类的成员列表，包含两部分的内容：fields_count 和 fields[fields_count]<br> fields_count是类变量和实例变量的字段的数量总和。<br> fileds[]是包含字段详细信息的列表。</p><p>9、<strong>methods</strong> 保存了当前类的方法列表，包含两部分的内容：methods_count和methods[methods_count]<br> methods_count是该类或者接口显示定义的方法的数量。<br> method[]是包含方法信息的一个详细列表。</p><p>10、<strong>attributes</strong> 包含了当前类的attributes列表，包含两部分内容：attributes_count 和 attributes[attributes_count]<br> class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。attributes_count指的是attributes列表中包含的attribute_info的数量。<br> 属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。</p><h2 id="通过示例代码来手动分析class文件"><a href="#通过示例代码来手动分析class文件" class="headerlink" title="通过示例代码来手动分析class文件"></a>通过示例代码来手动分析class文件</h2><p>上面大致讲解了一下class文件的结构，这里，我们拿一个class文件做一个简单的分析，来验证上面的文件结构是否确实是如此。</p><p>我们在这里新建一个java文件，Hello.java，具体内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span>&#123;</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> test;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> test;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再通过javac命令将此java文件编译成class文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">javac <span class="hljs-regexp">/d/</span>class_file_test/Hello.java<br></code></pre></td></tr></table></figure><p>编译之后的class文件十六进制结果如下所示，可以用UltraEdit等十六进制编辑器打开，得到：</p><p><img src="http://static.zybuluo.com/Wind729/xxy7sc8k65wd060vl7h47hnh/hello_class_test.PNG" alt="hello_class_test.PNG-22.6kB"></p><p>hello_class_test.PNG-22.6kB</p><p>接下来我们就按照class文件的格式来分析上面的一串数字，还是按照之前的顺序来：</p><ol><li><p><strong>magic</strong>:<br> <code>CA FE BA BE</code> ，代表该文件是一个字节码文件，我们平时区分文件类型都是通过后缀名来区分的，不过后缀名是可以随便修改的，所以仅靠后缀名不能真正区分一个文件的类型。区分文件类型的另个办法就是magic数字，JVM 就是通过 CA FE BA BE 来判断该文件是不是class文件</p></li><li><p><strong>version字段</strong>：<br> <code>00 00 00 34</code>，前两个字节00是minor_version，后两个字节0034是major_version字段，对应的十进制值为52，也就是说当前class文件的主版本号为52，次版本号为0。下表是jdk 1.6 以后对应支持的 Class 文件版本号：</p><p><img src="http://static.zybuluo.com/Wind729/pwtmpc9fws585t7h2dtdb0ml/image_1c2th3nii1otd13vg1vhg1hl6itg4i.png" alt="image_1c2th3nii1otd13vg1vhg1hl6itg4i.png-23.7kB"></p><p>image_1c2th3nii1otd13vg1vhg1hl6itg4i.png-23.7kB</p></li><li><p><strong>常量池，constant_pool:</strong><br> 3.1.  <code>constant_pool_count</code><br> 紧接着version字段下来的两个字节是：<code>00 12</code>代表常量池里包含的常量数目，因为字节码的常量池是从1开始计数的，这个常量池包含17个（0x0012-1）常量。</p><p> 3.2.<strong>constant_pool</strong><br> 接下来就是分析这17个常量:</p></li></ol><p>3.2.1.   第一个变量 <code>0a 00 04 00 0e</code><br> 首先，紧接着constant_pool_count的第一个字节0a（tag=10）根据上面的表格（文中第二张图片）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  !<span class="hljs-selector-attr">[image_1c2tj6ib6pslkbb1876ot81rjj4v.png-4kB]</span><span class="hljs-selector-attr">[7]</span><br><br>可知，这表示的是一个CONSTANT_Methodref。CONSTANT_Methodref的结构如下：<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CONSTANT_Methodref_info &#123;<br>          u1 tag;    <span class="hljs-comment">//u1表示占一个字节</span><br>          u2 class_index;    <span class="hljs-comment">//u2表示占两个字节</span><br>          u2 name_and_type_index;    <span class="hljs-comment">//u2表示占两个字节</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中class_index表示该方法所属的类在常量池里的索引，name_and_type_index表示该方法的名称和类型的索引。常量池里的变量的索引从1开始。</p><p>那么这个methodref结构的数据如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0</span>a  <span class="hljs-comment">//tag  10表示这是一个CONSTANT_Methodref_info结构</span><br><span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-comment">//class_index 指向常量池中第4个常量所表示的类</span><br><span class="hljs-number">00</span> <span class="hljs-number">0</span>e  <span class="hljs-comment">//name_and_type_index 指向常量池中第14个常量所表示的方法</span><br></code></pre></td></tr></table></figure><p>3.2.2.  第二个变量<code>09 00 03 00 0F</code><br> 接着是第二个常量，它的tag是09，根据上面的表格可知，这表示的是一个CONSTANT_Fieldref的结构，它的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> CONSTANT_Fieldref_info &#123;<br>      u1 tag;<br>      u2 class_index;<br>      u2 name_and_type_index;<br>&#125;<br></code></pre></td></tr></table></figure><p>和上面的变量基本一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">09</span> <span class="hljs-comment">//tag</span><br><span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-comment">//指向常量池中第3个常量所表示的类</span><br><span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-comment">//指向常量池中第15个常量所表示的变量</span><br></code></pre></td></tr></table></figure><p>3.2.3.  第三个变量 <code>07 00 10</code><br> tag为07表示是一个CONSTANT_Class变量，这个变量的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"> CONSTANT_Class_info &#123;<br>          u1 tag;<br>          u2 name_index;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了tag字段以外，还有一个name_index的值为<code>00 10</code>，即是指向常量池中第16个常量所表示的Class名称。</p><p>3.2.4.  第四个变量<code>07 00 11</code><br> 同上，也是一个CONSTANT_Class变量，不过，指向的是第17个常量所表示的Class名称。</p><p>3.2.5.  第五个变量 <code>01 00 04 74 65 73 74</code><br> tag为1，表示这是一个CONSTANT_Utf8结构，这种结构用UTF-8的一种变体来表示字符串，结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">CONSTANT_Utf8_info &#123;<br>               u1 tag;<br>               u2 length;<br>               u1 bytes[length];<br>&#125;<br></code></pre></td></tr></table></figure><p>其中length表示该字符串的字节数，bytes字段包含该字符串的二进制表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">01</span> <span class="hljs-comment">//tag  1表示这是一个CONSTANT_Utf8结构</span><br><span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-comment">//表示这个字符串的长度是4字节,也就是后面的四个字节74 65 73 74</span><br><span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-comment">//通过ASCII码表转换后，表示的是字符串“test”</span><br></code></pre></td></tr></table></figure><p>接下来的8个变量都是字符串，这里就不具体分析了。</p><p>3.2.6.  第十四个常量 <code>0c 00 07 00 08</code><br> tag为0c，表示这是一个CONSTANT_NameAndType结构，这个结构用来描述一个方法或者成员变量。具体结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">CONSTANT_NameAndType_info &#123;<br>          u1 tag;<br>          u2 name_index;<br>          u2 descriptor_index;<br>&#125;<br></code></pre></td></tr></table></figure><p>name_index表示的是该变量或者方法的名称，这里的值是0007，表示指向第7个常量，即是<code>&lt;init&gt;</code>。</p><p>descriptor_index指向该方法的描述符的引用，这里的值是0008，表示指向第8个常量，即是<code>()V</code>，由前面描述符的语法可知，这个方法是一个无参的，返回值为void的方法。</p><p>综合两个字段，可以推出这个方法是<code>void &lt;init&gt;()</code>。也即是指向这个NameAndType结构的Methodref的方法名为<code>void &lt;init&gt;()</code>，也就是说第一个常量表示的是<code>void &lt;init&gt;()</code>方法，这个方法其实就是此类的默认构造方法。</p><p>3.2.7.  第十五个常量也是一个CONSTANT_NameAndType，表示的方法名为“int test()”，第2个常量引用了这个NameAndType，所以第二个常量表示的是“int test()”方法。</p><p>3.2.8.  第16和17个常量也是字符串，可以按照前面的方法分析。</p><p>3.3.  <strong>完整的常量池</strong><br> 最后，通过以上分析，完整的常量池如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">00 12  常量池的数目 18-1=17<br>0a 00 04 00 0e  方法：java.lang.Ojbect void &lt;init&gt;()<br>09 00 03 00 0f   方法 ：Hello int <span class="hljs-built_in">test</span>() <br>07 00 10  字符串：Hello<br>07 00 11 字符串：java.lang.Ojbect<br>01 00 04 74 65 73 74 字符串：<span class="hljs-built_in">test</span><br>01 00 01 49  字符串：I<br>01 00 06 3c 69 6e 69 74 3e 字符串：&lt;init&gt;<br>01 00 03 28 29 56 字符串：()V<br>01 00 04 43 6f 64 65 字符串：Code <br>01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 字符串：LineNumberTable <br>01 00 03 28 29 49 字符串：()I<br>01 00 0a 53 6f 75 72 63 65 46 69 6c 65 字符串：SourceFile<br>01 00 0a 48 65 6c 6c 6f 2e 6a 61 76 61 字符串：Hello.java<br>0c 00 07 00 08 NameAndType：&lt;init&gt; ()V<br>0c 00 05 00 06 NameAndType：<span class="hljs-built_in">test</span> I<br>01 00 05 48 65 6c 6c 6f 字符串：Hello<br>01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 字符串： java/lang/Object<br></code></pre></td></tr></table></figure><p>通过这样分析其实非常的累，我们只是为了了解class文件的原理才来一步一步分析每一个二进制字节码。JDK提供了现成的工具可以直接解析此二进制文件，即javap工具(在JDK的bin目录下)，我们通过javap命令来解析此class文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">javap -v -p -s -sysinfo -constants <span class="hljs-regexp">/d/</span>class_file_test/Hello.<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>解析得到的结果为：</p><p><img src="http://static.zybuluo.com/Wind729/y3px0bt1fj1qclzo80apjhbb/class_file_2.PNG" alt="class_file_2.PNG-44.1kB"></p><p>class_file_2.PNG-44.1kB</p><p> 关于此表每一项的详细分析，可以参考国外的这一篇文档：<a href="https://link.jianshu.com/?t=http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a><br> 关于此表中Method操作指令<code>aload_1,getfield,ireturn</code>的作用，可以参考云溪社区的这篇文章：<br><a href="https://link.jianshu.com/?t=https://yq.aliyun.com/articles/7242?spm=5176.100239.blogcont7243.8.3d63c7fjRFN0C">JVM Class详解之二 Method字节码指令</a></p><p>发现了没有，上面生成代码中的<code>Constant pool</code>跟我们上面分析出来的完整常量池一模一样，有木有！有木有？<br> 这说明我们上面的分析的完成正确！</p><p>由此，我们终于弄懂了<code>Constant pool</code>的内幕。</p><p>接下来继续看其他的字段。</p><ol><li><strong>access_flag(u2)</strong><br> <code>00 21</code>这两个字节的数据表示这个变量的访问标志位，JVM对访问标示符的规范如下：</li></ol><p><img src="http://static.zybuluo.com/Wind729/tr3zxmnkvbrvl0qtnt72tj1i/access_flag.PNG" alt="access_flag.PNG-26.8kB"></p><p>access_flag.PNG-26.8kB</p><p>这个表里面无法直接查询到0021这个值，原因是0021=0020+0001，也就是表示当前class的access_flag是<code>ACC_PUBLIC|ACC_SUPER</code>。ACC_PUBLIC和代码里的public 关键字相对应。ACC_SUPER表示当用invokespecial指令来调用父类的方法时需要特殊处理。</p><ol><li><strong>this_class(u2)</strong>  <code>00 03</code><br> this_class指向constant pool的索引值，该值必须是CONSTANT_Class_info类型，这里是3，即指向常量池中的第三项，即是“Hello”。</li><li><strong>super_class</strong> <code>00 04</code><br> super_class存的是父类的名称在常量池里的索引，这里指向第四个常量，即是“java/lang/Object”。</li><li><strong>interfaces</strong><br> interfaces包含interfaces_count和interfaces[]两个字段。因为这里没有实现接口，所以就不存在interfces选项，所以这里的interfaces_count为0（0000），所以后面的内容也对应为空。</li><li><strong>fields</strong></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-number">00</span> <span class="hljs-number">01</span> fields count        <span class="hljs-comment">//表示成员变量的个数，此处为1个</span><br><span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>   <span class="hljs-comment">//成员变量的结构</span><br></code></pre></td></tr></table></figure><p>每个成员变量对应一个field_info结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">field_info &#123;<br>          u2 access_flags; 0002<br>          u2 name_index; 0005<br>          u2 descriptor_index; 0006<br>          u2 attributes_count; 0000<br>          attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><p>access_flags为0002，即是ACC_PRIVATE<br> name_index指向常量池的第五个常量，为“test”<br> descriptor_index指向常量池的第6个常量为“I”<br> 三个字段结合起来，说明这个变量是”private int test”。<br> 接下来的是attribute字段，用来描述该变量的属性，因为这个变量没有附加属性，所以attributes_count为0，attribute_info为空。</p><ol><li><strong>methods</strong><br> <code>00 02 00 01 00 07 00 08 00 01 00 09 ...</code><br> 最前面的2个字节是method_count<br> method_count：<code>00 02</code>，为什么会有两个方法呢？我们明明只写了一个方法，这是因为JVM 会自动生成一个<code>&lt;init&gt;</code>方法，这个是类的默认构造方法。</li></ol><p>接下来的内容是两个<code>method_info</code>结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">method_info &#123;<br>     u2 access_flags;<br>     u2 name_index;<br>     u2 descriptor_index;<br>     u2 attributes_count;<br>     attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><p>前三个字段和field_info一样，可以分析出第一个方法是“public void <init>()”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">00</span> <span class="hljs-number">01</span> ACC_PUBLIC<br><span class="hljs-number">00</span> <span class="hljs-number">07</span>  &lt;<span class="hljs-keyword">init</span>&gt;<br><span class="hljs-number">00</span> 08  V()<br></code></pre></td></tr></table></figure><p>接下来是attribute字段，也即是这个方法的附加属性，这里的attributes_count =1，也即是有一个属性。<br> 每个属性的都是一个attribute_info结构，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">attribute_info &#123;<br>     u2 attribute_name_index;<br>     u4 attribute_length;<br>     u1 info[attribute_length];<br>&#125;<br></code></pre></td></tr></table></figure><p>JVM预定义了部分attribute，但是编译器自己也可以实现自己的attribute写入class文件里，供运行时使用。不同的attribute通过attribute_name_index来区分。JVM规范里对以下attribute进行了预定义：</p><p><img src="http://static.zybuluo.com/Wind729/dmtcwtltw7uramvchw1q8gj0/21718047_1346754834pJjH.png" alt="21718047_1346754834pJjH.png-65.4kB"></p><p>21718047_1346754834pJjH.png-65.4kB</p><p>这里的attribute_name_index值为0009，表示指向第9个常量，即是Code。Code Attribute的作用是保存该方法的结构如所对应的字节码，具体的结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Code_attribute &#123;<br>     u2 attribute_name_index;<br>     u4 attribute_length;<br>     u2 max_stack;<br>     u2 max_locals;<br>     u4 code_length;<br>     u1 code[code_length];<br>     u2 exception_table_length;<br>     &#123; <br>          u2 start_pc;<br>          u2 end_pc;<br>          u2 handler_pc;<br>          u2 catch_type;<br>     &#125; exception_table[exception_table_length];<br>     u2 attributes_count;<br>     attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><p>attribute_length表示attribute所包含的字节数，这里为0000001d，即是39个字节，不包含attribute_name_index和attribute_length字段。<br> max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度，这里是0001<br> max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量，这里是0001.<br> 接下来的code_length表示该方法的所包含的字节码的字节数以及具体的指令码。<br> 这里的字节码长度为00000005，即是后面的5个字节 2a b7 00 01 b1为对应的字节码指令的指令码。<br> 参照下表可以将上面的指令码翻译成对应的助记符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">2a   aload_0    <br>b7   invokespecial<br><span class="hljs-number">00</span>   nop<br><span class="hljs-number">01</span>   aconst_null<br>b1   <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>这即是该方法被调用时，虚拟机所执行的字节码</p><p>接下来是exception_table，这里存放的是处理异常的信息。<br> 每个exception_table表项由start_pc，end_pc，handler_pc，catch_type组成。start_pc和end_pc表示在code数组中的从start_pc到end_pc处（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理;handler_pc表示处理异常的代码的开始处。catch_type表示会被处理的异常类型，它指向常量池里的一个异常类。当catch_type为0时，表示处理所有的异常，这个可以用来实现finally的功能。</p><p>不过，这段代码里没有异常处理，所以exception_table_length为0000，所以我们不做分析。</p><p>接下来是该方法的附加属性，attributes_count为0001，表示有一个附加属性。<br> attribute_name_index为000a，指向第十个常量，为LineNumberTable。这个属性用来表示code数组中的字节码和java代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数。LineNumberTable的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">LineNumberTable_attribute &#123;<br>          u2 attribute_name_index;<br>          u4 attribute_length;<br>          u2 line_number_table_length;<br>          &#123; u2 start_pc;<br>          u2 line_number;<br>     &#125; line_number_table[line_number_table_length];<br>&#125;<br></code></pre></td></tr></table></figure><p>前面两个字段分别表示这个attribute的名称是LineNumberTable以及长度为00000006。接下来的0001表示line_number_table_length，表示line_number_table有一个表项，其中start_pc为 00 00，line_number为 00 00，表示第0行代码从code的第0个指令码开始。</p><p>后面的内容是第二个方法，具体就不再分析了。</p><ol><li>attributes<br> 最后剩下的内容是attributes，这里的attributes表示整个class文件的附加属性，不过结构还是和前面的attribute保持一致。<code>00 01</code>表示有一个attribute。<br> Attribute结构如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">SourceFile_attribute &#123;<br>     u2 attribute_name_index;<br>     u4 attribute_length;<br>     u2 sourcefile_index;<br>&#125;<br></code></pre></td></tr></table></figure><p>attribute_name_index为000c，指向第12个常量，为SourceFile，说明这个属性是Source<br> attribute_length为00000002<br> sourcefile_index为000d，表示指向常量池里的第13个常量，为<code>Hello.java</code>。<br> 这个属性表明当前的class文件是从Hello.java文件编译而来。</p><h2 id="字节码修改技术"><a href="#字节码修改技术" class="headerlink" title="字节码修改技术"></a>字节码修改技术</h2><p>对Java Class字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。</p><p>那通过了解字节码，我们可以做些什么呢？</p><p>其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节。</p><p>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</p><p>目前字节码修改技术有ASM，javassist，cglib，BCEL等。cglib就是基于封装的Asm. Spring 就是使用cglib代理库。关于cglib的使用介绍，可以参考：<a href="https://link.jianshu.com/?t=http://blog.csdn.net/zghwaicsdn/article/details/50957474">CGLIB介绍与原理</a></p><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p><p>作者：Windy_816<br>链接：<a href="https://www.jianshu.com/p/247e2475fc3a">https://www.jianshu.com/p/247e2475fc3a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>3.反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理基础</title>
    <link href="/2022/01/06/Core/Java/2.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/06/Core/Java/2.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight php"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">String</span> s = processFile(“C:\\test.txt”);<br>    <span class="hljs-comment">// ok:</span><br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    <span class="hljs-comment">// file not found:</span><br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>    <span class="hljs-comment">// no read permission:</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-comment">// io error:</span><br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e) &#123;<br>    <span class="hljs-comment">// other error:</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为Java的异常是<code>class</code>，它的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                     ┌───────────┐<br>                     │  Object   │<br>                     └───────────┘<br>                           ▲<br>                           │<br>                     ┌───────────┐<br>                     │ Throwable │<br>                     └───────────┘<br>                           ▲<br>                 ┌─────────┴─────────┐<br>                 │                   │<br>           ┌───────────┐       ┌───────────┐<br>           │   Error   │       │ Exception │<br>           └───────────┘       └───────────┘<br>                 ▲                   ▲<br>         ┌───────┘              ┌────┴──────────┐<br>         │                      │               │<br>┌─────────────────┐    ┌─────────────────┐┌───────────┐<br>│OutOfMemoryError │... │RuntimeException ││IOException│...<br>└─────────────────┘    └─────────────────┘└───────────┘<br>                                ▲<br>                    ┌───────────┴─────────────┐<br>                    │                         │<br>         ┌─────────────────────┐ ┌─────────────────────────┐<br>         │NullPointerException │ │IllegalArgumentException │...<br>         └─────────────────────┘ └─────────────────────────┘<br></code></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code>又分为两大类：</p><ol><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p>Java规定：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><p> 注意：编译器对RuntimeException及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p><p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p><p>要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p><p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>还有一些童鞋喜欢在<code>toGBK()</code>内部“消化”异常：</p><p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p><p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p><p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p><p>不推荐捕获了异常但不进行任何处理。</p><h1 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h1><h3 id="多catch语句"><a href="#多catch语句" class="headerlink" title="多catch语句"></a>多catch语句</h3><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。**(即多个catch只有一个能执行,因此子类异常应该写前面)**</p><h3 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h3><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p><p>可以try和catch都写执行代码,也可以用<code>finally</code></p><p>注意<code>finally</code>有几个特点：</p><ol><li><code>finally</code>语句不是必须的，可写可不写；</li><li><code>finally</code>总是最后执行。</li></ol><p>可以把执行语句写若干遍：正常执行的放到<code>try</code>中，每个<code>catch</code>再写一遍。例如：</p><h3 id="捕获多种异常"><a href="#捕获多种异常" class="headerlink" title="捕获多种异常"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条<code>catch</code>子句</p><h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><h3 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止：</p><p>通过<code>printStackTrace()</code>可以打印出方法的<code>调用栈</code>，类似：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">java.lang.NumberFormatException: null<br>    at java.base/java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(Integer.<span class="hljs-params">java</span>:614)</span><br>    at java.base/java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(Integer.<span class="hljs-params">java</span>:770)</span><br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>process2(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">16</span>)<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>process1(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">12</span>)<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code>main()</code>调用<code>process1()</code>；</li><li><code>process1()</code>调用<code>process2()</code>；</li><li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li><li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code>。</li></ol><p>查看<code>Integer.java</code>源码可知，抛出异常的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> radix)</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>并且，每层调用均给出了源代码的行号，可直接定位。</p><h3 id="抛出异常-1"><a href="#抛出异常-1" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p><p>如何抛出异常？参考<code>Integer.parseInt()</code>方法，抛出异常分两步：</p><ol><li>创建某个<code>Exception</code>的实例；</li><li>用<code>throw</code>语句抛出。</li></ol><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">process2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s==<span class="hljs-literal">null</span>) &#123;<br>        NullPointerException e = <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">process2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">process1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        process2();<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">process2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>process2()</code>抛出<code>NullPointerException</code>后，被<code>process1()</code>捕获，然后抛出<code>IllegalArgumentException()</code>。</p><p>如果在<code>main()</code>中捕获<code>IllegalArgumentException</code>，我们看看打印的异常栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// exception</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process1();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process2();<br>        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">java.lang.IllegalArgumentException<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>process1(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">15</span>)<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常<code>NullPointerException</code>的信息了。</p><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// exception</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process1();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process2();<br>        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e);<br>            <span class="hljs-comment">//注意这里把原始异常的实例e传进去了</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">java.lang.IllegalArgumentException: java.lang.NullPointerException<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>process1(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">15</span>)<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">5</span>)<br>Caused by: java.lang.NullPointerException<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>process2(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">20</span>)<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>process1(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><p>注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的。</p><p><strong>在代码中拿到异常后可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了。</strong></p><p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。</p><p><strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场!</strong></p><p>如果我们在<code>try</code>或者<code>catch</code>语句块中抛出异常，<code>finally</code>语句是否会执行？<strong>会</strong>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// exception</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Integer.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (Exception e) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;catched&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(e);<br>        &#125; finally &#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码执行结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">catched<br>finally<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NumberFormatException</span>: For <span class="hljs-selector-tag">input</span> string: <span class="hljs-string">&quot;abc&quot;</span><br>    at Main<span class="hljs-selector-class">.main</span>(Main<span class="hljs-selector-class">.java</span>:<span class="hljs-number">8</span>)<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NumberFormatException</span>: For <span class="hljs-selector-tag">input</span> string: <span class="hljs-string">&quot;abc&quot;</span><br>    at ...<br></code></pre></td></tr></table></figure><p>第一行打印了<code>catched</code>，说明进入了<code>catch</code>语句块。第二行打印了<code>finally</code>，说明执行了<code>finally</code>语句块。</p><p>因此，在<code>catch</code>中抛出异常，不会影响<code>finally</code>的执行。JVM会先执行<code>finally</code>，然后抛出异常。</p><h3 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h3><p>如果在执行<code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// exception</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Integer.parseInt(<span class="hljs-string">&quot;abc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;catched&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">catched<br>finally<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><p>这说明<code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p><p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用<code>origin</code>变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code>finally</code>抛出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// exception</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) throws <span class="hljs-built_in">Exception</span> &#123;<br>        <span class="hljs-built_in">Exception</span> origin = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-keyword">Integer</span>.parseInt(<span class="hljs-string">&quot;abc&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e) &#123;<br>            origin = e;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">Exception</span> e = <span class="hljs-keyword">new</span> IllegalArgumentException();<br>            <span class="hljs-keyword">if</span> (origin != <span class="hljs-literal">null</span>) &#123;<br>                e.addSuppressed(origin);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>catch</code>和<code>finally</code>都抛出了异常时，虽然<code>catch</code>的异常被屏蔽了，但是，<code>finally</code>抛出的异常仍然包含了它：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException<br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">11</span>)<br>Suppressed: java.lang.NumberFormatException: For input <span class="hljs-built_in">string</span>: <span class="hljs-string">&quot;abc&quot;</span><br>    at java.base/java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NumberFormatException</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">InputString(NumberFormatException.<span class="hljs-params">java</span>:65)</span><br>    at java.base/java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(Integer.<span class="hljs-params">java</span>:652)</span><br>    at java.base/java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(Integer.<span class="hljs-params">java</span>:770)</span><br>    at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>通过<code>Throwable.getSuppressed()</code>可以获取所有的<code>Suppressed Exception</code>。</p><p>绝大多数情况下，在<code>finally</code>中不要抛出异常。因此，我们通常不需要关心<code>Suppressed Exception</code>。</p><h1 id="自定义异常-重要"><a href="#自定义异常-重要" class="headerlink" title="自定义异常(重要)"></a>自定义异常(重要)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ascii">Exception<br>│<br>├─ RuntimeException //运行时异常<br>│  │<br>│  ├─ NullPointerException //空指针<br>│  │<br>│  ├─ IndexOutOfBoundsException //数据月结<br>│  │<br>│  ├─ SecurityException // 安全异常<br>│  │<br>│  └─ IllegalArgumentException //非法参数<br>│     │<br>│     └─ NumberFormatException //数字格式转换异常<br>│ <br>├─ IOException<br>│  │<br>│  ├─ UnsupportedCharsetException<br>│  │<br>│  ├─ FileNotFoundException<br>│  │<br>│  └─ SocketException<br>│<br>├─ ParseException<br>│<br>├─ GeneralSecurityException<br>│<br>├─ SQLException<br>│<br>└─ TimeoutException<br></code></pre></td></tr></table></figure><p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出<code>IllegalArgumentException</code>：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (age &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseException</span> </span>&#123;<br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFailedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseException</span> </span>&#123;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure><p>自定义的<code>BaseException</code>应该提供多个构造方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">BaseException</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">BaseException</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message, Throwable cause</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">BaseException</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">BaseException</span>(<span class="hljs-params">Throwable cause</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h1 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h1><p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由JVM抛出的</p><p>如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Optional&lt;String&gt; read<span class="hljs-constructor">FromFile(String <span class="hljs-params">file</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!file<span class="hljs-constructor">Exist(<span class="hljs-params">file</span>)</span>) &#123;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<span class="hljs-literal">()</span>;<br>    &#125;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>这样调用方必须通过<code>Optional.isPresent()</code>判断是否有结果。</p><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p><p>我们先看一个例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> x = Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">-123.45</span>);<br>    assert x &gt;= <span class="hljs-number">0</span>;<br>    System.out.<span class="hljs-built_in">println</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p><p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">assert</span> x &gt;= <span class="hljs-number">0</span> : <span class="hljs-string">&quot;x must &gt;= 0&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p><p>Java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> arr != <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;array cannot be null&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们在程序中使用<code>assert</code>时，例如，一个简单的断言：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// assert</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">-1</span>;<br>        assert x &gt; <span class="hljs-number">0</span>;<br>        System.out.<span class="hljs-built_in">println</span>(x);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>断言<code>x</code>必须大于<code>0</code>，实际上<code>x</code>为<code>-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出<code>AssertionError</code>，而是正常打印了<code>x</code>的值。</p><p>这是怎么肥四？为什么<code>assert</code>语句不起作用？</p><p><strong>这是因为JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</strong></p><p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">$ java -ea <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.AssertionError<br>at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对<code>com.itranswarp.sample.Main</code>这个类启用断言。</p><p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个<code>.</code>），表示对<code>com.itranswarp.sample</code>这个包启动断言。</p><p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解<code>JUnit</code>的使用。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>断言是一种调试方式，断言失败会抛出<code>AssertionError</code>，只能在开发和测试阶段启用断言；</p><p>对可恢复的错误不能使用断言，而应该抛出异常；</p><p>断言很少被使用，更好的方法是编写单元测试。</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是日志？日志就是Logging，它的目的是为了取代<code>System.out.println()</code>。</p><p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li><li>可以按包名控制日志级别，只输出某些包打的日志；</li><li>可以……</li></ol><p>总之就是好处很多啦。</p><p>那如何使用日志？</p><p>因为Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p><h3 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// logging</span><br><span class="hljs-keyword">import</span> java.util.logging.Level;<br><span class="hljs-keyword">import</span> java.util.logging.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = Logger.getGlobal();<br>        logger.info(<span class="hljs-string">&quot;start process...&quot;</span>);<br>        logger.warning(<span class="hljs-string">&quot;memory is running out...&quot;</span>);<br>        logger.fine(<span class="hljs-string">&quot;ignored.&quot;</span>);<br>        logger.severe(<span class="hljs-string">&quot;process will be terminated...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mar</span> <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br><span class="hljs-attribute">INFO</span>: start process...<br><span class="hljs-attribute">Mar</span> <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br><span class="hljs-attribute">WARNING</span>: memory is running out...<br><span class="hljs-attribute">Mar</span> <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br><span class="hljs-attribute">SEVERE</span>: process will be terminated...<br></code></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p><p>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从<strong>严重到普通</strong>：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><p>使用Java标准库内置的Logging有以下局限：</p><p>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p><p>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p><p>因此，Java标准库内置的Logging使用并不是非常广泛。</p><h3 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h3><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p><p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； 第二步，使用<code>Log</code>实例的方法打日志。</p><p>示例代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> org.apache.commons.logging.<span class="hljs-keyword">Log</span>;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Main &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">Log</span> <span class="hljs-keyword">log</span> = LogFactory.getLog(Main.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(&quot;start...&quot;);<br>        <span class="hljs-keyword">log</span>.warn(&quot;end.&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述代码，肯定会得到编译错误，类似<code>error: package org.apache.commons.logging does not exist</code>（找不到<code>org.apache.commons.logging</code>这个包）。因为Commons Logging是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来。下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下，例如<code>work</code>目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ascii">work<br>│<br>├─ commons-logging-1.2.jar<br>│<br>└─ Main.java<br></code></pre></td></tr></table></figure><p>然后用<code>javac</code>编译<code>Main.java</code>，编译的时候要指定<code>classpath</code>，不然编译器找不到我们引用的<code>org.apache.commons.logging</code>包。编译命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">javac</span> -cp commons-logging-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.jar Main.java<br></code></pre></td></tr></table></figure><p>如果编译成功，那么当前目录下就会多出一个<code>Main.class</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ascii">work<br>│<br>├─ commons-logging-1.2.jar<br>│<br>├─ Main.java<br>│<br>└─ Main.class<br></code></pre></td></tr></table></figure><p>现在可以执行这个<code>Main.class</code>，使用<code>java</code>命令，也必须指定<code>classpath</code>，命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -cp .;commons-logging-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.jar Main<br></code></pre></td></tr></table></figure><p>注意到传入的<code>classpath</code>有两部分：一个是<code>.</code>，一个是<code>commons-logging-1.2.jar</code>，用<code>;</code>分割。<code>.</code>表示当前目录，如果没有这个<code>.</code>，JVM不会在当前目录搜索<code>Main.class</code>，就会报错。</p><p>如果在Linux或macOS下运行，注意<code>classpath</code>的分隔符不是<code>;</code>，而是<code>:</code>：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">java -cp .<span class="hljs-symbol">:commons-logging-</span><span class="hljs-number">1.2</span>.jar Main<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mar</span> <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">7</span>:<span class="hljs-number">15</span>:<span class="hljs-number">31</span> PM Main main<br><span class="hljs-attribute">INFO</span>: start...<br><span class="hljs-attribute">Mar</span> <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">7</span>:<span class="hljs-number">15</span>:<span class="hljs-number">31</span> PM Main main<br><span class="hljs-attribute">WARNING</span>: end.<br></code></pre></td></tr></table></figure><p>Commons Logging定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是<code>INFO</code>。</p><p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在静态方法中引用Log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Log log = LogFactory.<span class="hljs-built_in">getLog</span>(Main.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在实例方法中引用Log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Log log = LogFactory.<span class="hljs-built_in">getLog</span>(<span class="hljs-built_in">getClass</span>());<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到实例变量log的获取方式是<code>LogFactory.getLog(getClass())</code>，虽然也可以用<code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该<code>log</code>实例。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 在子类中使用父类实例化的log:</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    void bar() &#123;<br>        log.info(<span class="hljs-string">&quot;bar&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Java类的动态特性，子类获取的<code>log</code>字段实际上相当于<code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><p>此外，Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;got exception!&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p><p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">log.info(&quot;User signed in.&quot;);<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │<br> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │<br> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │<br>     └──────────┘    └──────────┘    └──────────┘    └──────────┘<br></code></pre></td></tr></table></figure><p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库</li></ul><p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</p><p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p><p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d</span><span class="hljs-template-variable">&#123;MM-dd HH:mm:ss.SSS&#125;</span><span class="xml"> [%t] %-5level %logger</span><span class="hljs-template-variable">&#123;36&#125;</span><span class="xml">%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;log.pattern&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;file.err.filename&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;file.err.pattern&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;log.pattern&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="xml">                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p><p>有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p><p>要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">03</span>-<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">09</span>:<span class="hljs-number">45</span>.<span class="hljs-number">880</span><span class="hljs-meta"> [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="hljs-meta">Start process...</span><br></code></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p><h3 id="SLF4J-占位符-和Logback"><a href="#SLF4J-占位符-和Logback" class="headerlink" title="SLF4J(占位符)和Logback"></a>SLF4J(占位符)和Logback</h3><p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p><p>有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？</p><p>其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p><p>为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p><p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p><p>我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> score = <span class="hljs-number">99</span>;<br>p.set<span class="hljs-constructor">Score(<span class="hljs-params">score</span>)</span>;<br>log.info(<span class="hljs-string">&quot;Set score &quot;</span> + score + <span class="hljs-string">&quot; for Person &quot;</span> + p.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; ok.&quot;</span>);<br></code></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> score = <span class="hljs-number">99</span>;<br>p.set<span class="hljs-constructor">Score(<span class="hljs-params">score</span>)</span>;<br>logger.info(<span class="hljs-string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.get<span class="hljs-constructor">Name()</span>);<br></code></pre></td></tr></table></figure><p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Main</span> &#123;<br>    <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>对比一下Commons Logging和SLF4J的接口：</p><table><thead><tr><th align="left">Commons Logging</th><th align="left">SLF4J</th></tr></thead><tbody><tr><td align="left">org.apache.commons.logging.Log</td><td align="left">org.slf4j.Logger</td></tr><tr><td align="left">org.apache.commons.logging.LogFactory</td><td align="left">org.slf4j.LoggerFactory</td></tr></tbody></table><p>不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory。</p><p>使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载<a href="https://www.slf4j.org/download.html">SLF4J</a>和<a href="https://logback.qos.ch/download.html">Logback</a>，然后把以下jar包放到classpath下：</p><ul><li>slf4j-api-1.7.x.jar</li><li>logback-classic-1.2.x.jar</li><li>logback-core-1.2.x.jar</li></ul><p>然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，把<code>logback.xml</code>放到classpath下，配置如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d</span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="xml"> [%thread] %-5level %logger</span><span class="hljs-template-variable">&#123;36&#125;</span><span class="xml"> - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d</span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="xml"> [%thread] %-5level %logger</span><span class="hljs-template-variable">&#123;36&#125;</span><span class="xml"> - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>log/output.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>1MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>运行即可获得类似如下的输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">13</span>:<span class="hljs-number">15</span>:<span class="hljs-number">25.328</span> <span class="hljs-selector-attr">[main]</span> INFO  com<span class="hljs-selector-class">.itranswarp</span><span class="hljs-selector-class">.learnjava</span><span class="hljs-selector-class">.Main</span> - Start process...<br></code></pre></td></tr></table></figure><p>从目前的趋势来看，越来越多的开源项目从Commons Logging加Log4j转向了SLF4J加Logback。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>2.异常处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型基础</title>
    <link href="/2022/01/06/Core/Java/5.%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/06/Core/Java/5.%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>泛型是一种“代码模板”，可以用一套代码套用各种类型</strong>。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1290121955508289/l" alt="java-generics"></p><p>本节我们详细讨论Java的泛型编程。</p><h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><p>在讲解什么是泛型之前，我们先观察Java标准库提供的<code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上<code>ArrayList</code>内部就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight nim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">ArrayList</span> &#123;<br>    private <span class="hljs-type">Object</span>[] <span class="hljs-built_in">array</span>;<br>    private <span class="hljs-built_in">int</span> size;<br>    public <span class="hljs-built_in">void</span> add(<span class="hljs-type">Object</span> e) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-built_in">void</span> remove(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-type">Object</span> get(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果用上述<code>ArrayList</code>存储<code>String</code>类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ArrayList list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// 获取到Object，必须强制转型为String:</span><br><span class="hljs-keyword">String</span> first = (<span class="hljs-keyword">String</span>) list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>很容易出现ClassCastException，因为容易“误转型”：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">list.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// ERROR: ClassCastException:</span><br><span class="hljs-keyword">String</span> <span class="hljs-built_in">second</span> = (<span class="hljs-keyword">String</span>) list.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>要解决上述问题，我们可以为<code>String</code>单独编写一种<code>ArrayList</code>：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">StringArrayList</span> &#123;<br>    private <span class="hljs-type">String</span>[] <span class="hljs-built_in">array</span>;<br>    private <span class="hljs-built_in">int</span> size;<br>    public <span class="hljs-built_in">void</span> add(<span class="hljs-type">String</span> e) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-built_in">void</span> remove(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-type">String</span> get(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，存入的必须是<code>String</code>，取出的也一定是<code>String</code>，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">StringArrayList list = <span class="hljs-keyword">new</span> <span class="hljs-type">StringArrayList</span>();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">String</span> first = list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 编译错误: 不允许放入非String类型:</span><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>));<br></code></pre></td></tr></table></figure><p>问题暂时解决。</p><p>然而，新的问题是，如果要存储<code>Integer</code>，还需要为<code>Integer</code>单独编写一种<code>ArrayList</code>：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">IntegerArrayList</span> &#123;<br>    private <span class="hljs-type">Integer</span>[] <span class="hljs-built_in">array</span>;<br>    private <span class="hljs-built_in">int</span> size;<br>    public <span class="hljs-built_in">void</span> add(<span class="hljs-type">Integer</span> e) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-built_in">void</span> remove(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-type">Integer</span> get(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，还需要为其他所有class单独编写一种<code>ArrayList</code>：</p><ul><li>LongArrayList</li><li>DoubleArrayList</li><li>PersonArrayList</li><li>…</li></ul><p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p><p>为了解决新的问题，我们必须把<code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">ArrayList</span>&lt;T&gt; &#123;<br>    private T[] <span class="hljs-built_in">array</span>;<br>    private <span class="hljs-built_in">int</span> size;<br>    public <span class="hljs-built_in">void</span> add(T e) <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-built_in">void</span> remove(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>    public T get(<span class="hljs-built_in">int</span> index) <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>T</code>可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建可以存储String的ArrayList:</span><br>ArrayList&lt;<span class="hljs-keyword">String</span>&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br><span class="hljs-comment">// 创建可以存储Float的ArrayList:</span><br>ArrayList&lt;<span class="hljs-keyword">Float</span>&gt; floatList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">Float</span>&gt;();<br><span class="hljs-comment">// 创建可以存储Person的ArrayList:</span><br>ArrayList&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;Person&gt;();<br></code></pre></td></tr></table></figure><p>因此，泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ArrayList&lt;<span class="hljs-keyword">String</span>&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br></code></pre></td></tr></table></figure><p>由编译器针对类型作检查：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing">strList.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">String</span> s = strList.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK</span><br>strList.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>)); <span class="hljs-comment">// compile error!</span><br>Integer n = strList.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>这样一来，既实现了<strong>编写一次，万能匹配</strong>，又<strong>通过编译器保证了类型安全</strong>：这就是泛型。</p><h3 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h3><p><strong>1.编写一次，万能匹配</strong></p><p><strong>2.通过编译器保证了类型安全</strong></p><h3 id="向上转型-集合的泛型类型不能转为父类型-因为那样可以添加其他的子类-违背了泛型使用规则"><a href="#向上转型-集合的泛型类型不能转为父类型-因为那样可以添加其他的子类-违背了泛型使用规则" class="headerlink" title="向上转型(集合的泛型类型不能转为父类型,因为那样可以添加其他的子类,违背了泛型使用规则)"></a>向上转型(集合的泛型类型不能转为父类型,因为那样可以添加其他的子类,违背了泛型使用规则)</h3><p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">List</span></span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    ...<br>&#125;<br><br>List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br></code></pre></td></tr></table></figure><p>即类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>。</p><p>要<em>特别注意</em>：<strong>不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>(集合)。</strong></p><p>这是为什么呢？假设<code>ArrayList&lt;Integer&gt;</code>可以向上转型为<code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建ArrayList&lt;Integer&gt;类型：</span><br>ArrayList&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-comment">// 添加一个Integer：</span><br>integerList.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// “向上转型”为ArrayList&lt;Number&gt;：</span><br>ArrayList&lt;Number&gt; numberList = integerList;<br><span class="hljs-comment">// 添加一个Float，因为Float也是Number：</span><br>numberList.add(<span class="hljs-keyword">new</span> Float(<span class="hljs-number">12.34</span>));<br><span class="hljs-comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span><br>Integer n = integerList.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// ClassCastException!</span><br></code></pre></td></tr></table></figure><p>我们把一个<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>类型后，这个<code>ArrayList&lt;Number&gt;</code>就可以接受<code>Float</code>类型，因为<code>Float</code>是<code>Number</code>的子类。但是，<code>ArrayList&lt;Number&gt;</code>实际上和<code>ArrayList&lt;Integer&gt;</code>是同一个对象，也就是<code>ArrayList&lt;Integer&gt;</code>类型，它不可能接受<code>Float</code>类型， 所以在获取<code>Integer</code>的时候将产生<code>ClassCastException</code>。</p><p>实际上，编译器为了避免这种错误，根本就不允许把<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>。</p><p><strong>ArrayList<Integer>和ArrayList<Number>两者没有继承关系。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>泛型就是编写模板代码来适应任意类型；</p><p><strong>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</strong></p><p>注意泛型的继承关系：可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（<code>T</code>不能变！），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变成父类）。</p><h1 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h1><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code>：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 编译器警告:</span><br>List list = <span class="hljs-keyword">new</span> ArrayList();<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">String</span> first = (<span class="hljs-keyword">String</span>) list.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">second</span> = (<span class="hljs-keyword">String</span>) list.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 无编译器警告:</span><br>List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 无强制转型:</span><br><span class="hljs-keyword">String</span> first = list.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">second</span> = list.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>当我们定义泛型类型<code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;Number&gt;</code>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;Number&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;Number&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>));<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Double</span>(<span class="hljs-number">12.34</span>));<br>Number first = list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>Number second = list.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">List&lt;<span class="hljs-built_in">Number</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">Number</span>&gt;();<br></code></pre></td></tr></table></figure><p>**编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>**，因此，可以把代码简写为：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span><br>List&lt;<span class="hljs-built_in">Number</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">int</span> compareTo(T o);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接对<code>String</code>数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] ss = <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span> &#125;;<br>        Arrays.sort(ss);<br>        System.out.println(Arrays.toString(ss));<span class="hljs-comment">//[Apple, Orange, Pear]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为<code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的<code>Person</code>类型试试：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>            Person[] ps = <span class="hljs-keyword">new</span> Person[] &#123;<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">61</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">75</span>),<br>        &#125;;<br>        Arrays.sort(ps);<br>        System.out.println(Arrays.toString(ps));<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-built_in">String</span> name;<br>    int score;<br>    <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, int score</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，我们会得到<code>ClassCastException</code>，即无法将<code>Person</code>转型为<code>Comparable</code>。我们修改代码，让<code>Person</code>实现<code>Comparable&lt;T&gt;</code>接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Person[] ps = <span class="hljs-keyword">new</span> Person[] &#123;<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">61</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">75</span>),<br>        &#125;;<br>        Arrays.sort(ps);<br>        System.out.println(Arrays.toString(ps)); <span class="hljs-comment">// [Alice,88, Bob,61, Lily,75]</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-title">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt; </span>&#123;<br>    <span class="hljs-built_in">String</span> name;<br>    int score;<br>    <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, int score</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">compareTo</span>(<span class="hljs-params">Person other</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按<code>name</code>进行排序。</p><p>也可以修改比较逻辑，例如，按<code>score</code>从高到低排序。请自行修改测试。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>使用泛型时，把泛型参数<code>&lt;T&gt;</code>替换为需要的class类型，例如：<code>ArrayList&lt;String&gt;</code>，<code>ArrayList&lt;Number&gt;</code>等；</p><p>可以省略编译器能自动推断出的类型，例如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>；</p><p>不指定泛型参数类型时，编译器会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>Object</code>类型；</p><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p><h1 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h1><h3 id="如何编写泛型类"><a href="#如何编写泛型类" class="headerlink" title="如何编写泛型类"></a>如何编写泛型类</h3><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如<code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> first;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> first, <span class="hljs-built_in">String</span> last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是<code>String</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> first;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> first, <span class="hljs-built_in">String</span> last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>熟练后即可直接从<code>T</code>开始编写。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>无法在静态方法<code>create()</code>的方法参数和返回类型上使用泛型类型T</strong></p><p><strong>原因</strong>:这实际上和类型泛型擦除有关</p><p><strong>因为普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的<T>的具体类型了；</strong></p><p>而<strong>静态方法不需要对象实例来调用，所以也就不知道<T>的具体类型，虚拟机不允许这种情况发生，所以编译的时候就报错了。</strong></p><p><strong>静态方法由于随着类的加载而加载，不能访问类的泛型（因为在创建对象的时候才确定），因此必须定义自己的泛型类型。</strong></p><p>用个老师的例子：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt; p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);  <span class="hljs-comment">//创建实例时已经知道&lt;T&gt;是String类型</span><br><span class="hljs-built_in">String</span> first = p.getFirst();  <br><span class="hljs-built_in">Pair</span>.create(<span class="hljs-params">...</span>);  <span class="hljs-comment">//如果是静态方法，则并不清楚&lt;T&gt;的具体类型</span><br></code></pre></td></tr></table></figure><p><K>放在static后面，你可以理解为既然静态方法不知道Pair里面的具体类型，你就手动的告诉它具体的类型。</p><p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法(因为泛型)。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 对静态方法使用&lt;T&gt;:</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们<strong>无法在静态方法<code>create()</code>的方法参数和返回类型上使用泛型类型<code>T</code>。</strong></p><p>有些同学在网上搜索发现，可以在<code>static</code>修饰符后面加一个<code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 可以编译通过:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上，<strong>这个<code>&lt;T&gt;</code>和<code>Pair&lt;T&gt;</code>类型(实例对象中的T?)的<code>&lt;T&gt;</code>已经没有任何关系了。</strong></p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; <span class="hljs-function">Pair&lt;K&gt; <span class="hljs-title">create</span><span class="hljs-params">(K first, K last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样才能<strong>清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</strong></p><h3 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> K last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, K last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>编写泛型时，需要定义泛型类型<code>&lt;T&gt;</code>；</p><p>静态方法不能引用泛型类型<code>&lt;T&gt;</code>，必须定义其他类型（例如<code>&lt;K&gt;</code>）来实现静态泛型方法；</p><p>泛型可以同时定义多种类型，例如<code>Map&lt;K, V&gt;</code>。</p><h1 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h1><h3 id="由编译器完成擦拭"><a href="#由编译器完成擦拭" class="headerlink" title="由编译器完成擦拭"></a>由编译器完成擦拭</h3><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p><strong>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</strong></p><p>例如，我们编写了一个泛型类<code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码(擦拭成父类,一般对象的父类即Object)：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span> first;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span> last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> first, <span class="hljs-built_in">Object</span> last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li><li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt; p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-built_in">String</span> first = p.getFirst();<br><span class="hljs-built_in">String</span> last = p.getLast();<br></code></pre></td></tr></table></figure><p>而<strong>虚拟机执行的代码并没有泛型</strong>：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span> p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-built_in">String</span> first = (<span class="hljs-built_in">String</span>) p.getFirst();<br><span class="hljs-built_in">String</span> last = (<span class="hljs-built_in">String</span>) p.getLast();<br></code></pre></td></tr></table></figure><p>所以，<strong>Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型</strong>。</p><h4 id="泛型的局限"><a href="#泛型的局限" class="headerlink" title="泛型的局限"></a>泛型的局限</h4><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;int&gt; p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>局限二：无法取得带泛型的<code>Class</code>。观察以下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Pair&lt;<span class="hljs-built_in">String</span>&gt; p1 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        Class c1 = p1.getClass();<br>        Class c2 = p2.getClass();<br>        System.out.println(c1==c2); <span class="hljs-comment">// true</span><br>        System.out.println(c1==Pair.class); <span class="hljs-comment">// true</span><br>           &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为<code>T</code>是<code>Object</code>，我们对<code>Pair&lt;String&gt;</code>和<code>Pair&lt;Integer&gt;</code>类型获取<code>Class</code>时，获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p><p>换句话说，<strong>所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</strong></p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">Integer</span>&gt; p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br><span class="hljs-comment">// Compile error:</span><br><span class="hljs-keyword">if</span> (p instanceof <span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt;) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p><p>局限四：不能实例化<code>T</code>类型：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> Pair() &#123;<br>        <span class="hljs-comment">// Compile error:</span><br>        first = <span class="hljs-keyword">new</span> <span class="hljs-type">T</span>();<br>        last = <span class="hljs-keyword">new</span> <span class="hljs-type">T</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">first</span> = new T()<span class="hljs-comment">;</span><br><span class="hljs-attr">last</span> = new T()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">first</span> = new Object()<span class="hljs-comment">;</span><br><span class="hljs-attr">last</span> = new Object()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p><p><strong>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">**<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        first = clazz.newInstance();<br>        last = clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt; pair = <span class="hljs-keyword">new</span> Pair&lt;&gt;(String.class);<br></code></pre></td></tr></table></figure><p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p><h3 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Pair</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean equals(T t) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，<strong>编译器会阻止一个实际上会变成覆写的泛型方法定义(覆写equals(Object t))。</strong></p><p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Pair</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean same(T t) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，<strong>因为子类<code>IntPair</code>并没有泛型类型</strong>，所以，正常使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntPair ip = <span class="hljs-keyword">new</span> IntPair(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="获取父类泛型的方法"><a href="#获取父类泛型的方法" class="headerlink" title="获取父类泛型的方法"></a>获取父类泛型的方法</h4><p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>           Class&lt;IntPair&gt; clazz = IntPair.class;<br>        <span class="hljs-comment">//获取父类type</span><br>        Type t = clazz.getGenericSuperclass();<br>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            ParameterizedType pt = (ParameterizedType) t;<br>            Type[] types = pt.getActualTypeArguments(); <span class="hljs-comment">// 可能有多个泛型类型</span><br>            Type firstType = types[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 取第一个泛型类型</span><br>            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;<br>            System.out.println(typeClass); <span class="hljs-comment">// Integer</span><br>        &#125;<br>          &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntPair</span><span class="hljs-params">(Integer first, Integer last)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Java引入了泛型，所以，只用<code>Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                      ┌────┐<br>                      │Type│<br>                      └────┘<br>                         ▲<br>                         │<br>   ┌────────────┬────────┴─────────┬───────────────┐<br>   │            │                  │               │<br>┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐<br>│Class││ParameterizedType││GenericArrayType││WildcardType│<br>└─────┘└─────────────────┘└────────────────┘└────────────┘<br></code></pre></td></tr></table></figure><p>Type 的子接口</p><p><img src="%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80.assets/image-20211219014454545.png" alt="image-20211219014454545"></p><h3 id="Java-中的所有类型"><a href="#Java-中的所有类型" class="headerlink" title="Java 中的所有类型"></a>Java 中的所有类型</h3><ul><li>raw type：原始类型，对应<code>Class</code><ul><li>即我们通常说的引用类型，包括普通的类，例如 <code>String.class</code>、<code>List.class</code></li><li>也包括数组(<code>Array.class</code>)、接口(<code>Cloneable.class</code>)、注解(<code>Annotation.class</code>)、枚举(<code>Enum.class</code>)等</li></ul></li><li>primitive types：基本类型，对应<code>Class</code><ul><li>包括 <code>Built-in</code> 内置类型，例如 <code>int.class</code>、<code>char.class</code>、<code>void.class</code></li><li>也包括 <code>Wrappers</code> 内置类型包装类型，例如 <code>Integer.class</code>、<code>Boolean.class</code>、<code>Void.class</code></li></ul></li><li>parameterized types：参数化类型，对应<code>ParameterizedType</code><strong>(即List<T>)</strong><ul><li>带有类型参数的类型，即常说的泛型，例如 <code>List&lt;T&gt;</code>、<code>Map&lt;Integer, String&gt;</code>、<code>List&lt;? extends Number&gt;</code></li><li>实现类 <code>sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</code></li></ul></li><li>type variables：类型变量类型，对应<code>TypeVariable&lt;D&gt;</code>（类型变量）<strong>即<code>List&lt;T&gt;</code>中的T</strong><ul><li>即参数化类型 ParameterizedType 中的 E、K 等类型变量，表示泛指任何类</li><li>实现类 <code>sun.reflect.generics.reflectiveObjects.TypeVariableImpl</code></li></ul></li><li>array types：泛型数组类型，对应<code>GenericArrayType</code><ul><li>元素类型是参数化类型或者类型变量的泛型数组类型，例如 <code>T[]</code></li><li>实现类 <code>sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl</code></li></ul></li></ul><p>Type 接口的另一个子接口 <code>WildcardType</code> 代表<code>通配符表达式类型</code>，或<code>泛型表达式类型</code>，比如<code>?</code>、<code>? super T</code>、<code>? extends T</code>，他并不是 Java 类型中的一种。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>Java的泛型是采用擦拭法实现的；</p><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p><p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p><h1 id="extends通配符-子类或实现类"><a href="#extends通配符-子类或实现类" class="headerlink" title="extends通配符(子类或实现类)"></a>extends通配符(子类或实现类)</h1><h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p>我们前面已经讲到了泛型的继承关系：**<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。**</p><p>假设我们定义了<code>Pair&lt;T&gt;</code>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Pair</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>然后，我们又针对<code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PairHelper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;Number&gt; p)</span> </span>&#123;<br>        Number first = p.getFirst();<br>        Number last = p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sum = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PairHelper</span>.</span></span>add(<span class="hljs-keyword">new</span> Pair&lt;Number&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>注意：传入的类型是<code>Pair&lt;Number&gt;</code>，实际参数类型是<code>(Integer, Integer)</code>。</p><p>既然实际参数是<code>Integer</code>类型，试试传入<code>Pair&lt;Integer&gt;</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        int n = add(p);<br>        System.out.println(n);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> int <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">Pair&lt;<span class="hljs-built_in">Number</span>&gt; p</span>)</span> &#123;<br>        <span class="hljs-built_in">Number</span> first = p.getFirst();<br>        <span class="hljs-built_in">Number</span> last = p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br> &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接运行，会得到一个编译错误：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">incompatible <span class="hljs-built_in">type</span><span class="hljs-variable">s:</span> Pair<span class="hljs-symbol">&lt;Integer&gt;</span> cannot <span class="hljs-keyword">be</span> converted <span class="hljs-keyword">to</span> Pair<span class="hljs-symbol">&lt;Number&gt;</span><br></code></pre></td></tr></table></figure><p>原因很明显，因为<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类，因此，<code>add(Pair&lt;Number&gt;)</code>不接受参数类型<code>Pair&lt;Integer&gt;</code>。</p><p>但是从<code>add()</code>方法的代码可知，传入<code>Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Number</span> first = p.getFirst();<br><span class="hljs-attribute">Number</span> <span class="hljs-literal">last</span> = p.getLast();<br></code></pre></td></tr></table></figure><p>实际类型是<code>Integer</code>，引用类型是<code>Number</code>，没有问题。问题在于方法参数类型定死了只能传入<code>Pair&lt;Number&gt;</code>。</p><p>有没有办法使得方法参数接受<code>Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。我们把代码改写如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        int n = add(p);<br>        System.out.println(n);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> int <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">Pair&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Number</span>&gt; p</span>)</span> &#123;<br>        <span class="hljs-built_in">Number</span> first = p.getFirst();<br>        <span class="hljs-built_in">Number</span> last = p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T last</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">getLast</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，给方法传入<code>Pair&lt;Integer&gt;</code>类型时，它符合参数<code>Pair&lt;? extends Number&gt;</code>类型。这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为<strong>上界通配符（Upper Bounds Wildcards）</strong>，即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p><p>除了可以传入<code>Pair&lt;Integer&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类(<strong>实现类也行?</strong>)。</p><blockquote><p>Java是单根继承，只能继承一个class：</p><p>class A extends B implements C, D, E, F</p><p>如果写</p><p>class A extends B, C, D, E, F</p><p>你说可不可以呢？完全可以，因为编译器自己能判断哪个是class而且只允许一个是class，只是这么写会不清晰而已。</p><p>而<T extends S>因为T可以是class也可以是interface，这个时候你说用extends还是implements？</p><p>当然只能硬性规定用extends了</p><p>语法的目的是在确保无歧义的情况下越易于阅读越好。</p><p>语法是人定的，不要死记硬背。</p></blockquote><p>如果我们考察对<code>Pair&lt;? extends Number&gt;</code>类型调用<code>getFirst()</code>方法，实际的方法签名变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;? extends Number&gt; getFirst();<br></code></pre></td></tr></table></figure><p>即返回值是<code>Number</code>或<code>Number</code>的子类，因此，可以安全赋值给<code>Number</code>类型的变量：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Number x = p.getFirst()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后，<strong>我们不可预测实际类型就是<code>Integer</code>，例如，下面的代码是无法通过编译的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = p.getFirst();<br></code></pre></td></tr></table></figure><p>这是因为实际的返回类型可能是<code>Integer</code>，也可能是<code>Double</code>或者其他类型，编译器只能确定类型一定是<code>Number</code>的子类（包括<code>Number</code>类型本身），但具体类型无法确定。</p><h4 id="上界通配符的限制-写set方法违反了类型安全规则-只能读不能写"><a href="#上界通配符的限制-写set方法违反了类型安全规则-只能读不能写" class="headerlink" title="上界通配符的限制:写set方法违反了类型安全规则(只能读不能写)"></a>上界通配符的限制:写set方法违反了类型安全规则(只能读不能写)</h4><p>我们再来考察一下<code>Pair&lt;T&gt;</code>的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-keyword">int</span> n = add(p);<br>        System.out.println(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;<br>        Number first = p.getFirst();<br>        Number last = p.getLast();<br>        p.setFirst(<span class="hljs-keyword">new</span> Integer(first.intValue() + <span class="hljs-number">100</span>));<br>        p.setLast(<span class="hljs-keyword">new</span> Integer(last.intValue() + <span class="hljs-number">100</span>));<br>        <span class="hljs-keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();<br>    &#125;<br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外，我们会得到一个编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">incompatible types: Integer cannot be converted to CAP#<span class="hljs-number">1</span><br>where CAP#<span class="hljs-number">1</span> is a fresh type-variable:<br>    CAP#<span class="hljs-number">1</span> extends Number from capture of ? extends Number<br></code></pre></td></tr></table></figure><p><strong>编译错误发生在<code>p.setFirst()</code>传入的参数是<code>Integer</code>类型。有些童鞋会问了，既然<code>p</code>的定义是<code>Pair&lt;? extends Number&gt;</code>，那么<code>setFirst(? extends Number)</code>为什么不能传入<code>Integer</code>？</strong></p><p><strong>原因还在于擦拭法。如果我们传入的<code>p</code>是<code>Pair&lt;Double&gt;</code>，显然它满足参数定义<code>Pair&lt;? extends Number&gt;</code>，然而，<code>Pair&lt;Double&gt;</code>的<code>setFirst()</code>显然无法接受<code>Integer</code>类型。</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;Double&gt; p = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>();<span class="hljs-comment">//满足Pair&lt;? extends Number&gt;</span><br>此时p.setFirst无法接收<span class="hljs-built_in">Integer</span><br></code></pre></td></tr></table></figure><p><strong>还有一个原因:Q</strong>:如果 &lt;? extends Number&gt;. 那么泛型擦拭 是变成Number 还是Object呢？</p><p><strong>A</strong>:Number</p><p>这就是<code>&lt;? extends Number&gt;</code>通配符的一个重要限制：**方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>**。</p><p>这里唯一的例外是可以给方法参数传入<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">p.setFirst(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// ok, 但是后面会抛出NullPointerException</span><br>p.getFirst().intValue(); <span class="hljs-comment">// NullPointerException</span><br></code></pre></td></tr></table></figure><h3 id="extends通配符的作用-使对象模板只读"><a href="#extends通配符的作用-使对象模板只读" class="headerlink" title="extends通配符的作用(使对象模板只读)*"></a>extends通配符的作用(使对象模板只读)*</h3><p>如果我们考察Java标准库的<code>java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span>; <span class="hljs-comment">// 获取个数</span><br>    <span class="hljs-function">T <span class="hljs-title">get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>; <span class="hljs-comment">// 根据索引获取指定元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">T t</span>)</span>; <span class="hljs-comment">// 添加一个新元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>(<span class="hljs-params">T t</span>)</span>; <span class="hljs-comment">// 删除一个已有元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，让我们定义一个方法来处理列表的每个元素：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> sumOfList(List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-keyword">Integer</span>&gt; list) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>    for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">Integer</span> n = list.get(i);<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么我们定义的方法参数类型是<code>List&lt;? extends Integer&gt;</code>而不是<code>List&lt;Integer&gt;</code>？从方法内部代码看，传入<code>List&lt;? extends Integer&gt;</code>或者<code>List&lt;Integer&gt;</code>是完全一样的，但是，注意到**<code>List&lt;? extends Integer&gt;</code>的限制**(只能get不能set)：</p><ul><li>允许调用<code>get()</code>方法获取<code>Integer</code>的引用；</li><li><strong>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）</strong>。</li></ul><p>因此，<strong>方法参数类型<code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素（因为无法调用<code>add(? extends Integer)</code>、<code>remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用<code>set(null)</code>除外）</strong>。</p><h3 id="使用extends限定T类型"><a href="#使用extends限定T类型" class="headerlink" title="使用extends限定T类型"></a>使用extends限定T类型</h3><p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number&gt;</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>现在，我们只能定义：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;Number&gt; p1 = <span class="hljs-built_in">null</span>;<br><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">Integer</span>&gt; p2 = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">Pair</span>&lt;Double&gt; p3 = <span class="hljs-built_in">null</span>;<br></code></pre></td></tr></table></figure><p>因为<code>Number</code>、<code>Integer</code>和<code>Double</code>都符合<code>&lt;T extends Number&gt;</code>。</p><p>非<code>Number</code>类型将无法通过编译：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt; p1 = <span class="hljs-built_in">null</span>; <span class="hljs-comment">// compile error!</span><br><span class="hljs-built_in">Pair</span>&lt;Object&gt; p2 = <span class="hljs-built_in">null</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>因为<code>String</code>、<code>Object</code>都不符合<code>&lt;T extends Number&gt;</code>，因为它们不是<code>Number</code>类型或<code>Number</code>的子类。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><h1 id="super通配符-读get方法违反类型安全规则-只能写不能读"><a href="#super通配符-读get方法违反类型安全规则-只能写不能读" class="headerlink" title="super通配符(读get方法违反类型安全规则,只能写不能读)"></a>super通配符(读get方法违反类型安全规则,只能写不能读)</h1><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p><p>考察下面的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Pair&lt;Integer&gt; p, Integer first, Integer last)</span> </span>&#123;<br>    p.setFirst(first);<br>    p.setLast(last);<br>&#125;<br></code></pre></td></tr></table></figure><p>传入<code>Pair&lt;Integer&gt;</code>是允许的，但是传入<code>Pair&lt;Number&gt;</code>是不允许的。</p><p>和<code>extends</code>通配符相反，这次，我们希望接受<code>Pair&lt;Integer&gt;</code>类型，以及<code>Pair&lt;Number&gt;</code>、<code>Pair&lt;Object&gt;</code>，因为<code>Number</code>和<code>Object</code>是<code>Integer</code>的父类，<code>setFirst(Number)</code>和<code>setFirst(Object)</code>实际上允许接受<code>Integer</code>类型。</p><p>我们使用<code>super</code>通配符来改写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Pair&lt;? <span class="hljs-keyword">super</span> Integer&gt; p, Integer first, Integer last)</span> </span>&#123;<br>    p.setFirst(first);<br>    p.setLast(last);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，<strong>方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</strong></p><p>下面的代码可以被正常编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Number&gt; p1 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">12.3</span>, <span class="hljs-number">4.56</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        setSame(p1, <span class="hljs-number">100</span>);<br>        setSame(p2, <span class="hljs-number">200</span>);<br>        System.out.println(p1.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p1.getLast());<br>        System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSame</span><span class="hljs-params">(Pair&lt;? <span class="hljs-keyword">super</span> Integer&gt; p, Integer n)</span> </span>&#123;<br>        p.setFirst(n);<br>        p.setLast(n);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考察<code>Pair&lt;? super Integer&gt;</code>的<code>setFirst()</code>方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(? <span class="hljs-keyword">super</span> Integer)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>因此，可以安全地传入<code>Integer</code>类型。</p><p>再考察<code>Pair&lt;? super Integer&gt;</code>的<code>getFirst()</code>方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">? <span class="hljs-function"><span class="hljs-keyword">super</span> Integer <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>这里注意到<strong>我们无法使用<code>Integer</code>类型来接收<code>getFirst()</code>的返回值，即下面的语句将无法通过编译：(因为获取的可能是Integer的父类,无法转型为Integer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = p.getFirst();<br></code></pre></td></tr></table></figure><p><strong>因为如果传入的实际类型是<code>Pair&lt;Number&gt;</code>，编译器无法将<code>Number</code>类型转型为<code>Integer</code>。</strong></p><p>注意：虽然<code>Number</code>是一个抽象类，我们无法直接实例化它。但是，即便<code>Number</code>不是抽象类，这里仍然无法通过编译。此外，传入<code>Pair&lt;Object&gt;</code>类型时，编译器也无法将<code>Object</code>类型转型为<code>Integer</code>。</p><p><strong>唯一可以接收<code>getFirst()</code>方法返回值的是<code>Object</code>类型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj = p.getFirst();<br></code></pre></td></tr></table></figure><p>因此，<strong>使用<code>&lt;? super Integer&gt;</code>通配符表示：</strong></p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，<strong>使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</strong></p><h3 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h3><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p>一个是允许读不允许写，另一个是允许写不允许读。</p><p><strong>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            T t = src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是把一个<code>List</code>的每个元素依次添加到另一个<code>List</code>中。它的第一个参数是<code>List&lt;? super T&gt;</code>，表示目标<code>List</code>，第二个参数<code>List&lt;? extends T&gt;</code>，表示要复制的<code>List</code>。我们可以简单地用<code>for</code>循环实现复制。在<code>for</code>循环中，我们可以看到，对于类型<code>&lt;? extends T&gt;</code>的变量<code>src</code>，我们可以安全地获取类型<code>T</code>的引用，而对于类型<code>&lt;? super T&gt;</code>的变量<code>dest</code>，我们可以安全地传入<code>T</code>的引用。</p><p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p><ul><li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li><li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li></ul><p>这是由编译器检查来实现的。如果在方法代码中意外修改了<code>src</code>，或者意外读取了<code>dest</code>，就会导致一个编译错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">copy</span>(<span class="hljs-params">List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? <span class="hljs-keyword">extends</span> T&gt; src</span>)</span> &#123;<br>        ...<br>        T t = dest.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// compile error!</span><br>        src.add(t); <span class="hljs-comment">// compile error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>copy()</code>方法的另一个好处是可以安全地把一个<code>List&lt;Integer&gt;</code>添加到<code>List&lt;Number&gt;</code>，但是无法反过来添加：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">//</span> <span class="hljs-variable">copy</span> <span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">to</span> <span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Number</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">ok</span><span class="hljs-operator">:</span><br><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Number</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">numList</span> <span class="hljs-operator">=</span> <span class="hljs-operator">...;</span><br><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">intList</span> <span class="hljs-operator">=</span> <span class="hljs-operator">...;</span><br><span class="hljs-variable">Collections</span><span class="hljs-operator">.</span><span class="hljs-variable">copy</span><span class="hljs-punctuation">(</span><span class="hljs-variable">numList</span><span class="hljs-operator">,</span> <span class="hljs-variable">intList</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><br><span class="hljs-operator">//</span> <span class="hljs-variable">ERROR</span><span class="hljs-operator">:</span> <span class="hljs-variable">cannot</span> <span class="hljs-variable">copy</span> <span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Number</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">to</span> <span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;:</span><br><span class="hljs-variable">Collections</span><span class="hljs-operator">.</span><span class="hljs-variable">copy</span><span class="hljs-punctuation">(</span><span class="hljs-variable">intList</span><span class="hljs-operator">,</span> <span class="hljs-variable">numList</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><p>而这些都是通过<code>super</code>和<code>extends</code>通配符，并由编译器强制检查来实现的。</p><h3 id="PECS原则-生产者继承-消费者超类"><a href="#PECS原则-生产者继承-消费者超类" class="headerlink" title="PECS原则(生产者继承,消费者超类)"></a>PECS原则(生产者继承,消费者超类)</h3><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：<strong>Producer Extends Consumer Super。</strong></p><p>即：<strong>如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</strong></p><p>还是以<code>Collections</code>的<code>copy()</code>方法为例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Collections &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">copy</span>(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? <span class="hljs-keyword">extends</span> T&gt; src) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.<span class="hljs-keyword">size</span>(); i++) &#123;<br>            T t = src.get(i); <span class="hljs-comment">// src是producer</span><br>            dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p><h3 id="无限定通配符-号-既不能读也不能写-只能做null判断"><a href="#无限定通配符-号-既不能读也不能写-只能做null判断" class="headerlink" title="无限定通配符(?号,既不能读也不能写,只能做null判断)"></a>无限定通配符(?号,既不能读也不能写,只能做null判断)</h3><p>我们已经讨论了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sample</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p><ul><li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li><li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li></ul><p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNull</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-keyword">null</span> || p.getLast() == <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNull</span><span class="hljs-params">(Pair&lt;T&gt; p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-keyword">null</span> || p.getLast() == <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点-Pair是所有Pair-的超类："><a href="#特点-Pair是所有Pair-的超类：" class="headerlink" title=" 特点:`Pair是所有Pair`的超类："></a><?> 特点:`Pair<?><code>是所有</code>Pair<T>`的超类：</h4><p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：**<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        Pair&lt;?&gt; p2 = p; <span class="hljs-comment">// 安全地向上转型</span><br>        System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是可以正常编译运行的，因为<code>Pair&lt;Integer&gt;</code>是<code>Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p><p>无限定通配符<code>&lt;?&gt;</code>很少使用，<strong>可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类</strong>。</p><h1 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h1><h3 id="反射中的泛型"><a href="#反射中的泛型" class="headerlink" title="反射中的泛型"></a>反射中的泛型</h3><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// compile warning:</span><br>Class clazz = String.class;<br>String str = (String) clazz.newInstance();<br><br><span class="hljs-comment">// no warning:</span><br>Class&lt;String&gt; clazz = String.class;<br>String str = clazz.newInstance();<br></code></pre></td></tr></table></figure><p><strong>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;? <span class="hljs-keyword">super</span> String&gt; sup = String.class.getSuperclass();<br></code></pre></td></tr></table></figure><p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Integer&gt; clazz = Integer.class;<br>Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="hljs-keyword">int</span>.class);<br>Integer i = cons.newInstance(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p><strong>我们可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt;[] ps = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// ok</span><br>Pair&lt;String&gt;[] ps = <span class="hljs-keyword">new</span> Pair&lt;String&gt;[<span class="hljs-number">2</span>]; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>必须通过强制转型实现带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p><strong>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code>ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code>arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code>arr</code>可能导致从<code>ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组</strong>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-built_in">Pair</span>[] arr = new <span class="hljs-built_in">Pair</span>[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt;[] ps = (<span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt;[]) arr;<br><br>ps[<span class="hljs-number">0</span>] = new <span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt;(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>arr[<span class="hljs-number">1</span>] = new <span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">Integer</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>// ClassCastException:<br><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt; p = ps[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">String</span> s = p.getFirst();<br></code></pre></td></tr></table></figure><p>要安全地使用泛型数组，必须扔掉<code>arr</code>的引用：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br><span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt;[] ps = (<span class="hljs-built_in">Pair</span>&lt;<span class="hljs-built_in">String</span>&gt;[]) new <span class="hljs-built_in">Pair</span>[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p><p><strong>带泛型的数组实际上是编译器的类型擦除(擦成父类对象,一般类型的就擦成Object,需要时候再将类型转成子类)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>System.out.println(ps.getClass() == Pair[].class); <span class="hljs-comment">// true</span><br><br>String s1 = (String) arr[<span class="hljs-number">0</span>].getFirst();<br>String s2 = ps[<span class="hljs-number">0</span>].getFirst();<br></code></pre></td></tr></table></figure><p>**所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>(为啥?看下面案例)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// compile error:</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abc</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T[] createArray() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>必须借助<code>Class&lt;T&gt;</code>来创建泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] createArray(Class&lt;T&gt; cls) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) Array.newInstance(cls, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们**还可以利用可变参数创建泛型数组<code>T[]</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayHelper</span> </span>&#123;<br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br><br>String[] ss = ArrayHelper.asArray(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Integer[] ns = ArrayHelper.asArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="谨慎使用泛型可变参数"><a href="#谨慎使用泛型可变参数" class="headerlink" title="谨慎使用泛型可变参数"></a>谨慎使用泛型可变参数</h3><p>在上面的例子中，我们看到，通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>    <span class="hljs-keyword">return</span> objs;<br>&#125;<br></code></pre></td></tr></table></figure><p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] arr = asArray(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// ClassCastException:</span><br>        String[] firstTwo = pickTwo(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(firstTwo));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;<br>        <span class="hljs-keyword">return</span> asArray(k1, k2);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接调用<code>asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code>ClassCastException</code>，原因还是因为擦拭法，在<code>pickTwo()</code>方法内部，编译器无法检测<code>K[]</code>的正确类型，因此返回了<code>Object[]</code>。</p><p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p><p> 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p><p>更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p><p><strong>原因:调用外层方法static <K> K[] pickTwo(K k1, K k2, K k3)时，编译器已经将K的实际类型擦拭成Object了，再调用内层方法static <T> T[] asArray(T… objs)时，入参T的类型就被认定为Object，因此内层方法返回的类型为Object[]，且不会被编译器进行强制转换（因为入参类型就是Object，因此编译器认为不需要进行强制转换），最后外层方法将返回一个Object[]对象，且将会被编译器强制转换成String[]，此时会发生ClassCastException</strong></p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>部分反射API是泛型，例如：<code>Class&lt;T&gt;</code>，<code>Constructor&lt;T&gt;</code>；</p><p>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</p><p>可以通过<code>Array.newInstance(Class&lt;T&gt;, int)</code>创建<code>T[]</code>数组，需要强制转型；</p><p>同时使用泛型和可变参数时需要特别小心。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>5.泛型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象基础</title>
    <link href="/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h1><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>判断基本数据类型时,比较的是值</p><p>判断对象类型时,两个对象是否指向同一内存地址,和hashCode没有直接关系,只是恰好Object及其继承类的hashCode()方法返回的是内存地址</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java">OverRideHashCode a = <span class="hljs-keyword">new</span> OverRideHashCode(<span class="hljs-number">1</span>);<br>OverRideHashCode b = <span class="hljs-keyword">new</span> OverRideHashCode(<span class="hljs-number">1</span>);<br>System.out.println(a == b); <span class="hljs-comment">//false</span><br>System.out.println(a.hashCode()); <span class="hljs-comment">//118 虽然哈希码相同但是内存地址不同</span><br>System.out.println(b.hashCode()); <span class="hljs-comment">//118</span><br></code></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p><strong>hashCode()只是特征表示码,表示两个对象有同样的特征值,主要用来配合哈希表使用</strong></p><p>调用hashCode方法默认返回的值被称为<strong>identity hash code（标识哈希码）</strong>，接下来我们会用标识哈希码来区分重写hashCode方法。如果一个类重写了hashCode方法，那么通过调用<code>System.identityHashCode(Object o)</code>方法获得标识哈希码。</p><p>**Q:**hashCode()方法返回的到底是不是对象地址?</p><p><strong>A:</strong> 不一定,hashCode()是一个native方法,即非java实现的(c实现),有多种实现策略,在不同的jvm里有不同的实现,可能是内存地址,也有可能是通过当前状态值进行异或（XOR）运算得到的一个 hash 值</p><p>可以通过配置jvm启动参数 -XX:hashCode=N  N可以是0/1/2/3/4/5 </p><p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125145808108.png!%5Bimage-20211125150343680%5D(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.assets/image-20211125150343680.png" alt="image-20211125145808108">Object里的hashCode默认为内存地址转为十进制</p><p><strong>注意 用了lombok注解@EqualsAndHashCode(@Data里面也包含)时,重写了hashCode()和equals(),导致内部值相同时,两个对象hashcode也相同,equals也成立</strong></p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>如果没有重写的话,比如在Object中,equals等效与==</p><p>如果重写了,比如在String中,equals表示一种逻辑上的相等,比较的是字符是否相同,与==不等效</p><hr><p>hashCode和equals两个方法是有语义关联的，它们需要满足：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>equals(B)==<span class="hljs-literal">true</span> ---&gt;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>hash<span class="hljs-constructor">Code()</span>==<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>hash<span class="hljs-constructor">Code()</span><br></code></pre></td></tr></table></figure><p>注意,如果重写了equals,必须要重写hashCode,保证equals认定为两个相同的对象,具有相同哈希值,保证逻辑上的一致性</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类创建实例时,通过构造方法初始化,构造方法名字和类名一样,可以任意传参,内部语句也可以任意编写,但是没有返回值(没有void)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FormBiz</span><span class="hljs-params">(RemoteActivitiService remoteActivitiService, RemoteTaskService remoteTaskService, IWbAppService appService, IWbAppManagerService wbAppManagerService, IWbOrgDeptService deptService, IWbDynamicFormService dynamicFormService, IWbDynamicFormDirectoryService dynamicFormDirectoryService, DynamicDataSource dynamicDataSource, FormPermissionProvider formPermissionProvider, FormManager formManager, UserProvider userProvider)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.remoteActivitiService = remoteActivitiService;<br>    <span class="hljs-keyword">this</span>.remoteTaskService = remoteTaskService;<br>    <span class="hljs-keyword">this</span>.appService = appService;<br>    <span class="hljs-keyword">this</span>.wbAppManagerService = wbAppManagerService;<br>    <span class="hljs-keyword">this</span>.deptService = deptService;<br>    <span class="hljs-keyword">this</span>.dynamicFormService = dynamicFormService;<br>    <span class="hljs-keyword">this</span>.dynamicFormDirectoryService = dynamicFormDirectoryService;<br>    <span class="hljs-keyword">this</span>.dynamicDataSource = dynamicDataSource;<br>    <span class="hljs-keyword">this</span>.formPermissionProvider = formPermissionProvider;<br>    <span class="hljs-keyword">this</span>.formManager = formManager;<br>    <span class="hljs-keyword">this</span>.userProvider = userProvider;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>如果一个类没有定义构造方法,那么会生成一个默认无参的构造方法,如果自定义构造方法,就会覆盖无参的方法</p><p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>; 也可以对字段进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>赋值时,先执行初始化赋值,再执行构造方法赋值</p><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p><p>举个例子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p><ul><li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li><li><code>int indexOf(String str)</code>：根据字符串查找；</li><li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li><li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。]</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>定义Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义Student继承于Person</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 不要重复name和age字段/方法,</span><br>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span><br>    <span class="hljs-keyword">private</span> int score;<br><br>    public int getScore() &#123; … &#125;<br>    public void setScore(int score) &#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</strong></p><p>lombok  @AllArgsConstructor 无法获取全部父类构造器</p><h3 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h3><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────┐<br>│  Object   │<br>└───────────┘<br>      ▲<br>      │<br>┌───────────┐<br>│  Person   │<br>└───────────┘<br>      ▲<br>      │<br>┌───────────┐<br>│  Student  │<br>└───────────┘<br></code></pre></td></tr></table></figure><p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p><p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───────────┐<br>       │  Object   │<br>       └───────────┘<br>             ▲<br>             │<br>       ┌───────────┐<br>       │  Person   │<br>       └───────────┘<br>          ▲     ▲<br>          │     │<br>          │     │<br>┌───────────┐ ┌───────────┐<br>│  Student  │ │  Teacher  │<br>└───────────┘ └───────────┘<br></code></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;<br>    <span class="hljs-keyword">private</span> int age;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    public <span class="hljs-type">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 编译错误：无法访问name字段</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> name;<br>    <span class="hljs-keyword">protected</span> int age;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    public <span class="hljs-type">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// OK!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    public <span class="hljs-type">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-keyword">super</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// super</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Run</p><p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p><p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> int score;<br><br>    public <span class="hljs-type">Student</span>(<span class="hljs-type">String</span> name, int age, int score) &#123;<br>        <span class="hljs-keyword">super</span>(); <span class="hljs-comment">// 自动调用父类的构造方法</span><br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> int score;<br><br>    public <span class="hljs-type">Student</span>(<span class="hljs-type">String</span> name, int age, int score) &#123;<br>        <span class="hljs-keyword">super</span>(name, age); <span class="hljs-comment">// 调用父类的构造方法Person(String, int)</span><br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以正常编译了！</p><p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>这里还顺带引出了另一个问题：即子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p><p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p><p>例如，定义一个<code>Shape</code>类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> sealed <span class="hljs-keyword">class</span> <span class="hljs-symbol">Shape</span> <span class="hljs-symbol">permits</span> <span class="hljs-symbol">Rect, <span class="hljs-symbol">Circle</span>, <span class="hljs-symbol">Triangle</span></span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。但是，如果定义一个<code>Ellipse</code>就会报错：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ellipse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125;<br><span class="hljs-comment">// Compile error: class is not allowed to extend sealed class: Shape</span><br></code></pre></td></tr></table></figure><p>原因是<code>Ellipse</code>并未出现在<code>Shape</code>的<code>permits</code>列表中。这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</p><p><code>sealed</code>类在Java 15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>如果一个引用变量的类型是<code>Student</code>，那么它可以指向一个<code>Student</code>类型的实例：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Student s</span> = new Student();<br></code></pre></td></tr></table></figure><p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Person p</span> = new Person();<br></code></pre></td></tr></table></figure><p>现在问题来了：如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能否指向<code>Student</code>类型的实例？</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(); <span class="hljs-comment">// ???</span><br></code></pre></td></tr></table></figure><p>测试一下就可以发现，这种指向是允许的！</p><p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p><p><strong>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">Student s = new Student();<br>Person p = s; <span class="hljs-regexp">//</span> upcasting, ok<br>Object o1 = p; <span class="hljs-regexp">//</span> upcasting, ok<br>Object o2 = s; <span class="hljs-regexp">//</span> upcasting, ok<br></code></pre></td></tr></table></figure><p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(); <span class="hljs-comment">// upcasting, ok</span><br>Person p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>Student s1 = (Student) p1; <span class="hljs-comment">// ok</span><br>Student s2 = (Student) p2; <span class="hljs-comment">// runtime error! ClassCastException!</span><br></code></pre></td></tr></table></figure><p>如果测试上面的代码，可以发现：</p><p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，<code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。在向下转型的时候，把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p><p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p><p>为了避免向下转型出错，Java提供了**<code>instanceof</code>**操作符，可以先判断一个实例究竟是不是某种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person();<br>System.out.println(p <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br>System.out.println(p <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span><br><br>Student s = <span class="hljs-keyword">new</span> Student();<br>System.out.println(s <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br>System.out.println(s <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// true</span><br><br>Student n = <span class="hljs-keyword">null</span>;<br>System.out.println(n <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：z</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Person p = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Student) &#123;<br>    <span class="hljs-comment">// 只有判断成功才会向下转型:</span><br>    Student s = (Student) p; <span class="hljs-comment">// 一定会成功</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">Object</span> obj = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">String</span>) &#123;<br>    <span class="hljs-keyword">String</span> s = (<span class="hljs-keyword">String</span>) obj;<br>    System.out.<span class="hljs-built_in">println</span>(s.toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// instanceof variable:</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object obj = <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;<br>            <span class="hljs-comment">// 可以直接使用变量s:</span><br>            System.out.println(s.toUpperCase());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> Run</p><p>这种使用<code>instanceof</code>的写法更加简洁。</p><h3 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h3><p>在使用继承时，我们要注意逻辑一致性。</p><p>考察下面的<code>Book</code>类：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">class <span class="hljs-type">Book</span> &#123;<br>    protected <span class="hljs-type">String</span> name;<br>    public <span class="hljs-type">String</span> getName() <span class="hljs-meta">&#123;...&#125;</span><br>    public <span class="hljs-built_in">void</span> setName(<span class="hljs-type">String</span> name) <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>Book</code>类也有<code>name</code>字段，那么，我们能不能让<code>Student</code>继承自<code>Book</code>呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> int score;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，从逻辑上讲，这是不合理的，<code>Student</code>不应该从<code>Book</code>继承，而应该从<code>Person</code>继承。</p><p>究其原因，是因为<code>Student</code>是<code>Person</code>的一种，它们是is关系，而<code>Student</code>并不是<code>Book</code>。实际上<code>Student</code>和<code>Book</code>的关系是has关系。</p><p>具有has关系不应该使用继承，而是使用组合，即<code>Student</code>可以持有一个<code>Book</code>实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Book</span> book;<br>    <span class="hljs-keyword">protected</span> int score;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，继承是is关系，组合是has关系。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Person p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>();<br>p.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 无法确定运行时究竟调用哪个run()方法</span><br></code></pre></td></tr></table></figure><p>有童鞋会问，从上面的代码一看就明白，肯定调用的是<code>Student</code>的<code>run()</code>方法啊。</p><p>但是，假设我们编写这样一个方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTwice</span><span class="hljs-params">(Person p)</span> </span>&#123;<br>    p.<span class="hljs-built_in">run</span>();<br>    p.<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p><p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p><p>我们还是来举栗子。</p><p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Income</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> income;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> income * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 税率10%</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public double getTax() &#123;<br>        <span class="hljs-keyword">if</span> (income &lt;= <span class="hljs-number">5000</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateCouncilSpecialAllowance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public double getTax() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">totalTax</span><span class="hljs-params">(Income... incomes)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Income income: incomes) &#123;<br>        total = total + income.<span class="hljs-built_in">getTax</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样,只有到实际执行的时候,才知道执行的是哪个方法,类似低代码平台的Control</p><p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><h3 id="覆写Object方法"><a href="#覆写Object方法" class="headerlink" title="覆写Object方法"></a>覆写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><ul><li><code>toString()</code>：把instance输出为<code>String</code>；</li><li><code>equals()</code>：判断两个instance是否逻辑相等；</li><li><code>hashCode()</code>：计算一个instance的哈希值。</li></ul><p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 显示更有意义的字符串:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:name=&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">// 比较是否相等:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;<br>        <span class="hljs-comment">// 当且仅当o为Person类型:</span><br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            Person p = (Person) o;<br>            <span class="hljs-comment">// 并且name字段相同时，返回true:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算hash:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br>Student <span class="hljs-keyword">extends</span> Person &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的hello()方法:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.hello() + <span class="hljs-string">&quot;!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">public</span> final <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br>Student <span class="hljs-keyword">extends</span> Person &#123;<br>    <span class="hljs-comment">// compile error: 不允许覆写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">String</span> name;<br>&#125;<br><br><span class="hljs-comment">// compile error: 不允许继承自Person</span><br>Student <span class="hljs-keyword">extends</span> Person &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name = <span class="hljs-string">&quot;Unamed&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对<code>final</code>字段重新赋值会报错：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>p.name = <span class="hljs-string">&quot;New Name&quot;</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p><strong>可以在构造方法中初始化final字段：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p><ul><li><code>final</code>修饰符有多种作用：<ul><li><code>final</code>修饰的方法可以阻止被覆写；</li><li><code>final</code>修饰的class可以阻止被继承；</li><li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li></ul></li></ul><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>Person</code>类派生的<code>Student</code>和<code>Teacher</code>都可以覆写<code>run()</code>方法。</p><p>如果父类<code>Person</code>的<code>run()</code>方法没有实际意义，能否去掉方法的执行语句？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// Compile Error!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。</p><p>能不能去掉父类的<code>run()</code>方法？</p><p>答案还是不行，因为去掉父类的<code>run()</code>方法，就失去了多态的特性。例如，<code>runTwice()</code>就无法编译：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTwice</span><span class="hljs-params">(Person p)</span> </span>&#123;<br>    p.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// Person没有run()方法，会导致编译错误</span><br>    p.<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p><p>**使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类： 但可以实例化被继承的子类 **</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(); <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Person s</span> = new Student();<br><span class="hljs-attribute">Person t</span> = new Teacher();<br></code></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 不关心Person变量的具体子类型:</span><br>s.<span class="hljs-built_in">run</span>();<br>t.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure><p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 同样不关心新的子类是如何实现run()方法的：</span><br>Person e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>();<br>e.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：<code>interface</code>。</p><p>在Java中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Person, <span class="hljs-symbol">Hello</span></span> &#123; <span class="hljs-comment">// 实现了两个interface</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>注意区分术语：</p><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p><p>抽象类和接口的对比如下：</p><table><thead><tr><th align="left"></th><th align="left">abstract class</th><th align="left">interface</th></tr></thead><tbody><tr><td align="left">继承</td><td align="left">只能extends一个class</td><td align="left">可以implements多个interface</td></tr><tr><td align="left">字段</td><td align="left">可以定义实例字段</td><td align="left">不能定义实例字段</td></tr><tr><td align="left">抽象方法</td><td align="left">可以定义抽象方法</td><td align="left">可以定义抽象方法</td></tr><tr><td align="left">非抽象方法</td><td align="left">可以定义非抽象方法</td><td align="left">可以定义default方法</td></tr></tbody></table><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><strong>抽象类可以不实现接口,留给子类去实现</strong></p><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，<strong>公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。</strong>可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────────┐<br>│   Iterable    │<br>└───────────────┘<br>        ▲                ┌───────────────────┐<br>        │                │      Object       │<br>┌───────────────┐        └───────────────────┘<br>│  Collection   │                  ▲<br>└───────────────┘                  │<br>        ▲     ▲          ┌───────────────────┐<br>        │     └──────────│AbstractCollection │<br>┌───────────────┐        └───────────────────┘<br>│     List      │                  ▲<br>└───────────────┘                  │<br>              ▲          ┌───────────────────┐<br>              └──────────│   AbstractList    │<br>                         └───────────────────┘<br>                                ▲     ▲<br>                                │     │<br>                                │     │<br>                     ┌────────────┐ ┌────────────┐<br>                     │ ArrayList  │ │ LinkedList │<br>                     └────────────┘ └────────────┘<br></code></pre></td></tr></table></figure><p>在使用的时候，<strong>实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">List list = new ArrayList(); <span class="hljs-regexp">//</span> 用List接口引用具体子类的实例<br>Collection coll = list; <span class="hljs-regexp">//</span> 向上转型为Collection接口<br>Iterable it = coll; <span class="hljs-regexp">//</span> 向上转型为Iterable接口<br></code></pre></td></tr></table></figure><h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> interface<br></code></pre></td></tr></table></figure><p> Run</p><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段(<strong>注:接口中不能有实例字段,但可以有静态字段,默认是public static final的,修饰符可写可不写</strong>)，**<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段**。</p><h1 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h1><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">// 定义静态字段number:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ascii">        ┌──────────────────┐<br>ming ──&gt;│Person instance   │<br>        ├──────────────────┤<br>        │name = &quot;Xiao Ming&quot;│<br>        │age = 12          │<br>        │number ───────────┼──┐    ┌─────────────┐<br>        └──────────────────┘  │    │Person class │<br>                              │    ├─────────────┤<br>                              ├───&gt;│number = 99  │<br>        ┌──────────────────┐  │    └─────────────┘<br>hong ──&gt;│Person instance   │  │<br>        ├──────────────────┤  │<br>        │name = &quot;Xiao Hong&quot;│  │<br>        │age = 15          │  │<br>        │number ───────────┼──┘<br>        └──────────────────┘<br></code></pre></td></tr></table></figure><p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，所有实例共享一个静态字段。</p><p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p><p>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>number = <span class="hljs-number">99</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>number);<br></code></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>有静态字段，就有静态方法。用<code>static</code>修饰的方法称为静态方法。</p><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> static method<br></code></pre></td></tr></table></figure><p> Run</p><p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p><p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p><p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p><p>静态方法经常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><p>静态方法也经常用于辅助方法。注意到Java程序的入口<code>main()</code>也是静态方法。</p><h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MALE = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FEMALE = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Person</span> &#123;<br>    <span class="hljs-comment">// 编译器会自动加上public statc final:</span><br>    <span class="hljs-built_in">int</span> MALE = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> FEMALE = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会自动把该字段变为<code>public static final</code>类型。</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p><p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code></p><p><strong>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系.</strong></p><p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p><p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">package_sample<br>└─ src<br>    ├─ hong<br>    │  └─ Person.java<br>    │  ming<br>    │  └─ Person.java<br>    └─ mr<br>       └─ jun<br>          └─ Arrays.java<br></code></pre></td></tr></table></figure><p>即所有Java文件对应的目录层次要和包的层次一致。</p><p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">package_sample<br>└─ bin<br>   ├─ hong<br>   │  └─ Person.class<br>   │  ming<br>   │  └─ Person.class<br>   └─ mr<br>      └─ jun<br>         └─ Arrays.class<br></code></pre></td></tr></table></figure><p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">javac -d ../bin ming/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>java hong/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>java mr/jun/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>java<br></code></pre></td></tr></table></figure><p>在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。</p><h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 包作用域:</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> hello;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>        p.hello(); <span class="hljs-comment">// 可以调用，因为Main和Person在同一个包</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p><p>第一种，直接写出完整类名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        mr.jun.Arrays arrays = <span class="hljs-keyword">new</span> mr.jun.Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，每次写完整类名比较痛苦。</p><p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入完整类名:</span><br><span class="hljs-keyword">import</span> mr.jun.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Arrays arrays = <span class="hljs-keyword">new</span> Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入mr.jun包的所有class:</span><br><span class="hljs-keyword">import</span> mr.jun.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Arrays arrays = <span class="hljs-keyword">new</span> Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p><p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package main;<br><br><span class="hljs-comment">// 导入System类的所有静态字段和静态方法:</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 相当于调用System.out.println(…)</span><br>        out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>import static</code>很少使用。</p><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p><strong>编写class的时候，编译器会自动帮我们做两个import动作</strong>：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>.</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p><ul><li>String</li><li>System</li><li>Runtime</li><li>…</li></ul><p>要注意也不要和JDK常用类重名：</p><ul><li>java.util.List</li><li>java.text.Format</li><li>java.math.BigInteger</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在Java中，我们经常看到<code>public</code>、<code>protected</code>、<code>private</code>这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。</p><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Main可以访问Hello</span><br>        Hello h = <span class="hljs-keyword">new</span> Hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>hi()</code>方法是<code>public</code>，可以被其他类调用，前提是首先要能访问<code>Hello</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        Hello h = <span class="hljs-keyword">new</span> Hello();<br>        h.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// 不能被其他类调用:</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hi();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// private</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Inner i = <span class="hljs-keyword">new</span> Inner();<br>        i.hi();<br>    &#125;<br><br>    <span class="hljs-comment">// private方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;private hello!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 静态内部类:</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">hi</span>(<span class="hljs-params"></span>)</span> &#123;<br>            Main.hello();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Run</p><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p><h3 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// protected方法:</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>protected</code>方法可以被继承的类访问：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    void foo() &#123;<br>        <span class="hljs-comment">// 可以访问protected方法:</span><br>        hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><span class="hljs-comment">// package权限的类:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// package权限的方法:</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</p><p><strong>注:一个.java文件中最多只能有一个public类,且类名与文件名相同,也可以没有public类,这样类名可以和.java文件名不同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 可以访问package权限的类:</span><br>        Hello h = <span class="hljs-keyword">new</span> Hello();<br>        <span class="hljs-comment">// 可以调用package权限的方法:</span><br>        h.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123; <span class="hljs-comment">// ①</span><br>        <span class="hljs-keyword">String</span> s = name.<span class="hljs-built_in">toLowerCase</span>(); <span class="hljs-comment">// ②</span><br>        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// ③</span><br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// ④</span><br>            <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span> - len; <span class="hljs-comment">// ⑤</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">// ⑥</span><br>                System.out.<span class="hljs-built_in">println</span>(); <span class="hljs-comment">// ⑦</span><br>            &#125; <span class="hljs-comment">// ⑧</span><br>        &#125; <span class="hljs-comment">// ⑨</span><br>    &#125; <span class="hljs-comment">// ⑩</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们观察上面的<code>hi()</code>方法代码：</p><ul><li>方法参数name是局部变量，它的作用域是整个方法，即①～⑩；</li><li>变量s的作用域是定义处到方法结束，即②～⑩；</li><li>变量len的作用域是定义处到方法结束，即③～⑩；</li><li>变量p的作用域是定义处到if块结束，即⑤～⑨；</li><li>变量i的作用域是for循环，即⑥～⑧。</li></ul><p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p><h3 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h3><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-comment">// 无法被继承:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> i = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-comment">// 无法被覆写:</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        t = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</p><p>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p><p><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</p><p>以上针对类和方法,针对成员变量则有下图</p><p><img src="https://images2015.cnblogs.com/blog/690292/201609/690292-20160923095944481-1758567758.png" alt="img"></p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h3 id="内部类-Inner-Class"><a href="#内部类-Inner-Class" class="headerlink" title="内部类(Inner Class)"></a>内部类(Inner Class)</h3><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>        // 定义了一个<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">Class</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Main &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>(&quot;Nested&quot;); // 实例化一个<span class="hljs-keyword">Outer</span><br>        <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); // 实例化一个<span class="hljs-keyword">Inner</span><br>        <span class="hljs-keyword">inner</span>.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span> &#123;<br>    private String <span class="hljs-type">name</span>;<br><br>    <span class="hljs-keyword">Outer</span>(String <span class="hljs-type">name</span>) &#123;<br>        this.name = <span class="hljs-type">name</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>        <span class="hljs-type">void</span> hello() &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Hello, &quot; + <span class="hljs-keyword">Outer</span>.this.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察上述代码，要实例化一个<code>Inner</code>，我们必须首先创建一个<code>Outer</code>的实例，然后，调用<code>Outer</code>实例的<code>new</code>来创建<code>Inner</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer.Inner inner = outer.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>这是因为Inner Class除了有一个<code>this</code>指向它自己，还隐含地持有一个Outer Class实例，可以用<code>Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p><p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的<code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。x</p><h3 id="匿名类-Anonymous-Class"><a href="#匿名类-Anonymous-Class" class="headerlink" title="匿名类(Anonymous Class)"></a>匿名类(Anonymous Class)</h3><p><strong>接口不能实例化,所以实例化一个内部匿名接口时,必须实现它的所有方法</strong></p><p><strong>内部匿名类也可以是非接口,比如</strong></p><p><code>     HashMap&lt;String, String&gt; map2 = new HashMap&lt;&gt;() &#123;&#125;; // 匿名类!</code>     </p><p>后面的方括号表示static代码块,可以做一些初始化操作</p><p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Anonymous Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Outer outer = <span class="hljs-keyword">new</span> Outer(<span class="hljs-string">&quot;Nested&quot;</span>);<br>        outer.asyncHello();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">asyncHello</span><span class="hljs-params">()</span> </span>&#123;<br>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-keyword">this</span>.name);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Runnable r = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 实现必要的抽象方法...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p><p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// Anonymous Class</span><br><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">HashMap</span>;<br><br><span class="hljs-keyword">public</span> class Main &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="hljs-comment">// 匿名类!</span><br>        <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; map3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;() &#123;<br>            &#123;<br>                put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>                put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>            &#125;<br>        &#125;;<br>        System.out.<span class="hljs-built_in">println</span>(map3.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;A&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，<strong>并且添加了<code>static</code>代码块来初始化数据</strong>*<strong>注:中括号内即为static代码块</strong>。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p><h3 id="静态内部类-Static-Nested-Class"><a href="#静态内部类-Static-Nested-Class" class="headerlink" title="静态内部类(Static Nested Class)"></a>静态内部类(Static Nested Class)</h3><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Static Nested Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Outer.StaticNested sn = <span class="hljs-keyword">new</span> Outer.StaticNested();<br>        sn.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String NAME = <span class="hljs-string">&quot;OUTER&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNested</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.NAME);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种：</p><ul><li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer Class的<code>private</code>访问权限；</li><li>Static Nested Class是独立类，但拥有Outer Class的<code>private</code>访问权限。</li></ul><h1 id="classpath-类路径-和jar"><a href="#classpath-类路径-和jar" class="headerlink" title="classpath(类路径)和jar"></a>classpath(类路径)和jar</h1><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>在Java中，我们经常听到<code>classpath</code>这个东西。网上有很多关于“如何设置classpath”的文章，但大部分设置都不靠谱。</p><p>到底什么是<code>classpath</code>？</p><p>**<code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>**。</p><p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p><p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\w</span>ork<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in;C:<span class="hljs-symbol">\s</span>hared;&quot;D:<span class="hljs-symbol">\M</span>y Documents<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in&quot;<br></code></pre></td></tr></table></figure><p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>shared:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/</span>home<span class="hljs-regexp">/liaoxuefeng/</span>bin<br></code></pre></td></tr></table></figure><p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p><ul><li>&lt;当前目录&gt;\abc\xyz\Hello.class</li><li>C:\work\project1\bin\abc\xyz\Hello.class</li><li>C:\shared\abc\xyz\Hello.class</li></ul><p><strong>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</strong></p><p><code>classpath</code>的设定方法有两种：</p><p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p><p>在启动JVM时设置<code>classpath</code>变量，推荐。</p><p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在<strong>启动JVM</strong>时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -classpath .;C:<span class="hljs-symbol">\w</span>ork<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in;C:<span class="hljs-symbol">\s</span>hared abc.xyz.Hello<br></code></pre></td></tr></table></figure><p>或者使用<code>-cp</code>的简写：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -cp .;C:<span class="hljs-symbol">\w</span>ork<span class="hljs-symbol">\p</span>roject1<span class="hljs-symbol">\b</span>in;C:<span class="hljs-symbol">\s</span>hared abc.xyz.Hello<br></code></pre></td></tr></table></figure><p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>abc.xyz.Hello<br></code></pre></td></tr></table></figure><p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p><p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p><p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p><p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p><p> 不要把任何Java核心库添加到<code>classpath</code>中！JVM根本不依赖<code>classpath</code>加载核心库！</p><p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p><p>假设我们有一个编译后的<code>Hello.class</code>，它的包名是<code>com.example</code>，当前目录是<code>C:\work</code>，那么，目录结构必须如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">C:\work<br>└─ com<br>   └─ example<br>      └─ Hello.class<br></code></pre></td></tr></table></figure><p>运行这个<code>Hello.class</code>必须在当前目录下使用如下命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">C:</span>\work&gt; java -<span class="hljs-keyword">cp</span> . <span class="hljs-keyword">com</span>.example.Hello<br></code></pre></td></tr></table></figure><p>JVM根据classpath设置的<code>.</code>在当前目录下查找<code>com.example.Hello</code>，即实际搜索文件必须位于<code>com/example/Hello.class</code>。如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p><h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar包实际上就是一个<code>zip</code>格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p><p><strong>注:jar包也可以当<code>classpath</code>用</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -cp ./hello<span class="hljs-selector-class">.jar</span> abc<span class="hljs-selector-class">.xyz</span>.Hello<br></code></pre></td></tr></table></figure><p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p><p>那么问题来了：如何创建jar包？</p><p><strong>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</strong></p><p>假设编译输出的目录结构是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">package_sample<br>└─ bin<br>   ├─ hong<br>   │  └─ Person.class<br>   │  ming<br>   │  └─ Person.class<br>   └─ mr<br>      └─ jun<br>         └─ Arrays.class<br></code></pre></td></tr></table></figure><p><strong>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</strong></p><p><img src="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l" alt="hello.zip.ok"></p><p>如果长这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l" alt="hello.zip.invalid"></p><p>说明打包打得有问题，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p><p>????</p><p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><p><strong>即会自动去找main-class,可以直接用java -jar xxx.jar启动jar包</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>hello.<span class="hljs-keyword">jar</span><br></code></pre></td></tr></table></figure><p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p><p><strong>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>，可以非常方便地创建jar包。</strong></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p><p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p><p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p><p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p><h1 id="模块-Java9"><a href="#模块-Java9" class="headerlink" title="模块(Java9)"></a>模块(Java9)</h1><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>从Java 9开始，JDK又引入了模块（Module）。</p><p>什么是模块？这要从Java 9之前的版本说起。</p><p>我们知道，<code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p><p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main<br></code></pre></td></tr></table></figure><p> <strong>注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</strong></p><p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code>。</p><p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p><p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>…</li></ul><p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p><p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><h3 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h3><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ascii">oop-module<br>├── bin<br>├── build.sh<br>└── src<br>    ├── com<br>    │   └── itranswarp<br>    │       └── sample<br>    │           ├── Greeting.java<br>    │           └── Main.java<br>    └── module-info.java<br></code></pre></td></tr></table></figure><p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">module</span> hello.world &#123;<br><span class="hljs-keyword">requires</span> java.base; <span class="hljs-comment">// 可不写，任何模块都会自动引入java.base</span><br><span class="hljs-keyword">requires</span> java.xml;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p><p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itranswarp.sample;<br><br><span class="hljs-comment">// 必须引入java.xml模块后才能使用其中的类:</span><br><span class="hljs-keyword">import</span> javax.xml.XMLConstants;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Greeting g = <span class="hljs-keyword">new</span> Greeting();<br>System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p><p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p><p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java<br></code></pre></td></tr></table></figure><p>如果编译成功，现在项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">oop-module<br>├── bin<br>│   ├── com<br>│   │   └── itranswarp<br>│   │       └── sample<br>│   │           ├── Greeting.class<br>│   │           └── Main.class<br>│   └── module-info.class<br>└── src<br>    ├── com<br>    │   └── itranswarp<br>    │       └── sample<br>    │           ├── Greeting.java<br>    │           └── Main.java<br>    └── module-info.java<br></code></pre></td></tr></table></figure><p>注意到<code>src</code>目录下的<code>module-info.java</code>被编译到<code>bin</code>目录下的<code>module-info.class</code>。</p><p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .<br></code></pre></td></tr></table></figure><p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jmod create --class-path hello.jar hello.jmod<br></code></pre></td></tr></table></figure><p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p><h3 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java --module-path hello.jmod --module hello.world<br></code></pre></td></tr></table></figure><p>结果是一个错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error occurred during initialization of boot layer<br>java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod<br></code></pre></td></tr></table></figure><p>原因是<code>.jmod</code>不能被放入<code>--module-path</code>中。换成<code>.jar</code>就没问题了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java --module-path hello.jar --module hello.world<br>Hello, xml!<br></code></pre></td></tr></table></figure><p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p><h3 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h3><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p><p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/<br></code></pre></td></tr></table></figure><p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jre/bin/java --module hello.world<br>Hello, xml!<br></code></pre></td></tr></table></figure><p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">module java.<span class="hljs-built_in">xml</span> &#123;<br>    exports java.<span class="hljs-built_in">xml</span>;<br>    exports javax.<span class="hljs-built_in">xml</span>.catalog;<br>    exports javax.<span class="hljs-built_in">xml</span>.datatype;<br>    <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;<br>    <span class="hljs-keyword">exports</span> com.itranswarp.sample;<br><br>    <span class="hljs-keyword">requires</span> java.base;<br><span class="hljs-keyword">requires</span> java.xml;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>1.面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合基础</title>
    <link href="/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/06/Core/Java/6.%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span>[] ss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 可以持有10个String对象</span><br>ss[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 可以放入String对象</span><br><span class="hljs-keyword">String</span> first = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 可以获取String对象</span><br></code></pre></td></tr></table></figure><p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p><ul><li>数组初始化后大小不可变；</li><li>数组只能按索引顺序存取。</li></ul><p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p><ul><li>可变大小的顺序链表；</li><li>保证无重复元素的集合；</li><li>…</li></ul><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li><li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li><li>还包括Queue等</li></ul><p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 只能放入String类型</span><br></code></pre></td></tr></table></figure><p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li><li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li><li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li></ul><p><img src="README.assets/image-20211222153755858.png" alt="image-20211222153755858"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><h2 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h2><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p><p><code>List</code>的行为和数组几乎完全相同：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从<code>0</code>开始。</p><p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;&#125;</code>中删除索引为<code>2</code>的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br>              │   │<br>          ┌───┘   │<br>          │   ┌───┘<br>          │   │<br>          ▼   ▼<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ D │ E │   │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>这个“删除”操作实际上是把<code>&#39;C&#39;</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p><p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个<code>ArrayList</code>拥有5个元素，实际数组大小为<code>6</code>（即有一个空位）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │   │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=6<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=6<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size=7<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p><p>我们考察<code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code>boolean add(E e)</code></li><li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li><li>删除指定索引的元素：<code>E remove(int index)</code></li><li>删除某个元素：<code>boolean remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li></ul><p>但是，实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。在<code>LinkedList</code>中，它的内部每个元素都指向下一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐<br>HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │<br>        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘<br></code></pre></td></tr></table></figure><p>我们来比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p><table><thead><tr><th align="left"></th><th align="left">ArrayList</th><th align="left">LinkedList</th></tr></thead><tbody><tr><td align="left">获取指定元素</td><td align="left">速度很快</td><td align="left">需要从头开始查找元素(越大越慢)</td></tr><tr><td align="left">添加元素到末尾</td><td align="left">速度很快</td><td align="left">速度很快</td></tr><tr><td align="left">在指定位置添加/删除</td><td align="left">需要移动元素</td><td align="left">不需要移动元素</td></tr><tr><td align="left">内存占用</td><td align="left">少</td><td align="left">较大(除了存储数据还需存储指针)</td></tr></tbody></table><p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p><h3 id="List的特点"><a href="#List的特点" class="headerlink" title="List的特点"></a>List的特点</h3><p>使用<code>List</code>时，我们要关注<code>List</code>接口的规范。<code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.add(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=2</span><br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// 允许重复添加元素，size=3</span><br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>List还允许添加null：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> class Main &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// size=2</span><br>        list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=3</span><br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">second</span> = list.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// null</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">second</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建List"><a href="#创建List" class="headerlink" title="创建List"></a>创建List</h3><p>除了使用<code>ArrayList</code>和<code>LinkedList</code>，我们还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>(java9:返回的是对象不可变列表,列表不可变,列表内的数据可能会变)：</p><p>在java8中的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>stringList = Collections.unmodifiableList(stringList);<span class="hljs-comment">//数据集不改变,数据可能会变</span><br></code></pre></td></tr></table></figure><p>java9中写法:返回不可变数据集</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">List</span>&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p><h3 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h3><p>和数组类型，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">String</span> s = list.<span class="hljs-built_in">get</span>(i);<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这种方式并不推荐，一是代码复杂，二是因为**<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。**</p><p><strong>所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code><strong>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。</strong><code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</strong></p><p><strong>即对于不同List,迭代器对象具有最高访问效率的实现</strong></p><p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;<span class="hljs-keyword">String</span>&gt; it = list.<span class="hljs-built_in">iterator</span>(); it.<span class="hljs-built_in">hasNext</span>(); ) &#123;<br>            <span class="hljs-keyword">String</span> s = it.<span class="hljs-built_in">next</span>();<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> s : list) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p><p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。</p><h3 id="List和Array转换"><a href="#List和Array转换" class="headerlink" title="List和Array转换"></a>List和Array转换</h3><p>把<code>List</code>变为<code>Array</code>有三种方法，第一种是调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; list = List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        Object[] array = list.<span class="hljs-built_in">toArray</span>();<br>        <span class="hljs-keyword">for</span> (Object s : array) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这种方法会丢失类型信息，所以实际应用很少。</strong></p><p>第二种方式是给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>]);<br>        <span class="hljs-keyword">for</span> (Integer n : array) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到这个<code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入<code>Number</code>类型的数组，返回的仍然是<code>Number</code>类型：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">import java.util.<span class="hljs-class">List;</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> class Main &#123;<br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br>        List&lt;Integer&gt; list = List.of(12, 34, 56);<br>        Number[]<span class="hljs-built_in"> array </span>= list.toArray(new Number[3]);<br>        for (Number n<span class="hljs-keyword"> :</span> array) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p><p>如果我们传入的数组大小和<code>List</code>实际的元素个数不一致怎么办？根据<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray(T[])">List接口</a>的文档，我们可以知道：</p><p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；<strong>如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>(int填0)。</strong></p><p>实际上，最常用的是传入一个“恰好”大小的数组：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= list.toArray(new Integer[list.size()]);<br></code></pre></td></tr></table></figure><p><strong>最后一种更简洁的写法是通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法</strong>：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= list.toArray(Integer[]::new);<br></code></pre></td></tr></table></figure><p>这种函数式写法我们会在后续讲到。</p><p>反过来，把<code>Array</code>变为<code>List</code>就简单多了，通过<code>List.of(T...)</code>方法最简单：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Integer[]<span class="hljs-built_in"> array </span>= &#123; 1, 2, 3 &#125;;<br>List&lt;Integer&gt; list = List.of(array);<br></code></pre></td></tr></table></figure><p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p><p>要注意的是，List.of(array)返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        list.add(<span class="hljs-number">999</span>); <span class="hljs-comment">// UnsupportedOperationException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造从start到end的序列：</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = <span class="hljs-number">20</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 随机删除List中的一个元素:</span><br>        <span class="hljs-keyword">int</span> removed = list.remove((<span class="hljs-keyword">int</span>) (Math.random() * list.size()));<br>        <span class="hljs-keyword">int</span> found = findMissingNumber(start, end, list);<br>        System.out.println(list.toString());<br>        System.out.println(<span class="hljs-string">&quot;missing number: &quot;</span> + found);<br>        System.out.println(removed == found ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMissingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) != start) &#123;<br>                <span class="hljs-keyword">return</span> start;<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>增强版：和上述题目一样，但整数不再有序，试找出缺失的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造从start到end的序列：</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = <span class="hljs-number">20</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 洗牌算法shuffle可以随机交换List中的元素位置:</span><br>        Collections.shuffle(list);<br>        <span class="hljs-comment">// 随机删除List中的一个元素:</span><br>        <span class="hljs-keyword">int</span> removed = list.remove((<span class="hljs-keyword">int</span>) (Math.random() * list.size()));<br>        <span class="hljs-keyword">int</span> found = findMissingNumber(start, end, list);<br>        System.out.println(list.toString());<br>        System.out.println(<span class="hljs-string">&quot;missing number: &quot;</span> + found);<br>        System.out.println(removed == found ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO </span><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMissingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, List&lt;Integer&gt; list)</span> </span>&#123;<br>         <span class="hljs-keyword">while</span>(start &lt;= end)&#123;<br>            <span class="hljs-keyword">if</span>(list.contains(start))&#123;<br>                start++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//还有一种方法  用等差数列求和公式,算出原集合和之后集合的差值</span><br> <span class="hljs-keyword">int</span> sum = (start + end) * (end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>              <span class="hljs-keyword">int</span> all = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">for</span>(Integer i:list) &#123;<br>                  all += i;<br>              &#125;<br>              <span class="hljs-keyword">return</span> sum - all;<br></code></pre></td></tr></table></figure><p><img src="%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80.assets/image-20211222204919210.png" alt="image-20211222204919210"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p><p>可以直接使用<code>for each</code>遍历<code>List</code>；</p><p><code>List</code>可以和<code>Array</code>相互转换。</p><h2 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h2><p>List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等，例如contains()方法可以实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> </span>&#123;<br>    Object[] elementData;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementData.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，要正确使用List的contains()、indexOf()这些方法，放入的实例必须正确覆写equals()方法，否则，放进去的实例，查找不到。我们之所以能正常放入String、Integer这些对象，是因为Java标准库定义的这些类已经正确实现了equals()方法。<br>我们以Person对象为例，测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; list = List.of(<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Ming&quot;</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Hong&quot;</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>)<br>        );<br>        System.out.println(list.contains(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外，虽然放入了new Person(“Bob”)，但是用另一个new Person(“Bob”)查询不到，原因就是Person类没有覆写equals()方法。</p><p>编写equals<br>如何正确编写equals()方法？equals()方法要求我们必须满足以下条件：</p><p><code>自反性（Reflexive）</code>：xex-&gt;xex  对于非null的x来说，x.equals(x)必须返回true,即；</p><p><code>对称性（Symmetric）</code>：xey-&gt;yex  对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true；</p><p><code>传递性（Transitive）</code>：xey,yez-&gt;xez   对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true；</p><p><code>一致性（Consistent）</code>：xey-&gt;xey   对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false；<br>对null的比较：即x.equals(null)永远返回false。</p><p>上述规则看上去似乎非常复杂，但其实代码实现equals()方法是很简单的，我们以Person类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们要定义“相等”的逻辑含义。对于Person类，如果name相等，并且age相等，我们就认为两个Person实例相等。</p><p>因此，编写equals()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用==。</p><p>如果this.name为null，那么equals()方法会报错，因此，需要继续改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">boolean</span> nameEquals = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name == <span class="hljs-keyword">null</span> &amp;&amp; p.name == <span class="hljs-keyword">null</span>) &#123;<br>            nameEquals = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name != <span class="hljs-keyword">null</span>) &#123;<br>            nameEquals = <span class="hljs-keyword">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nameEquals &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果Person有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用Objects.equals()静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(<span class="hljs-keyword">this</span>.name, p.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们总结一下equals()方法的正确编写方法：</p><p>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；<br>用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；<br>对引用类型用Objects.equals()比较，对基本类型直接用==比较。<br>使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。</p><p>如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。</p><p>注:lombok equalsAndHash注解会重写equals()和hashCode()</p><h2 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h2><p>重复放入key-value并不会有任何问题，但是一个key只能关联一个value。在上面的代码中，一开始我们把key对象”apple”映射到Integer对象123，然后再次调用put()方法把”apple”映射到789，这时，原来关联的value对象123就被“冲掉”了。实际上，put()方法的签名是V put(K key, V value)，如果放入的key已经存在，put()方法会返回被删除的旧的value，否则，返回null。</p><p> 始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。<br>此外，在一个Map中，虽然key不能重复，但value是可以重复的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">123</span>);<br>map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Map和List不同的是，Map存储的是key-value的映射关系，并且，它不保证顺序。在遍历的时候，遍历的顺序既不一定是put()时放入的key的顺序，也不一定是key的排序顺序。使用Map时，任何依赖顺序的逻辑都是不可靠的。以HashMap为例，假设我们放入”A”，”B”，”C”这3个key，遍历的时候，每个key会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！</p><p> 遍历Map时，不可假设输出的key是有序的！</p><p>注:想要有序用LinkedHashMap,它内部维护了一个双向链表</p><h2 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h2><p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p><p>以HashMap为例，观察下面的代码：</p><p>Map&lt;String, Person&gt; map = new HashMap&lt;&gt;();<br>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));<br>map.put(“c”, new Person(“Xiao Jun”));</p><p>map.get(“a”); // Person(“Xiao Ming”)<br>map.get(“x”); // null<br>HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引：</p><p>  ┌───┐<br>0 │   │<br>  ├───┤<br>1 │ ●─┼───&gt; Person(“Xiao Ming”)<br>  ├───┤<br>2 │   │<br>  ├───┤<br>3 │   │<br>  ├───┤<br>4 │   │<br>  ├───┤<br>5 │ ●─┼───&gt; Person(“Xiao Hong”)<br>  ├───┤<br>6 │ ●─┼───&gt; Person(“Xiao Jun”)<br>  ├───┤<br>7 │   │<br>  └───┘<br>如果key的值为”a”，计算得到的索引总是1，因此返回value为Person(“Xiao Ming”)，如果key的值为”b”，计算得到的索引总是5，因此返回value为Person(“Xiao Hong”)，这样，就不必遍历整个数组，即可直接读取key对应的value。</p><p>当我们使用key存取value的时候，就会引出一个问题：</p><p>我们放入Map的key是字符串”a”，但是，当我们获取Map的value时，传入的变量不一定就是放入的那个key对象。</p><p>换句话讲，两个key应该是内容相同，但不一定是同一个对象。测试代码如下：</p><p>import java.util.HashMap;<br>import java.util.Map;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String key1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(key1, <span class="hljs-number">123</span>);<br><br>        String key2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>);<br>        map.get(key2); <span class="hljs-comment">// 123</span><br><br>        System.out.println(key1 == key2); <span class="hljs-comment">// false</span><br>        System.out.println(key1.equals(key2)); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。</p><p>我们经常使用String作为key，因为String已经正确覆写了equals()方法。但如果我们放入的key是一个自己写的类，就必须保证正确覆写了equals()方法。</p><p>我们再思考一下HashMap为什么能通过key直接计算出value存储的索引。相同的key对象（使用equals()判断时返回true）必须要计算出相同的索引，否则，相同的key每次取出的value就不一定对。</p><p>通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。</p><p>因此，正确使用Map必须保证：</p><p>作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true；</p><p>作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：</p><p>如果两个对象相等，则两个对象的hashCode()必须相等；<br>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。<br>即对应两个实例a和b：</p><p>如果a和b相等，那么a.equals(b)一定为true，则a.hashCode()必须等于b.hashCode()；<br>如果a和b不相等，那么a.equals(b)一定为false，则a.hashCode()和b.hashCode()尽量不要相等。<br>上述第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。</p><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。</p><p>正确编写equals()的方法我们已经在编写equals方法一节中讲过了，以Person类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String firstName;<br>    String lastName;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>把需要比较的字段找出来：</p><p>firstName<br>lastName<br>age<br>然后，引用类型使用Objects.equals()比较，基本类型使用==比较。</p><p>在正确实现equals()的基础上，我们还需要正确实现hashCode()，即上述3个字段分别相同的实例，hashCode()返回的int必须相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String firstName;<br>    String lastName;<br>    <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>        h = <span class="hljs-number">31</span> * h + firstName.hashCode();<br>        h = <span class="hljs-number">31</span> * h + lastName.hashCode();<br>        h = <span class="hljs-number">31</span> * h + age;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到String类已经正确实现了hashCode()方法，我们在计算Person的hashCode()时，反复使用31*h，这样做的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围。</p><p>和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.hash()来计算：</p><p>int hashCode() {<br>    return Objects.hash(firstName, lastName, age);<br>}<br>所以，编写equals()和hashCode()遵循的原则是：</p><p>equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。</p><p>另外注意，对于放入HashMap的value对象，没有任何要求。</p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>既然HashMap内部使用了数组，通过计算key的hashCode()直接定位value所在的索引，那么第一个问题来了：hashCode()返回的int范围高达±21亿，先不考虑负数，HashMap内部使用的数组得有多大？</p><p>实际上HashMap初始化时默认的数组大小只有16，任何key，无论它的hashCode()有多大，都可以简单地通过：</p><p>int index = key.hashCode() &amp; 0xf; // 0xf = 15<br>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>第二个问题：如果添加超过16个key-value到HashMap，数组不够用了怎么办？</p><p>添加超过一定数量的key-value时，HashMap会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。例如，对长度为32的数组计算hashCode()对应的索引，计算方式要改为：</p><p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31<br>由于扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大。如果我们确定要使用一个容量为10000个key-value的HashMap，更好的方式是创建HashMap时就指定容量：</p><p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);<br>虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。</p><p>最后一个问题：如果不同的两个key，例如”a”和”b”，它们的hashCode()恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求hashCode()尽量不相等），那么，当我们放入：</p><p>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));<br>时，由于计算出的数组索引相同，后面放入的”Xiao Hong”会不会把”Xiao Ming”覆盖了？</p><p>当然不会！使用Map的时候，只要key不相同，它们映射的value就互不干扰。但是，在HashMap内部，确实可能存在不同的key，映射到相同的hashCode()，即相同的数组索引上，肿么办？</p><p>我们就假设”a”和”b”这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是”a”的映射，一个是”b”的映射：</p><p>  ┌───┐<br>0 │   │<br>  ├───┤<br>1 │   │<br>  ├───┤<br>2 │   │<br>  ├───┤<br>3 │   │<br>  ├───┤<br>4 │   │<br>  ├───┤<br>5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;<br>  ├───┤<br>6 │   │<br>  ├───┤<br>7 │   │<br>  └───┘<br>在查找的时候，例如：</p><p>Person p = map.get(“a”);<br>HashMap内部通过”a”找到的实际上是List&lt;Entry&lt;String, Person&gt;&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是”a”，才能返回对应的Person实例。</p><p><code>我们把不同的key具有相同的hashCode()的情况称之为哈希冲突</code>。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二：</p><p> 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。<br>hashCode()方法编写得越好，HashMap工作的效率就越高。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>要正确使用HashMap，作为key的类必须正确覆写equals()和hashCode()方法；</p><p>一个类如果覆写了equals()，就必须覆写hashCode()，并且覆写规则是：</p><p>如果equals()返回true，则hashCode()返回值必须相等；</p><p>如果equals()返回false，则hashCode()返回值尽量不要相等。</p><p>实现hashCode()方法可以通过Objects.hashCode()辅助方法实现。</p><p>`<br>hashmap中依据key的hash值来确定value存储位置，所以一定要重写hashCode方法，而重写equals方法，是为了解决hash冲突，如果两个key的hash值相同，就会调用equals方法，比较key值是否相同，在存储时：如果equals结果相同就覆盖更新value值，如果不同就用List他们都存储起来。在取出来是：如果equals结果相同就返回当前value值，如果不同就遍历List中下一个元素。即要key与hash同时匹配才会认为是同一个key。</p><p>JDK中源码:if(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))){ops;}<br>`</p><h2 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h2><p>因为HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。</p><p>如果作为<code>key的对象是enum类型</code>，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。</p><p>我们以DayOfWeek这个枚举类型为例，为它做一个“翻译”功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.DayOfWeek;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;DayOfWeek, String&gt; map = <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);<br>        map.put(DayOfWeek.MONDAY, <span class="hljs-string">&quot;星期一&quot;</span>);<br>        map.put(DayOfWeek.TUESDAY, <span class="hljs-string">&quot;星期二&quot;</span>);<br>        map.put(DayOfWeek.WEDNESDAY, <span class="hljs-string">&quot;星期三&quot;</span>);<br>        map.put(DayOfWeek.THURSDAY, <span class="hljs-string">&quot;星期四&quot;</span>);<br>        map.put(DayOfWeek.FRIDAY, <span class="hljs-string">&quot;星期五&quot;</span>);<br>        map.put(DayOfWeek.SATURDAY, <span class="hljs-string">&quot;星期六&quot;</span>);<br>        map.put(DayOfWeek.SUNDAY, <span class="hljs-string">&quot;星期日&quot;</span>);<br>        System.out.println(map);<br>        System.out.println(map.get(DayOfWeek.MONDAY));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。</p><p>小结<br>如果Map的key是enum类型，推荐使用EnumMap，既保证速度，也不浪费空间。</p><p>使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。</p><h2 id="使用TreeMap"><a href="#使用TreeMap" class="headerlink" title="使用TreeMap"></a>使用TreeMap</h2><p>我们已经知道，HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。</p><p>还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。注意到SortedMap是接口，它的实现类是<code>TreeMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">       ┌───┐<br>       │Map│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>                ▲<br>                │<br>          ┌─────────┐<br>          │ TreeMap │<br>          └─────────┘<br><br></code></pre></td></tr></table></figure><p>SortedMap保证遍历时以Key的顺序来进行排序。例如，放入的Key是”apple”、”pear”、”orange”，遍历的顺序一定是”apple”、”orange”、”pear”，因为String默认按字母排序</p><p>使用TreeMap时，放入的Key必须实现<code>Comparable</code>接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。<code>作为Value的对象则没有任何要求</code>。</p><p><code>如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Person key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        <span class="hljs-comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span><br>        System.out.println(map.get(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    Person(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;Person: &quot;</span> + name + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果a&lt;b，则返回负数，通常是-1，如果a==b，则返回0，如果a&gt;b，则返回正数，通常是1。TreeMap内部根据比较结果对Key进行排序。</p><p>从上述代码执行结果可知，打印的Key确实是按照Comparator定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个new Person(“Bob”)作为Key，它会返回对应的Integer值2。</p><p>另外，注意到Person类并未覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。</p><p>我们来看一个稍微复杂的例子：这次我们定义了Student类，并用分数score进行排序，高分在前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Student, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">77</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">66</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">99</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Student key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        System.out.println(map.get(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">66</span>))); <span class="hljs-comment">// null?</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> score;<br>    Student(String name, <span class="hljs-keyword">int</span> score) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在for循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的Key：new Student(“Bob”, 66)进行查找时，结果为null！</p><p>这是怎么肥四？难道TreeMap有问题？遇到TreeMap工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p><p>在这个例子中，TreeMap出现问题，原因其实出在这个Comparator上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在p1.score和p2.score不相等的时候，它的返回值是正确的，但是，在p1.score和p2.score相等的时候，它并没有返回0！这就是为什么TreeMap工作不正常的原因：TreeMap在比较两个Key是否相等时，依赖Key的compareTo()方法或者Comparator.compare()方法。在两个Key相等时，必须返回0。因此，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p1.score == p2.score) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者直接借助Integer.compare(int, int)也可以返回正确的比较结果。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>SortedMap在遍历时严格按照Key的顺序遍历，最常用的实现类是TreeMap；</p><p>作为SortedMap的Key必须实现Comparable接口，或者传入Comparator；</p><p>要严格按照compare()规范实现比较逻辑，否则，TreeMap将不能正常工作。</p><h2 id="使用Properties"><a href="#使用Properties" class="headerlink" title="使用Properties"></a>使用Properties</h2><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># 上次最后打开的文件:<br>last_open_file=/data/hello.txt<br># 自动保存文件的时间间隔:<br>auto_save_interval=<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>配置文件的特点是，它的Key-Value一般都是String-String类型的，因此我们完全可以用Map&lt;String, String&gt;来表示它。</p><p>因为配置文件非常常用，所以Java集合库提供了一个Properties来表示一组“配置”。<code>由于历史遗留原因</code>，Properties内部本质上是一个<code>Hashtable</code>，但我们只需要用到Properties自身关于读写配置的接口。</p><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>用Properties读取配置文件非常简单。Java默认配置文件以.properties为扩展名，每行以key=value表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"># setting.properties<br>last_open_file=/data/hello.txt<br>auto_save_interval=<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>可以从文件系统读取这个.properties文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>String f = <span class="hljs-string">&quot;setting.properties&quot;</span>;<br>props.load(<span class="hljs-keyword">new</span> java.io.FileInputStream(f));<span class="hljs-comment">//从文件流加载配置文件</span><br><br>String filepath = props.getProperty(<span class="hljs-string">&quot;last_open_file&quot;</span>);<br>String interval = props.getProperty(<span class="hljs-string">&quot;auto_save_interval&quot;</span>, <span class="hljs-string">&quot;120&quot;</span>);<span class="hljs-comment">//默认值120s</span><br></code></pre></td></tr></table></figure><p>可见，用Properties读取配置文件，一共有三步：</p><p>1.创建Properties实例；<br>2.调用load()读取文件；<br>3.调用getProperty()获取配置。<br>4.调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p><p><code>也可以从classpath读取.properties文件，因为load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>试试从内存读取一个字节流(用ByteArrayStream,读取用input,输出用output)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// properties</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String settings = <span class="hljs-string">&quot;# test&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;course=Java&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;<br>        ByteArrayInputStream input = <span class="hljs-keyword">new</span> ByteArrayInputStream(settings.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>)); <span class="hljs-comment">//ByteArrayInputStream从内存中读取</span><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        props.load(input);<br><br>        System.out.println(<span class="hljs-string">&quot;course: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;course&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;last_open_date&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;last_open_file&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;auto_save&quot;</span>, <span class="hljs-string">&quot;60&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有多个.properties文件，可以反复调用load()读取，后读取的key-value会覆盖已读取的key-value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br>props.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面的代码演示了Properties的一个常用用法：<code>可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</code></p><p>Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，<code>不要去调用这些从Hashtable继承下来的方法</code>。</p><h3 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h3><p>如果通过setProperty()修改了Properties实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.setProperty(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;http://www.liaoxuefeng.com&quot;</span>);<br>props.setProperty(<span class="hljs-string">&quot;language&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>props.store(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="hljs-string">&quot;这是写入的properties注释&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>早期版本的Java规定.properties文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用name=\u4e2d\u6587来表示，非常别扭。从<code>JDK9</code>开始，Java的.properties文件可以使用UTF-8编码了。</p><p>不过，需要注意的是，由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法load(Reader)读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure><p>就可以正常读取中文。<code>InputStream和Reader的区别是一个是字节流，一个是字符流。</code>字符流在内存中已经以char类型表示了，不涉及编码问题。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Java集合库提供的Properties用于读写配置文件.properties。.properties文件可以使用UTF-8编码。</p><p>可以从文件系统、classpath或其他任何地方读取.properties文件。</p><p>读写Properties时，注意仅使用getProperty()和setProperty()方法，不要调用继承而来的get()和put()等方法。</p><h2 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h2><p>我们知道，Map用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写equals()方法，还要正确覆写hashCode()方法。</p><p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。</p><p>Set用于存储不重复的元素集合，它主要提供以下几个方法：<br>将元素添加进Set<E>：boolean add(E e)<br>将元素从Set<E>删除：boolean remove(Object e)<br>判断是否包含元素：boolean contains(Object e)<br>我们来看几个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        System.out.println(set.add(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// false，添加失败，因为元素已存在</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// true，元素存在</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;XYZ&quot;</span>)); <span class="hljs-comment">// false，元素不存在</span><br>        System.out.println(set.remove(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// false，删除失败，因为元素不存在</span><br>        System.out.println(set.size()); <span class="hljs-comment">// 2，一共两个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。</p><p>因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。</p><p>最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 持有一个HashMap:</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 放入HashMap的value:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.remove(o) == PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Set接口并不保证有序，而SortedSet接口则保证元素是有序的：</p><p>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；<br>TreeSet是有序的，因为它实现了SortedSet接口。<br>用一张图表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">      ┌───┐<br>       │Set│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeSet │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p>我们来看HashSet的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意输出的顺序既不是添加的顺序，也不是String排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p><p>把HashSet换成TreeSet，在遍历TreeSet时，输出就是有序的，这个顺序是元素的排序顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用TreeSet和使用TreeMap的要求一样，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象。</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用Set去除重复的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>            <span class="hljs-comment">// Arrays.asList生成的List用的是ArrayList in Arrays,不能增删和修改,也不能修改原数组,否则List数值会变</span><br><span class="hljs-comment">//            List&lt;Message&gt; received = Arrays.asList(</span><br><span class="hljs-comment">//                new Message(1, &quot;Hello!&quot;),</span><br><span class="hljs-comment">//                        new Message(2, &quot;发工资了吗？&quot;),</span><br><span class="hljs-comment">//                        new Message(2, &quot;发工资了吗？&quot;),</span><br><span class="hljs-comment">//                        new Message(3, &quot;去哪吃饭？&quot;),</span><br><span class="hljs-comment">//                        new Message(3, &quot;去哪吃饭？&quot;),</span><br><span class="hljs-comment">//                        new Message(4, &quot;Bye&quot;)</span><br><span class="hljs-comment">//            );</span><br>            List&lt;Message&gt; received = <span class="hljs-keyword">new</span> ArrayList&lt;Message&gt;()&#123;&#123;<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello!&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;发工资了吗？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;发工资了吗？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;去哪吃饭？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;去哪吃饭？&quot;</span>));<br>                    add(<span class="hljs-keyword">new</span> Message(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Bye&quot;</span>));<br>            &#125;&#125;;<br><br>            List&lt;Message&gt; displayMessages = process(received);<br>            <span class="hljs-keyword">for</span> (Message message : displayMessages) &#123;<br>                System.out.println(message.text);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Message&gt; <span class="hljs-title">process</span><span class="hljs-params">(List&lt;Message&gt; received)</span> </span>&#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 按sequence去除重复消息</span><br>            <span class="hljs-comment">// TreeSet默认加的是String,如果不写比较类,元素Message就要实现Comparable接口</span><br>            TreeSet&lt;Message&gt; msgTreeSet = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((o1, o2) -&gt; &#123;<br>                <span class="hljs-keyword">if</span>(o1.sequence == o2.sequence &amp;&amp; Objects.equals(o1.text,o2.text))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> o1.sequence &gt; o2.sequence? <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>            &#125;);<br><span class="hljs-comment">//            Iterator&lt;Message&gt; iterator = received.iterator();</span><br><span class="hljs-comment">//            while (iterator.hasNext())&#123;</span><br><span class="hljs-comment">//                Message msg = iterator.next();</span><br><span class="hljs-comment">//                if(!msgTreeSet.add(msg))&#123;</span><br><span class="hljs-comment">//                iterator.remove();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br>            msgTreeSet.addAll(received);<br>           <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(msgTreeSet);<br><span class="hljs-comment">//            return received;</span><br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Message&gt; <span class="hljs-title">process</span><span class="hljs-params">(List&lt;Message&gt; received)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 按sequence去除重复消息</span><br>        <span class="hljs-keyword">return</span> received;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sequence;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String text;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequence, String text)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sequence = sequence;<br>        <span class="hljs-keyword">this</span>.text = text;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>Set用于存储不重复的元素集合：</p><p>放入HashSet的元素与作为HashMap的key要求相同；<br>放入TreeSet的元素与作为TreeMap的Key要求相同；<br>利用Set可以去除重复元素；</p><p>遍历SortedSet按照元素的排序顺序遍历，也可以自定义排序算法。</p><h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><p>队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p><p>把元素添加到队列末尾；<br>从队列头部取出元素。<br>超市的收银台就是一个队列：</p><h3 id="Queue-头删尾插-java中通常用LinkedList实现"><a href="#Queue-头删尾插-java中通常用LinkedList实现" class="headerlink" title="Queue(头删尾插,java中通常用LinkedList实现)"></a>Queue(头删尾插,java中通常用LinkedList实现)</h3><p>在Java的标准库中，队列接口Queue定义了以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>：获取队列长度；</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E)</span>/<span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E)</span>：添加元素到队尾；</span><br><span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span>/E <span class="hljs-title">poll</span><span class="hljs-params">()</span>：获取队首元素并从队列中删除；</span><br><span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span>/E <span class="hljs-title">peek</span><span class="hljs-params">()</span>：获取队首元素但并不从队列中删除。</span><br><span class="hljs-function">对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</span><br><span class="hljs-function">throw Exception返回<span class="hljs-keyword">false</span>或<span class="hljs-keyword">null</span></span><br><span class="hljs-function">添加元素到队尾<span class="hljs-title">add</span><span class="hljs-params">(E e)</span><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span><br><span class="hljs-function">取队首元素并删除E <span class="hljs-title">remove</span><span class="hljs-params">()</span>E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队首元素但不删除E <span class="hljs-title">element</span><span class="hljs-params">()</span>E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    q.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们调用offer()方法来添加元素，当添加失败时，它不会抛异常，而是返回false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">if</span> (q.offer(<span class="hljs-string">&quot;Apple&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要从Queue中取出队首元素时，如果当前Queue是一个空队列，调用remove()方法，它会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    String s = q.remove();<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们调用poll()方法来取出队首元素，当获取失败时，它不会抛异常，而是返回null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; q = ...<br>String s = q.poll();<br><span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，两套方法可以根据需要来选择使用。</p><p>注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。</p><p>接下来我们以poll()和peek()为例来说说“获取并删除”与“获取但不删除”的区别。对于Queue来说，每次调用poll()，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 从队列取出元素:</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列是空的</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果用peek()，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 队首永远都是apple，因为peek()不会删除它:</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从上面的代码中，我们还可以发现，LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个List:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-comment">// 这是一个Queue:</span><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br></code></pre></td></tr></table></figure><p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>队列Queue实现了一个先进先出（FIFO）的数据结构：</p><p>通过add()/offer()方法将元素添加到队尾；<br>通过remove()/poll()从队首获取元素并删除；<br>通过element()/peek()从队首获取元素但不删除。<br>要避免把null添加到队列。</p><h2 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h2><p>我们知道，Queue是一个先进先出（FIFO）的队列。</p><p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p><p>可以每个人先取一个号，例如：A1、A2、A3……然后，按照号码顺序依次办理，实际上这就是一个Queue。</p><p>如果这时来了一个VIP客户，他的号码是V1，虽然当前排队的是A10、A11、A12……但是柜台下一个呼叫的客户号码却是V1。</p><p>这个时候，我们发现，要实现“VIP插队”的业务，用Queue就不行了，因为Queue会严格按FIFO的原则取出队首元素。我们需要的是优先队列：PriorityQueue。</p><p>PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。</p><p>要使用PriorityQueue，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看PriorityQueue的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们放入的顺序是”apple”、”pear”、”banana”，但是取出的顺序却是”apple”、”banana”、”pear”，这是因为从字符串的排序看，”apple”排在最前面，”pear”排在最后面。</p><p>因此，放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。</p><p>如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个PriorityQueue：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> UserComparator());<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A10&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>        System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br>           <span class="hljs-keyword">if</span>( u1.number.length() == u2.number.length())&#123;<br>                <span class="hljs-keyword">return</span> u1.number.compareTo(u2.number) ;<br>             &#125;<br>                <span class="hljs-keyword">return</span> u1.number.length() &gt; u2.number.length() ? <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>            <span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现PriorityQueue的关键在于提供的UserComparator对象，它负责比较两个元素的大小（较小的在前）。UserComparator总是把V开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p><p>上面的UserComparator的比较逻辑其实还是有问题的，它会把A10排在A2的前面，请尝试修复该错误。</p><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>PriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</p><p>PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）。</p><h2 id="双端队列Deque（Double-Ended-Queue）"><a href="#双端队列Deque（Double-Ended-Queue）" class="headerlink" title="双端队列Deque（Double Ended Queue）"></a>双端队列Deque（Double Ended Queue）</h2><p>我们知道，Queue是队列，只能一头进，另一头出。</p><p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。</p><p>Java集合提供了接口Deque来实现一个双端队列，它的功能是：</p><p>既可以添加到队尾，也可以添加到队首；<br>既可以从队首获取，又可以从队尾获取。<br>我们来比较一下Queue和Deque出队和入队的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">QueueDeque<br>添加元素到队尾add(E e) / offer(E e)addLast(E e) / offerLast(E e)<br>取队首元素并删除<span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span> / E <span class="hljs-title">poll</span><span class="hljs-params">()</span>E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> / E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队首元素但不删除E <span class="hljs-title">element</span><span class="hljs-params">()</span> / E <span class="hljs-title">peek</span><span class="hljs-params">()</span>E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> / E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">添加元素到队首无<span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> / <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span><br><span class="hljs-function">取队尾元素并删除无E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> / E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">取队尾元素但不删除无E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> / E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">对于添加元素到队尾的操作，Queue提供了<span class="hljs-title">add</span><span class="hljs-params">()</span>/<span class="hljs-title">offer</span><span class="hljs-params">()</span>方法，而Deque提供了<span class="hljs-title">addLast</span><span class="hljs-params">()</span>/<span class="hljs-title">offerLast</span><span class="hljs-params">()</span>方法。添加元素到对首、取队尾元素的操作在Queue中不存在，在Deque中由<span class="hljs-title">addFirst</span><span class="hljs-params">()</span>/<span class="hljs-title">removeLast</span><span class="hljs-params">()</span>等方法提供。</span><br></code></pre></td></tr></table></figure><p>注意到Deque接口实际上扩展自Queue：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因此，Queue提供的add()/offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        deque.offerLast(<span class="hljs-string">&quot;A&quot;</span>); <span class="hljs-comment">// A</span><br>        deque.offerLast(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// A &lt;- B</span><br>        deque.offerFirst(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// C &lt;- A &lt;- B</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// C, 剩下A &lt;- B</span><br>        System.out.println(deque.pollLast()); <span class="hljs-comment">// B, 剩下A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果直接写deque.offer()，我们就需要思考，offer()实际上是offerLast()，我们明确地写上offerLast()，不需要思考就能一眼看出这是添加到队尾。</p><p>因此，使用Deque，推荐总是明确调用offerLast()/offerFirst()或者pollFirst()/pollLast()方法。</p><p>Deque是一个接口，它的实现类有ArrayDeque和LinkedList。</p><p>我们发现LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><p>// 不推荐的写法:<br>LinkedList<String> d1 = new LinkedList&lt;&gt;();<br>d1.offerLast(“z”);<br>// 推荐的写法：<br>Deque<String> d2 = new LinkedList&lt;&gt;();<br>d2.offerLast(“z”);<br>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>Deque实现了一个双端队列（Double Ended Queue），它可以：</p><p>将元素添加到队尾或队首：addLast()/offerLast()/addFirst()/offerFirst()；<br>从队首／队尾获取元素并删除：removeFirst()/pollFirst()/removeLast()/pollLast()；<br>从队首／队尾获取元素但不删除：getFirst()/peekFirst()/getLast()/peekLast()；<br>总是调用xxxFirst()/xxxLast()以便与Queue的方法区分开；<br>避免把null添加到队列。</p><h2 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p><p>什么是LIFO呢？我们先回顾一下Queue的特点FIFO：</p><div class="code-wrapper"><pre><code class="hljs">      ────────────────────────</code></pre></div><p>  ((\      ((\    ((\    ((\      ((<br> (=’.’) ─&gt; (=’.’)  (=’.’)  (=’.’) ─&gt; (=’.’)<br>O(<em>“)”)   O(</em>“)”) O(<em>“)”) O(</em>“)”)   O(_”)”)<br>          ────────────────────────<br>所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进Stack的元素一定最早出Stack。如何做到这一点呢？只需要把队列的一端封死：</p><div class="code-wrapper"><pre><code class="hljs">       ───────────────────────────────┐</code></pre></div><p>  ((\       ((\    ((\    ((\    ((\ │<br> (=’.’) &lt;─&gt; (=’.’)  (=’.’)  (=’.’)  (=’.’)│<br>O(<em>“)”)    O(</em>“)”) O(<em>“)”) O(</em>“)”) O(_”)”)│<br>           ───────────────────────────────┘<br>因此，Stack是这样一种数据结构：只能不断地往Stack中压入（push）元素，最后进去的必须最早弹出（pop）来：</p><p>Stack只有入栈和出栈的操作：</p><p>把元素压栈：<code>push(E)</code>；<br>把栈顶的元素“弹出”：<code>pop()</code>；<br>取栈顶元素但不弹出：<code>peek()</code>。<br>在Java中，我们用Deque可以实现Stack的功能：</p><p>把元素压栈：<code>push(E)/addFirst(E)</code>；<br>把栈顶的元素“弹出”：<code>pop()/removeFirst()</code>；<br>取栈顶元素但不弹出：<code>peek()/peekFirst()</code>。<br>为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。</p><p>当我们把Deque作为Stack使用时，注意只调用<code>push()/pop()/peek()</code>方法，不要调用<code>addFirst()/removeFirst()/peekFirst()</code>方法，这样代码更加清晰。</p><h3 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h3><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    foo(<span class="hljs-number">123</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">foo</span><span class="hljs-params">(x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;F-&quot;</span> + bar(x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p><p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发StackOverflowError：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试无限递归调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        increase(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">increase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> increase(x) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h3><p>我们再来看一个Stack的用途：对整数进行进制的转换就可以利用栈。</p><p>例如，我们要把一个int整数12500转换为十六进制表示的字符串，如何实现这个功能？</p><p>首先我们准备一个空栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后计算12500÷16=781…4，余数是4，把余数4压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算781÷16=48…13，余数是13，13的十六进制用字母D表示，把余数D压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算48÷16=3…0，余数是0，把余数0压栈：</p><p>│   │<br>│   │<br>│   │<br>│ 0 │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>最后计算3÷16=0…3，余数是3，把余数3压栈：</p><p>│    │<br>│ 3 │<br>│    │<br>│ 0 │<br>│    │<br>│ D │<br>│    │<br>│ 4    │<br>└───┘<br>当商是0的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串30D4，这就是十进制整数12500的十六进制表示的字符串。</p><h3 id="计算中缀表达式"><a href="#计算中缀表达式" class="headerlink" title="计算中缀表达式"></a>计算中缀表达式</h3><p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：1 + 2 * (9 - 5)。</p><p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：1 2 9 5 - * +。</p><p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p><p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后我们依次扫描后缀表达式1 2 9 5 - * +，遇到数字1，就直接扔到栈里：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 1 │<br>└───┘<br>紧接着，遇到数字2，9，5，也扔到栈里：</p><p>│   │<br>│ 5 │<br>│   │<br>│ 9 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到减号时，弹出栈顶的两个元素，并计算9-5=4，把结果4压栈：</p><p>│   │<br>│   │<br>│   │<br>│ 4 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到<em>号时，弹出栈顶的两个元素，并计算2</em>4=8，把结果8压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 8 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到+号时，弹出栈顶的两个元素，并计算1+8=9，把结果9压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 9 │<br>└───┘<br>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果9。</p><h3 id="练习-用双端队列Deque模拟栈-只用push-pop-peek-方法"><a href="#练习-用双端队列Deque模拟栈-只用push-pop-peek-方法" class="headerlink" title="练习:用双端队列Deque模拟栈(只用push(),pop(),peek()方法)"></a>练习:用双端队列Deque模拟栈(只用push(),pop(),peek()方法)</h3><p>请利用Stack把一个给定的整数转换为十六进制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转十六进制</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String hex = toHex(<span class="hljs-number">12500</span>);<br>        <span class="hljs-keyword">if</span> (hex.equalsIgnoreCase(<span class="hljs-string">&quot;30D4&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试通过&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String hex = toHex(<span class="hljs-number">12500</span>);<br>        <span class="hljs-keyword">if</span> (hex.equalsIgnoreCase(<span class="hljs-string">&quot;30D4&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试通过&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;测试失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  Deque&lt;Character&gt; dq = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            dq.push(Character.forDigit(n % <span class="hljs-number">16</span>, <span class="hljs-number">16</span>));<br>            n /= <span class="hljs-number">16</span>;<br>        &#125;<br>        String s = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (dq.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            s += dq.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="进阶练习-中缀转后缀-："><a href="#进阶练习-中缀转后缀-：" class="headerlink" title="进阶练习(中缀转后缀)："></a>进阶练习(中缀转后缀)：</h3><h4 id="手工方法"><a href="#手工方法" class="headerlink" title="手工方法"></a>手工方法</h4><ol><li>按先加减后乘除的原则给表达式加括号</li></ol><blockquote><p>结果：((a+(b<em>c))+(((d</em>e)+f)*g))```</p></blockquote><p>2 .由内到外把每个括号里的表达式换成后缀</p><blockquote><p>最终结果：abc*+de<em>f+g</em>+</p></blockquote><h4 id="代码实现-借助栈"><a href="#代码实现-借助栈" class="headerlink" title="代码实现(借助栈)"></a>代码实现(借助栈)</h4><blockquote><p>从左到右开始扫描中缀表达式<br>遇到数字， 直接输出<br>遇到运算符<br>a. 若为“(” 直接入栈<br>b. 若为“)” 将符号栈中的元素依次出栈并输出, 直到 “(“, “(“只出栈, 不输出<br>c. 若为其他符号, 将符号栈中的元素依次出栈并输出, 直到遇到比当前符号优先级更低的符号或者”(“。 将当前符号入栈。扫描完后, 将栈中剩余符号依次输出</p></blockquote><p>请利用Stack把字符串中缀表达式编译为后缀表达式，然后再利用栈执行后缀表达式获得计算结果：</p><p>// 高难度练习，慎重选择！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String exp = <span class="hljs-string">&quot;1 + 2 * (9 - 5)&quot;</span>;<br>        SuffixExpression se = compile(exp);<br>        <span class="hljs-keyword">int</span> result = se.execute();<br>        System.out.println(exp + <span class="hljs-string">&quot; = &quot;</span> + result + <span class="hljs-string">&quot; &quot;</span> + (result == <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">9</span> - <span class="hljs-number">5</span>) ? <span class="hljs-string">&quot;✓&quot;</span> : <span class="hljs-string">&quot;✗&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> SuffixExpression <span class="hljs-title">compile</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuffixExpression();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuffixExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进阶练习2："><a href="#进阶练习2：" class="headerlink" title="进阶练习2："></a>进阶练习2：</h3><p>请把带变量的中缀表达式编译为后缀表达式，执行后缀表达式时，传入变量的值并获得计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String exp = <span class="hljs-string">&quot;x + 2 * (y - 5)&quot;</span>;<br>        SuffixExpression se = compile(exp);<br>        Map&lt;String, Integer&gt; env = Map.of(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">9</span>);<br>        <span class="hljs-keyword">int</span> result = se.execute(env);<br>        System.out.println(exp + <span class="hljs-string">&quot; = &quot;</span> + result + <span class="hljs-string">&quot; &quot;</span> + (result == <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">9</span> - <span class="hljs-number">5</span>) ? <span class="hljs-string">&quot;✓&quot;</span> : <span class="hljs-string">&quot;✗&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> SuffixExpression <span class="hljs-title">compile</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuffixExpression();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuffixExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(Map&lt;String, Integer&gt; env)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p><p>把元素压栈：push(E)；<br>把栈顶的元素“弹出”：pop(E)；<br>取栈顶元素但不弹出：peek(E)。<br>在Java中，我们用Deque可以实现Stack的功能，注意只调用push()/pop()/peek()方法，避免调用Deque的其他方法。</p><p>最后，不要使用遗留类Stack。</p><h2 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h2><p>Java的集合类都可以使用for each循环，List、Set和Queue会迭代每个元素，Map会迭代每个key。以List为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>     String s = it.next();<br>     System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把这种通过Iterator对象遍历集合的模式称为迭代器。</p><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p><p>例如，我们虽然知道ArrayList在内部是以数组形式存储元素，并且，它还提供了get(int)方法。虽然我们可以用for循环遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    Object value = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。</p><p><code>用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。</code></p><p>如果我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件：</p><p>集合类实现Iterable接口，该接口要求返回一个Iterator对象；<br>用Iterator对象迭代集合内部数据。</p><p>这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。</p><p>一个简单的Iterator示例如下，它总是以倒序遍历集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReverseList&lt;String&gt; rlist = <span class="hljs-keyword">new</span> ReverseList&lt;&gt;();<br>        rlist.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Orange&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Pear&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : rlist) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        list.add(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReverseIterator(list.size());<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> index;<br><br>        ReverseIterator(<span class="hljs-keyword">int</span> index) &#123;<br>            <span class="hljs-keyword">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            index--;<br>            <span class="hljs-keyword">return</span> ReverseList.<span class="hljs-keyword">this</span>.list.get(index);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然ReverseList和ReverseIterator的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按for each循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p><p>在编写Iterator的时候，我们通常可以用一个内部类来实现Iterator接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类ReverseIterator可以用ReverseList.this获得当前外部类的this引用，然后，通过这个this引用就可以访问ReverseList的所有字段和方法。</p><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>Iterator是一种抽象的数据访问模型。使用Iterator模式进行迭代的好处有：</p><p>对任何集合都采用同一种访问模型；<br>调用者对集合内部结构一无所知；<br>集合类返回的Iterator对象知道如何迭代。<br>Java提供了标准的迭代器模型，即集合类实现java.util.Iterable接口，返回java.util.Iterator实例。</p><h2 id="使用Collections"><a href="#使用Collections" class="headerlink" title="使用Collections"></a>使用Collections</h2><p>Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。</p><p> 注意Collections结尾多了一个s，不是Collection！<br>我们一般看方法名和参数就可以确认Collections提供的该方法的功能。例如，对于以下静态方法：</p><p>public static boolean addAll(Collection&lt;? super T&gt; c, T… elements) { … }<br>addAll()方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。</p><h3 id="创建空集合-不可变集合"><a href="#创建空集合-不可变集合" class="headerlink" title="创建空集合(不可变集合)"></a>创建空集合(不可变集合)</h3><p>Collections提供了一系列方法来创建空集合：</p><p>创建空List：List<T> emptyList()<br>创建空Map：Map&lt;K, V&gt; emptyMap()<br>创建空Set：Set<T> emptySet()<br>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p><p>此外，也可以用各个集合接口提供的of(T…)方法创建空集合。例如，以下创建空List的两个方法是等价的：</p><p>List<String> list1 = List.of();<br>List<String> list2 = Collections.emptyList();</p><h3 id="创建单元素集合-不可变"><a href="#创建单元素集合-不可变" class="headerlink" title="创建单元素集合(不可变)"></a>创建单元素集合(不可变)</h3><p>Collections提供了一系列方法来创建一个单元素集合：</p><p>创建一个元素的List：List<T> singletonList(T o)<br>创建一个元素的Map：Map&lt;K, V&gt; singletonMap(K key, V value)<br>创建一个元素的Set：Set<T> singleton(T o)<br>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p><p>此外，也可以用各个集合接口提供的of(T…)方法创建单元素集合。例如，以下创建单元素List的两个方法是等价的：</p><p>List<String> list1 = List.of(“apple”);<br>List<String> list2 = Collections.singletonList(“apple”);<br>实际上，使用List.of(T…)更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p><p>List<String> list1 = List.of(); // empty list<br>List<String> list2 = List.of(“apple”); // 1 element<br>List<String> list3 = List.of(“apple”, “pear”); // 2 elements<br>List<String> list4 = List.of(“apple”, “pear”, “orange”); // 3 elements</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List：</p><p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> list = new ArrayList&lt;&gt;();<br>        list.add(“apple”);<br>        list.add(“pear”);<br>        list.add(“orange”);<br>        // 排序前:<br>        System.out.println(list);<br>        Collections.sort(list);<br>        // 排序后:<br>        System.out.println(list);<br>    }<br>}</p><h3 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h3><p>Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌：</p><p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<Integer> list = new ArrayList&lt;&gt;();<br>        for (int i=0; i&lt;10; i++) {<br>            list.add(i);<br>        }<br>        // 洗牌前:<br>        System.out.println(list);<br>        Collections.shuffle(list);<br>        // 洗牌后:<br>        System.out.println(list);<br>    }<br>}</p><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>Collections还提供了一组方法把可变集合封装成不可变集合：</p><p>封装成不可变List：List<T> unmodifiableList(List&lt;? extends T&gt; list)<br>封装成不可变Set：Set<T> unmodifiableSet(Set&lt;? extends T&gt; set)<br>封装成不可变Map：Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)<br>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p><p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        immutable.add(“orange”); // UnsupportedOperationException!<br>    }<br>}</p><p>然而，继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List：</p><p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        mutable.add(“orange”);<br>        System.out.println(immutable);<br>    }<br>}</p><p>因此，如果我们希望把一个可变List封装成不可变List，那么，返回不可变List后，最好立刻扔掉可变List的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”List变化了：</p><p>import java.util.*;<br>public class Main {<br>    public static void main(String[] args) {<br>        List<String> mutable = new ArrayList&lt;&gt;();<br>        mutable.add(“apple”);<br>        mutable.add(“pear”);<br>        // 变为不可变集合:<br>        List<String> immutable = Collections.unmodifiableList(mutable);<br>        // 立刻扔掉mutable的引用:<br>        mutable = null;<br>        System.out.println(immutable);<br>    }<br>}</p><h3 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h3><p>Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p><p>变为线程安全的List：List<T> synchronizedList(List<T> list)<br>变为线程安全的Set：Set<T> synchronizedSet(Set<T> s)<br>变为线程安全的Map：Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)<br>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p><h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>Collections类提供了一组工具方法来方便使用集合类：</p><p>创建空集合；<br>创建单元素集合；<br>创建不可变集合；<br>排序／洗牌等操作。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>6.集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>@Configuration</title>
    <link href="/2022/01/06/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/@Configuration/"/>
    <url>/2022/01/06/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/@Configuration/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
      <category>注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Algorithm/README/"/>
    <url>/2022/01/06/Core/Algorithm/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>KEN</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/DesignPattern/README/"/>
    <url>/2022/01/06/Core/DesignPattern/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Framework/Activiti/README/"/>
    <url>/2022/01/06/Core/Framework/Activiti/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataX 3</title>
    <link href="/2022/01/06/Core/Framework/DataX/DataX%203.0/"/>
    <url>/2022/01/06/Core/Framework/DataX/DataX%203.0/</url>
    
    <content type="html"><![CDATA[<h1 id="DataX-3-0"><a href="#DataX-3-0" class="headerlink" title="DataX 3.0"></a>DataX 3.0</h1><p>​ DataX 是一个异构(不同结构)数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。<br><img src=".assets_img/d76eb0d0a1186f267f45c2ba3ed802b32b1f24434a0064885281da072c0b11db.png" alt="图 2"><br><img src=".assets_img/d76eb0d0a1186f267f45c2ba3ed802b32b1f24434a0064885281da072c0b11db.png" alt="图 3">  </p><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p>为了解决异构数据源同步问题，DataX将复杂的网状的同步链路变成了星型数据链路，DataX作为中间传输载体负责连接各种数据源。当需要接入一个新的数据源的时候，只需要将此数据源对接到DataX，便能跟已有的数据源做到无缝数据同步。</p><h2 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h2><p><img src=".assets_img/21e3e366247abcd5d79230eefbd3aa7b97f2e7275b7f55b57903472e9fe6155c.png" alt="图 4">  </p><center>数据库1 => 读插件(数据库1Reader) => 框架0 => 写插件(数据库2 Writer) => 数据库2<center>      <p>DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。</p><ul><li>Reader：Reader�为数据采集模块，负责采集数据源的数据，将数据发送给Framework。</li><li>Writer： Writer为数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。</li><li>Framework：Framework用于连接reader和writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。</li></ul><h2 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h2><p><img src=".assets_img/9bf670172b942444d50bf9d14f2e768b3688d3eeaf7360bff60ff6e6052da392.png" alt="图 5">  </p><h3 id="核心模块介绍："><a href="#核心模块介绍：" class="headerlink" title="核心模块介绍："></a>核心模块介绍：</h3><ol><li><p>DataX完成单个数据同步的作业，我们称之为Job，DataX接受到一个Job之后，将启动一个进程来完成整个作业同步过程。DataX Job模块是单个作业的中枢管理节点，承担了数据清理、子任务切分(将单一作业计算转化为多个子Task)、TaskGroup管理等功能。</p></li><li><p>DataXJob启动后，会根据不同的源端切分策略，将Job切分成多个小的Task(子任务)，以便于并发执行。Task便是DataX作业的最小单元，每一个Task都会负责一部分数据的同步工作。</p></li><li><p>切分多个Task之后，DataX Job会调用Scheduler模块，根据配置的并发数据量，将拆分成的Task重新组合，组装成TaskGroup(任务组)。每一个TaskGroup负责以一定的并发运行完毕分配好的所有Task，默认单个任务组的并发数量为5。</p></li><li><p>每一个Task都由TaskGroup负责启动，Task启动后，会固定启动Reader—&gt;Channel—&gt;Writer的线程来完成任务同步工作。</p></li><li><p>DataX作业运行起来之后， Job监控并等待多个TaskGroup模块任务完成，等待所有TaskGroup任务完成后Job成功退出。否则，异常退出，进程退出值非0</p><h3 id="DataX调度流程："><a href="#DataX调度流程：" class="headerlink" title="DataX调度流程："></a>DataX调度流程：</h3><p>举例来说，用户提交了一个DataX作业，并且配置了20个并发，目的是将一个100张分表的mysql数据同步到odps里面。 DataX的调度决策思路是：</p></li><li><p>DataXJob根据分库分表切分成了100个Task。</p></li><li><p>根据20个并发?，DataX计算共需要分配4个TaskGroup。</p></li><li><p>4个TaskGroup平分切分好的100个Task，每一个TaskGroup负责以5个并发共计运行25个Task。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>DataX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Framework/JDBC/README/"/>
    <url>/2022/01/06/Core/Framework/JDBC/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Framework/Quartz/README/"/>
    <url>/2022/01/06/Core/Framework/Quartz/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Quartz</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Framework/Ruoyi/README/"/>
    <url>/2022/01/06/Core/Framework/Ruoyi/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Ruoyi</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java核心接口</title>
    <link href="/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="标志性接口"><a href="#标志性接口" class="headerlink" title="标志性接口"></a>标志性接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>标志性接口即接口内不含有任何方法</p><h3 id="Cloneable-接口"><a href="#Cloneable-接口" class="headerlink" title="Cloneable 接口"></a>Cloneable 接口</h3><p>clone接口属于标志性接口（接口内不含有任何方法）。我们可以实现这个接口后，重写Object中的clone方法，通过对象调用clone方法实现对象clone，如果不实现这个接口，则会抛出CloneNotSupportedException(克隆不被支持)异常。</p><p>那什么是对象克隆呢？</p><p>假如我有一个Student类，类定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我有一个Student类对象 stu（id=12,name=”张三”）,我想生成一个和stu对象一样的对象（对象属性的值相同）,这个过程就叫克隆。</p><p>如果不使用clone方法，那么我们可以new一个新对象，然后通过构造方法赋值，这是一个可行的方法。不过在编程中有时候我们会发现，当我们需要一个实例，可是这个实例的创建过程十分复杂，在执行过程中会消耗大量的时间，同时创建第一个实例和创建第二个实例的初始化信息并未改变。在此种情况下，直接New 一个实例对象显得太浪费，不合理。所以这种情况下，对象克隆（clone）是一种很好的解决方法（对象属性直接基于堆复制）。</p><p>PS：实现简单的对象复制，常用的四种方法</p><p>（1）将A对象的值分别通过set方法加入B对象中；</p><p>（2）通过重写java.lang.Object类中的方法clone()；</p><p>（3）通过org.apache.commons中的工具类BeanUtils和PropertyUtils进行对象复制；</p><p>（4）通过序列化实现对象的复制。</p><h4 id="使用clone方法"><a href="#使用clone方法" class="headerlink" title="使用clone方法"></a>使用clone方法</h4><p>一个很典型的调用clone()代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>　<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>　　CloneClass o = <span class="hljs-keyword">null</span>;<br>　　<span class="hljs-keyword">try</span>&#123;<br>　　　o = (CloneClass)<span class="hljs-keyword">super</span>.clone();<br>　　&#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e)&#123;<br>　　　e.printStackTrace();<br>　　&#125;<br>　　<span class="hljs-keyword">return</span> o;<br>　&#125;<br>｝<br></code></pre></td></tr></table></figure><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        Student student = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            student = (Student) <span class="hljs-keyword">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student student=<span class="hljs-keyword">new</span> Student();<br>        student.setId(<span class="hljs-number">231</span>);<br>        student.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(student.getName());<br>        Student cloneStudent = (Student)student.clone();<br>        System.out.println(cloneStudent.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/16466161-5eac5bc74e8f30c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>1.面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实例的三种注入方式及循环依赖的解决</title>
    <link href="/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-实例的注入方式"><a href="#1-实例的注入方式" class="headerlink" title="1. 实例的注入方式"></a>1. 实例的注入方式</h1><h2 id="常见注入方式"><a href="#常见注入方式" class="headerlink" title="常见注入方式"></a>常见注入方式</h2><ul><li><p>属性注入</p></li><li><p>set方法注入：太臃肿,一般不用</p><div class="code-wrapper"><pre><code class="hljs">@Servicepublic class BService &#123;AService aService;@Autowiredpublic void setaService(AService aService) &#123;    this.aService = aService;&#125;</code></pre></div><p>}</p></li><li><p>构造方法注入 :</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;<br>    BService bService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AService</span><span class="hljs-params">(BService bService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.bService = bService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果类只有一个构造方法，那么 <code>@Autowired</code> 注解可以省略；如果类中有多个构造方法，那么需要添加上 <code>@Autowired</code> 来明确指定到底使用哪个构造方法。</p></li></ul><h3 id="属性注入注解"><a href="#属性注入注解" class="headerlink" title="属性注入注解"></a>属性注入注解</h3><p>​    最为常见的注入方式, 用 @Autowired @Resource @Inject</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ol><li><p>Spring自带注解,通过类的类型(<strong>type</strong>)自动装配,通过<strong>AutowiredAnnotationBeanPostProcessor</strong>类实现依赖注入,如果类型相同,会按照名称进行匹配,如果名称相同,会<strong>报错</strong>. 如果想要按指定名称匹配,要配合**@Qualifier**使用</p></li><li><p>有个required属性,设为false没有找到相应的Bean,系统不会报错</p></li><li><p>可以作用在变量,setter方法和构造函数上,常用方法为将@Autowired的写在被注入的成员变量上,就不用在xml文件中配置了,也可以省略写getter和setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写在变量上</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DemoService demoService;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写在构造方法上(写在setter方法上略)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> DemoService demoService;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoClass</span><span class="hljs-params">(DemoService demoService)</span></span>&#123;<br> <span class="hljs-keyword">this</span>.demoService = demoService;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配合<span class="hljs-doctag">@Qualifier</span>使用,此时byName</span><br><span class="hljs-comment"> * 注意<span class="hljs-doctag">@Autowired</span> 可以对成员变量、setter方法以及构造函数进行注释</span><br><span class="hljs-comment"> * 而<span class="hljs-doctag">@Qualifier</span> 的标注对象是成员变量、setter方法入参、构造函数入参</span><br><span class="hljs-comment"> */</span><br>如  <span class="hljs-number">1.</span> <br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-meta">@Qualifier(&quot;myDemoService&quot;)</span><br>        <span class="hljs-keyword">private</span> DemoService demoService;<br>    <span class="hljs-number">2.</span><br>        <span class="hljs-keyword">private</span> DemoService demoService;<br><br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoClass</span><span class="hljs-params">(  <span class="hljs-meta">@Qualifier(&quot;myDemoService&quot;)</span> DemoService demoService)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.demoService = demoService;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>1、@Resource是JSR250规范的实现，需要导入javax.annotation实现注入。</p><p>2、@Resource是根据<strong>名称</strong>进行自动装配的，一般会指定一个name属性</p><p>3、@Resource可以作用在变量、setter方法上,不可以作用在构造函数上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写在变量上</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> DemoService demoService;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写在构造方法上(写在setter方法上略)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> DemoService demoService;<br><br><span class="hljs-meta">@Resource(name=&quot;myDemoService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDemoService</span><span class="hljs-params">(DemoService demoService)</span></span>&#123;<br> <span class="hljs-keyword">this</span>.demoService = demoService;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><p>1、@Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject;实现注入。</p><p>2、@Inject是根据<strong>类型</strong>进行自动装配的，如果需要按名称进行装配，则需要配合@Named；</p><p>3、@Inject可以作用在变量、setter方法、构造函数上。</p><p>注意:</p><p><strong>a、</strong>将@Inject可以作用在变量、setter方法、构造函数上，和@Autowired一样</p><p><strong>b、@Named</strong></p><p>@Named(“XX”) 中的 XX是 Bean 的名称，所以 @Inject\和 @Named结合使用时，自动注入的策略就从 <strong>byType</strong> 转变成 <strong>byName</strong> 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> DemoService demoService;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoClass</span><span class="hljs-params">(  <span class="hljs-meta">@Named(&quot;myDemoService&quot;)</span> DemoService demoService)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.demoService = demoService;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="三种方式区别小结"><a href="#三种方式区别小结" class="headerlink" title="三种方式区别小结"></a>三种方式区别小结</h2><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>1.基于constructor的注入，会固定依赖注入的顺序；该方式不允许我们创建bean对象之间的循环依赖关系，这种限制其实是一种利用构造器来注入的益处 - 当你甚至没有注意到使用setter注入的时候，Spring能解决循环依赖的问题；</p><p>2.基于setter的注入，只有当对象是需要被注入的时候它才会帮助我们注入依赖，而不是在初始化的时候就注入；另一方面如果你使用基于constructor注入，CGLIB不能创建一个代理，迫使你使用基于接口的代理或虚拟的无参数构造函数。</p><p>3.相信很多同学都选择使用直接在成员变量上写上注解来注入，正如我们所见，这种方式看起来非常好，精短，可读性高，不需要多余的代码，也方便维护；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>缺点：</strong></p><p>1.当我们利用constructor来注入的时候，比较明显的一个缺点就是：假如我们需要注入的对象特别多的时候，我们的构造器就会显得非常的冗余、不好看，非常影响美观和可读性，维护起来也较为困难；</p><p>2.当我们选择setter方法来注入的时候，我们不能将对象设为final的；</p><p>3.当我们在field变量上来实现注入的时候</p><p>  a.这样不符合JavaBean的规范，而且很有可能引起空指针；</p><p>  b.同时也不能将对象标为final的；</p><p>  <strong>c.类与DI容器高度耦合，我们不能在外部使用它；</strong></p><p>  d.类不通过反射不能被实例化（例如单元测试中），你需要用DI容器去实例化它，这更像集成测试；</p><p><strong>换言之，要是使用属性注入，那么你这个类就只能在 IOC 容器中使用，要是想自己 new 一下这个类的对象，那么相关的依赖无法完成注入。</strong></p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>3.x : 推荐setter注入,因为构造器注入时,大量构造器参数显得非常笨重,尤其是属性是非必要的时候,setter方法可以使类的对象在后来重新配置或者重新注入,而构造器注入提供所有的依赖意味着对象总是返回一个完全初始化状态的client客户端(调用),缺点是对象变得不那么适合重新配置和重新注入。</p><p>4.x :推荐构造器注入，因为它允许一个应用程序组件实现为不可变对象，并确保所需的依赖项不是空。此外构造器注入组件总是返回一个完全初始化状态的client客户端(调用),如果用构造方法注入的时候，参数过多以至于代码过于臃肿，那么此时你需要考虑这个类的设计是否合理，这个类是否参杂了太多的其他无关功能，这个类是否做到了单一职责。</p><p>4.3以后  如果类中只有一个构造函数(有参会覆盖无参),Spring会实现隐式自动注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 4.3之前</span><br><span class="hljs-comment"> */</span><br> <br>  <span class="hljs-meta">@Service</span><br> <span class="hljs-number">2</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooService</span> </span>&#123;<br> <span class="hljs-number">3</span> <br> <span class="hljs-number">4</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FooRepository repository;<br> <span class="hljs-number">5</span> <br> <span class="hljs-number">6</span>     <span class="hljs-meta">@Autowired</span><br> <span class="hljs-number">7</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FooService</span><span class="hljs-params">(FooRepository repository)</span> </span>&#123;<br> <span class="hljs-number">8</span>         <span class="hljs-keyword">this</span>.repository = repository<br> <span class="hljs-number">9</span>     &#125;<br><span class="hljs-number">10</span> &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 4.3以后</span><br><span class="hljs-comment"> * 不需要写<span class="hljs-doctag">@Autowired</span>了,但成员变量要设为final</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-meta">@Service</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooService</span> </span>&#123;<br><span class="hljs-number">3</span> <br><span class="hljs-number">4</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FooRepository repository;<br><span class="hljs-number">5</span> <br><span class="hljs-number">6</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FooService</span><span class="hljs-params">(FooRepository repository)</span> </span>&#123;<br><span class="hljs-number">7</span>         <span class="hljs-keyword">this</span>.repository = repository<br><span class="hljs-number">8</span>     &#125;<br><span class="hljs-number">9</span> &#125;<br><br></code></pre></td></tr></table></figure><h2 id="注入接口时-如何指定实现类"><a href="#注入接口时-如何指定实现类" class="headerlink" title="注入接口时,如何指定实现类"></a>注入接口时,如何指定实现类</h2><h3 id="通过-Primary-指明实现类优先级"><a href="#通过-Primary-指明实现类优先级" class="headerlink" title="通过@Primary 指明实现类优先级"></a>通过@Primary 指明实现类优先级</h3><p>在写实现类的时候事先指明实现类的优先级，注入的时候就会使用优先级高的实现类。<strong>在controller中注入接口，默认使用的是Primary 标注的实现类的方法,最多只有一个实现类能添加该注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;s1&quot;)</span><br><span class="hljs-meta">@Primary</span>     <span class="hljs-comment">//**同一个接口的多个实现类，最多只能有一个添加该注解**</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span> </span>&#123;<br>     。。。<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过-Autowired和-Qualifier配合注入"><a href="#通过-Autowired和-Qualifier配合注入" class="headerlink" title="通过@Autowired和@Qualifier配合注入"></a>通过@Autowired和@Qualifier配合注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;interface1Impl1&quot;)</span> <span class="hljs-comment">//根据bean name</span><br>Interface1 interface1;    <span class="hljs-comment">//正常启动</span><br></code></pre></td></tr></table></figure><h3 id="通过-Resource注入-根据默认类名区分"><a href="#通过-Resource注入-根据默认类名区分" class="headerlink" title="通过@Resource注入,根据默认类名区分"></a>通过@Resource注入,根据默认类名区分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;interface1Impl1&quot;)</span><br>Interface1 interface1;    <span class="hljs-comment">//正常启动</span><br></code></pre></td></tr></table></figure><h3 id="通过-Resource注入-根据-Service指定的类名区分"><a href="#通过-Resource注入-根据-Service指定的类名区分" class="headerlink" title="通过@Resource注入,根据@Service指定的类名区分"></a>通过@Resource注入,根据@Service指定的类名区分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;s1&quot;)</span><br>Interface1 interface1;    <span class="hljs-comment">//正常启动</span><br></code></pre></td></tr></table></figure><h2 id="Bean命名逻辑"><a href="#Bean命名逻辑" class="headerlink" title="Bean命名逻辑"></a>Bean命名逻辑</h2><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><p>BeanNameGenerator接口定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Generate a bean name for the given bean definition.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> definition the bean definition to generate a name for</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry the bean definition registry that the given definition</span><br><span class="hljs-comment">     * is supposed to be registered with</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the generated bean name</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BeanNameGenerator是生成beanName的顶级接口，而它有两个实现类，图中左侧的DefaultBeanNameGenerator是给XML配置中Bean使用的，图中右侧的AnnotationBeanNameGenerator则是给通过注解定义的Bean使用的。</p><h4 id="通过XML配置命名"><a href="#通过XML配置命名" class="headerlink" title="通过XML配置命名"></a>通过XML配置命名</h4><p>类名+“#”+数字</p><h4 id="通过注解配置命名"><a href="#通过注解配置命名" class="headerlink" title="通过注解配置命名"></a>通过注解配置命名</h4><ol><li>取短类名，即不包含包路径的类名，例如com.test.Student的短类名为Student，这点跟XML配置中取全类名不一样</li><li>如果短类名长度大于1，且第一个和第二个字符为大写，则直接返回短类名，也就是说假设类为com.test.STudent，则beanName为STudent</li><li>其他情况下将短类名首字符小写后返回，假设类为com.test.Student，则beanName为student</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>由于只为了验证beanName，简单起见，Bean类中都为空</p><p>People类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pepole</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>TNtt类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TNttt</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>TestPepole类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TestPepole</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>TNTt类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TNTt</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中TestPepole和TNTt通过XML配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hust.TestPepole&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hust.TNTt&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试主类</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> App &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws IOException &#123;<br>        ApplicationContext applicationContext = <span class="hljs-built_in">new</span> ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">new</span> Gson().toJson(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Pepole.<span class="hljs-keyword">class</span>)));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">new</span> Gson().toJson(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext,<br>                TNttt.<span class="hljs-keyword">class</span>)));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">new</span> Gson().toJson(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext,<br>                TestPepole.<span class="hljs-keyword">class</span>)));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">new</span> Gson().toJson(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext,<br>                TNTt.<span class="hljs-keyword">class</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;pepole&quot;</span>]<br>[<span class="hljs-string">&quot;TNttt&quot;</span>]<br>[<span class="hljs-string">&quot;com.hust.TestPepole#0&quot;</span>]<br>[<span class="hljs-string">&quot;com.hust.TNTt#0&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>在不指定beanName的情况下，Spring会自动为注册的Bean生成一个唯一的beanName</li><li>通过注解注册的Bean和XML注册的Bean，Spring为其生成默认beanName的机制不一样</li><li>不要盲目觉得通过注解注册的Bean，Spring为其生成beanName就是将短类名的首字母小写，<strong>当短类名的首字符和第二个字符均大写时</strong>，beanName就是短类名</li></ul>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>1.面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Framework/Spring/SpringBoot/README/"/>
    <url>/2022/01/06/Core/Framework/Spring/SpringBoot/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>配置spring</title>
    <link href="/2022/01/06/Core/Framework/Spring/SpringBoot/%E9%85%8D%E7%BD%AEspring.profiles.active%E7%9A%84%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/06/Core/Framework/Spring/SpringBoot/%E9%85%8D%E7%BD%AEspring.profiles.active%E7%9A%84%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>背景</p><p>很多时候，我们项目在开发环境和生成环境的环境配置是不一样的，例如，数据库配置，在开发的时候，我们一般用测试数据库，而在生产环境的时候，我们是用正式的数据，这时候，我们可以利用profile在不同的环境下配置用不同的配置文件或者不同的配置。</p><p>spring boot 提供</p><p>spring boot允许你通过命名约定按照一定的格式(application-{profile}.properties)来定义多个配置文件，然后通过在application.properyies通过spring.profiles.active来具体激活一个或者多个配置文件，如果没有没有指定任何profile的配置文件的话，spring boot默认会启动application-default.properties。</p><p>profile的配置文件可以按照application.properyies的放置位置一样，放于以下四个位置：</p><p>当前目录的 “/config”的子目录下</p><p>当前目录下</p><p>classpath根目录的“/config”包下</p><p>classpath的根目录下</p><p>demo 演示</p><p>在这里我们就定义俩个profile文件，</p><p>application-sit.properties和application-prd.properties，</p><p>并在俩个文件中都分别</p><p>写上变量</p><p>我们在application.properyies也写上，并把profile切换到application-sit.properties的配置文件</p><p><img src="https://upload-images.jianshu.io/upload_images/1716179-d4a3de10febe7e7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>我们在application.properyies也写上，并把profile切换到application-sit.properties的配置文件</p><p>#修改tomcat的默认的端口号，将8080改为8889</p><p>server.port=8889</p><p>#启用shutdown endpoint的HTTP访问</p><p>endpoints.shutdown.enabled=true</p><p>#不需要用户名密码验证</p><p>endpoints.shutdown.sensitive=false</p><p>#默认curvar值</p><p>curvar=default.curvar</p><p>#切换配置文件</p><p>spring.profiles.active=sit</p><p>可以通过这样子来测试</p><p>package HelloWord;</p><p>import org.springframework.beans.factory.annotation.Value;</p><p>import org.springframework.web.bind.annotation.RequestMapping;</p><p>import org.springframework.web.bind.annotation.RestController;</p><p>@RestController</p><p>@RequestMapping(“/task”)</p><p>public class TaskController {</p><p>  @RequestMapping(value = {“/“,””})</p><p>  public String hellTask(@Value(“${curvar}”)String cusvar ){</p><p>​    return “hello task !! my current variable is “ + cusvar;</p><p>  }</p><p>}</p><p><img src="https://upload-images.jianshu.io/upload_images/1716179-8e43537c4af374aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>分别定义俩个实现类来实现它</p><p>package config;</p><p>import org.springframework.context.annotation.Profile;</p><p>import org.springframework.stereotype.Component;</p><p>/**</p><p> * 测试数据库</p><p> */</p><p>@Component</p><p>@Profile(“sitdb”)</p><p>public class SitDBConnector implements DBConnector {</p><p>  @Override</p><p>  public void configure() {</p><p>​    System.out.println(“sit-db”);</p><p>  }</p><p>}</p><p>package config;</p><p>import org.springframework.context.annotation.Profile;</p><p>import org.springframework.stereotype.Component;</p><p>/**</p><p> * 生产数据库</p><p> */</p><p>@Component</p><p>@Profile(“prddb”)</p><p>public class PrdDBConnector implements DBConnector {</p><p>  @Override</p><p>  public void configure() {</p><p>​    System.out.println(“prd-db”);</p><p>  }</p><p>}</p><p>通过在配置文件激活具体使用哪个实现类</p><p>#修改tomcat的默认的端口号，将8080改为8889</p><p>server.port=8889</p><p>#启用shutdown endpoint的HTTP访问</p><p>endpoints.shutdown.enabled=true</p><p>#不需要用户名密码验证</p><p>endpoints.shutdown.sensitive=false</p><p>#默认curvar值</p><p>curvar=default.curvar</p><p>#切换配置文件</p><p>#修改tomcat的默认的端口号，将8080改为8889</p><p>server.port=8889</p><p>#启用shutdown endpoint的HTTP访问</p><p>endpoints.shutdown.enabled=true</p><p>#不需要用户名密码验证</p><p>endpoints.shutdown.sensitive=false</p><p>#默认curvar值</p><p>curvar=default.curvar</p><p>#切换配置文件</p><p>spring.profiles.active=sitdb</p><p>然后就可以这么使用</p><p>package HelloWord;</p><p>import config.DBConnector;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.beans.factory.annotation.Value;</p><p>import org.springframework.context.annotation.ComponentScan;</p><p>import org.springframework.web.bind.annotation.RequestMapping;</p><p>​    import org.springframework.web.bind.annotation.RestController;</p><p>@RestController</p><p>@RequestMapping(“/task”)</p><p>@ComponentScan(basePackages={“config”})</p><p>public class TaskController {</p><p>  @Autowired DBConnector connector;</p><p>  @RequestMapping(value = {“/“,””})</p><p>  public String hellTask(@Value(“${curvar}”)String cusvar ){</p><p>​    connector.configure();//最终打印配置的db</p><p>​    return “hello task !! my current variable is “ + cusvar;</p><p>  }</p><p>}</p><p><img src="https://upload-images.jianshu.io/upload_images/1716179-632ba08a6f4dc101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/1716179-c958750dd3655188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/1716179-02cb963d222c450a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>以上就是spring boot用profile的作用。</p><p>以下为可选（主要是命令行使用）：</p><p>通过命令行设置属性值</p><p>相信使用过一段时间Spring Boot的用户，一定知道这条命令：java -jar xxx.jar –server.port=8888，通过使用–server.port属性来设置xxx.jar应用的端口为8888。</p><p>在命令行运行时，连续的两个减号–就是对application.properties中的属性值进行赋值的标识。所以，java -jar xxx.jar –server.port=8888命令，等价于我们在application.properties中添加属性server.port=8888，该设置在样例工程中可见，读者可通过删除该值或使用命令行来设置该值来验证。</p><p>通过命令行来修改属性值固然提供了不错的便利性，但是通过命令行就能更改应用运行的参数，那岂不是很不安全？是的，所以Spring Boot也贴心的提供了屏蔽命令行访问属性的设置，只需要这句设置就能屏蔽：SpringApplication.setAddCommandLineProperties(false)。</p><p>多环境配置</p><p>以上都不是重点，这才是重点，这才是重点，这才是重点，重要的事情说3遍。我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p><p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如：</p><p>application-dev.properties：开发环境</p><p>application-test.properties：测试环境</p><p>application-prod.properties：生产环境</p><p>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。</p><p>如：spring.profiles.active=test就会加载application-test.properties配置文件内容</p><p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p><p> 针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties</p><p> 在这三个文件均都设置不同的server.port属性，如：dev环境设置为8080，test环境设置为9090，prod环境设置为80</p><p> application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置</p><p>测试不同配置的加载：</p><p>执行java -jar xxx.jar，可以观察到服务端口被设置为8080，也就是默认的开发环境（dev）</p><p> 执行java -jar xxx.jar –spring.profiles.active=test，可以观察到服务端口被设置为9090，也就是测试环境的配置（test）</p><p> 执行java -jar xxx.jar –spring.profiles.active=prod，可以观察到服务端口被设置为80，也就是生产环境的配置（prod）</p><p>按照上面的实验，可以如下总结多环境的配置思路：</p><p>application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置</p><p>application-{profile}.properties中配置各个环境不同的内容</p><p>通过命令行方式去激活不同环境的配置。</p><p>多环境高级应用</p><p>在某些情况下，应用的某些业务逻辑可能需要有不同的实现。例如邮件服务，假设EmailService中包含的send(String email)方法向指定地址发送电子邮件，但是我们仅仅希望在生产环境中才执行真正发送邮件的代码，而开发环境里则不发送以免向用户发送无意义的垃圾邮件。</p><p>我们可以借助Spring的注解@Profile实现这样的功能，这样需要定义两个实现EmailService借口的类：</p><p>/**</p><p> * 发送邮件接口.</p><p> */</p><p>public interface EmailService {</p><p>  /*<em>发送邮件</em>/</p><p>  publicvoid send();</p><p>}</p><p>发送邮件的具体实现（dev-开发环境的代码）：</p><p>@Service</p><p>@Profile(“dev”) //开发环境的时候.</p><p>public class DevEmailServiceImpl implements EmailService{</p><p>  @Override</p><p>  publicvoid send() {</p><p>​    System.out.println(“DevEmailServiceImpl.send().开发环境不执行邮件的发送.”);</p><p>  }</p><p>}</p><p>发送邮件的具体实现（prod-生产环境的代码）：</p><p>@Service</p><p>@Profile(“prod”) //生产环境.</p><p>public class ProdEmailServiceImpl2 implements EmailService{</p><p>  @Override</p><p>  publicvoid send() {</p><p>​    System.out.println(“DevEmailServiceImpl.send().生产环境执行邮件的发送.”);</p><p>​    //具体的邮件发送代码.</p><p>​    //mail.send();</p><p>  }</p><p>}</p><p>Profile(“dev”)表明只有Spring定义的Profile为dev时才会实例化DevEmailService这个类。那么如何设置Profile呢？</p><p>在application.properties中加入：</p><p>spring.profiles.active=dev</p><p>通过命令行参数</p><p>java -jar app.jar –spring.profiles.active=dev</p><p>作者：WRFranky<br>链接：<a href="https://www.jianshu.com/p/e6ef9893cd63">https://www.jianshu.com/p/e6ef9893cd63</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/2022/01/06/Core/Framework/Spring/SpringCloud/README/"/>
    <url>/2022/01/06/Core/Framework/Spring/SpringCloud/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Spring</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>@RestControllerAdvice 统一异常处理</title>
    <link href="/2022/01/06/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/@RestControllerAdvice%20%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/01/06/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/@RestControllerAdvice%20%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在做前后端分离的项目时，后端通常都会拆分成多个独立的微服务，这时候就会涉及每个服务返回给前端的数据格式问题了。下面就来实现一个比较常用的数据格式，统一所有服务的返回值格式。<br> 一般返回的数据格式会包括4个部分，第一部分： 请求处理是否成功，第二部分：服务处理结果编码，第三部分：编码对应的文本信息，第四部分：返回值。如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;result&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;lantian&quot;</span>: <span class="hljs-number">17</span>,<br>        <span class="hljs-attr">&quot;qingfen&quot;</span>: <span class="hljs-number">16</span>,<br>        <span class="hljs-attr">&quot;baiyun&quot;</span>: <span class="hljs-number">18</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于异常处理情况，我们也需要统一成上面的格式。如果我们在controller中通过try catch来处理异常的话，会出现一个问题就是每个函数里都加一个Try catch,代码会变的很乱。下面我们就通过spring boot的注解来省略掉controller中的try-catch 帮助我们来封装异常信息并返回给前端，这样用户也不会得到一些奇奇怪怪的错误提示。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;result&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">3000</span>,<br>    <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;THIS IS AN UNKNOW EXCEPTION&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1：定义返回值结构信息（get-set函数省略）"><a href="#1：定义返回值结构信息（get-set函数省略）" class="headerlink" title="1：定义返回值结构信息（get, set函数省略）"></a>1：定义返回值结构信息（get, set函数省略）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallResultMsg</span>&lt;</span>T&gt; &#123;<br>    <span class="hljs-keyword">private</span> boolean result;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> T data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2：定义返回值和对应code的信息（get-set函数省略）"><a href="#2：定义返回值和对应code的信息（get-set函数省略）" class="headerlink" title="2：定义返回值和对应code的信息（get, set函数省略）"></a>2：定义返回值和对应code的信息（get, set函数省略）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CodeAndMsg</span> &#123;</span><br>    <span class="hljs-built_in">SUCCESS</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>),<br>    <span class="hljs-built_in">METHODFAIL</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&quot;ENCOUNTER AN ERROR WHEN EXECUTE METHOD&quot;</span>),<br>    <span class="hljs-built_in">UNKNOWEXCEPTION</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;THIS IS AN UNKNOW EXCEPTION&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-built_in">CodeAndMsg</span>(<span class="hljs-keyword">int</span> code, String msg)&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3：自定义异常"><a href="#3：自定义异常" class="headerlink" title="3：自定义异常"></a>3：自定义异常</h3><p>对于一些特别的异常，我们可以自定义Exception和Error Code,这里自定义一个异常（需要继承RuntimeException）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDefinedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CodeAndMsg <span class="hljs-built_in">exception</span>;<br><br>    <span class="hljs-keyword">public</span> UserDefinedException(CodeAndMsg <span class="hljs-built_in">exception</span>)&#123;<br>        this.<span class="hljs-built_in">exception</span> = <span class="hljs-built_in">exception</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> CodeAndMsg getException() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">exception</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setException(CodeAndMsg <span class="hljs-built_in">exception</span>) &#123;<br>        this.<span class="hljs-built_in">exception</span> = <span class="hljs-built_in">exception</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4：RestControllerAdvice来捕获全局异常，"><a href="#4：RestControllerAdvice来捕获全局异常，" class="headerlink" title="4：RestControllerAdvice来捕获全局异常，"></a>4：RestControllerAdvice来捕获全局异常，</h3><p>@RestControllerAdvice都是对Controller进行增强的，可以全局捕获spring mvc抛的异常。<br> @ExceptionHandler(value = Exception.class)<br> ExceptionHandler的作用是用来捕获指定的异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestControllerAdvice(annotations = RestController.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UniformReponseHandler</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@ResponseStatus(HttpStatus.OK)</span><br>    <span class="hljs-keyword">public</span> CallResultMsg sendSuccessResponse()&#123;<br>        <span class="hljs-keyword">return</span> new CallResultMsg(<span class="hljs-literal">true</span>, CodeAndMsg.SUCCESS, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@ResponseStatus(HttpStatus.OK)</span><br>    <span class="hljs-keyword">public</span> CallResultMsg sendSuccessResponse(T <span class="hljs-keyword">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> new CallResultMsg(<span class="hljs-literal">true</span>, CodeAndMsg.SUCCESS, <span class="hljs-keyword">data</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(UserDefinedException.class)</span><br>    <span class="hljs-meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span><br>    <span class="hljs-keyword">public</span> CallResultMsg sendErrorResponse_UserDefined(Exception exception)&#123;<br>        <span class="hljs-keyword">return</span> new CallResultMsg(<span class="hljs-literal">false</span>, ((UserDefinedException)exception).getException(), <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span><br>    <span class="hljs-keyword">public</span> CallResultMsg sendErrorResponse_System(Exception exception)&#123;<br>        <span class="hljs-keyword">if</span> (exception instanceof UserDefinedException) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sendErrorResponse_UserDefined(exception);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> new CallResultMsg(<span class="hljs-literal">false</span>, CodeAndMsg.UNKNOWEXCEPTION, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的一波操作，我们的controller中就不需要再去写大量的try-catch了，RestControllerAdvice会自动帮助catch,并匹配相应的ExceptionHandler,然后重新封装异常信息，返回值，统一格式返回给前端。<br> <img src="https://math.jianshu.com/math?formula=%5Ccolor%7B%20red%20%7D%7B%20%E5%BD%93%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E5%86%99%E6%88%90%E4%B8%80%E4%B8%AAjar%E5%8C%85%EF%BC%8C%E4%BE%9B%E5%85%B6%E4%BB%96%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82%20%7D" alt="\color{ red }{ 当然也可以单独写成一个jar包，供其他微服务的使用。 }"></p><h3 id="5：ControllerAdvice-和-RestControllerAdvice的区别"><a href="#5：ControllerAdvice-和-RestControllerAdvice的区别" class="headerlink" title="5：ControllerAdvice 和 RestControllerAdvice的区别"></a>5：ControllerAdvice 和 RestControllerAdvice的区别</h3><p>@ControllerAdvice 和 @RestControllerAdvice都是对Controller进行增强的，可以全局捕获spring mvc抛的异常。<br> RestControllerAdvice = ControllerAdvice + ResponseBody<br> 6：测试统一异常捕获功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">@<span class="hljs-built_in">GetMapping</span>(<span class="hljs-string">&quot;/doTestObject&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> CallResultMsg <span class="hljs-title">testObjectReturn</span><span class="hljs-params">()</span></span>&#123;<br>    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>();<br>    map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;qingfen&quot;</span>, <span class="hljs-number">16</span>);<br>    map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;lantian&quot;</span>, <span class="hljs-number">17</span>);<br>    map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;baiyun&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UniformReponseHandler&lt;Map&gt;().<span class="hljs-built_in">sendSuccessResponse</span>(map);<br>&#125;<br><br><br>@<span class="hljs-built_in">GetMapping</span>(<span class="hljs-string">&quot;/doTestException/&#123;x&#125;&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testExceptionResturn</span><span class="hljs-params">(@PathVariable <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; x &amp;&amp; x &lt; <span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserDefinedException</span>(CodeAndMsg.METHODFAIL);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;result&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;lantian&quot;</span>: <span class="hljs-number">17</span>,<br>        <span class="hljs-attr">&quot;qingfen&quot;</span>: <span class="hljs-number">16</span>,<br>        <span class="hljs-attr">&quot;baiyun&quot;</span>: <span class="hljs-number">18</span><br>    &#125;<br>&#125;<br>&#123;<br>    <span class="hljs-attr">&quot;result&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">2000</span>,<br>    <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;ENCOUNTER AN ERROR WHEN EXECUTE METHOD &quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作者：蓉漂里的小白<br>链接：<a href="https://www.jianshu.com/p/47aeeba6414c">https://www.jianshu.com/p/47aeeba6414c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
      <category>注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ControllerAdvice</title>
    <link href="/2022/01/06/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/ControllerAdvice/"/>
    <url>/2022/01/06/Core/Framework/Spring/SpringBoot/%E6%B3%A8%E8%A7%A3/ControllerAdvice/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-中-ControllerAdvice-注解的三种使用场景！"><a href="#SpringMVC-中-ControllerAdvice-注解的三种使用场景！" class="headerlink" title="SpringMVC 中 @ControllerAdvice 注解的三种使用场景！"></a><a href="https://www.cnblogs.com/lenve/p/10748453.html">SpringMVC 中 @ControllerAdvice 注解的三种使用场景！</a></h1><p>@ControllerAdvice ，很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：</p><ol><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ol><p>灵活使用这三个功能，可以帮助我们简化很多工作，需要注意的是，这是 SpringMVC 提供的功能，在 Spring Boot 中可以直接使用，下面分别来看。</p><h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><p>使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalExceptionHandler</span> </span>&#123;<br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">customException</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;message&quot;</span>, e.getMessage());<br>        mv.setViewName(<span class="hljs-string">&quot;myerror&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。</p><p>@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。</p><h1 id="全局数据绑定"><a href="#全局数据绑定" class="headerlink" title="全局数据绑定"></a>全局数据绑定</h1><p>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。</p><p>使用步骤，首先定义全局数据，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalExceptionHandler</span> </span>&#123;<br>    <span class="hljs-meta">@ModelAttribute(name = &quot;md&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">mydata</span><span class="hljs-params">()</span> </span>&#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">99</span>);<br>        map.put(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。</p><p>定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        Map&lt;String, Object&gt; map = model.asMap();<br>        System.out.println(map);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello controller advice&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="全局数据预处理"><a href="#全局数据预处理" class="headerlink" title="全局数据预处理"></a>全局数据预处理</h1><p>考虑我有两个实体类，Book 和 Author，分别定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Long price;<br>    <span class="hljs-comment">//getter/setter</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">//getter/setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时，如果我定义一个数据添加接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/book&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book, Author author)</span> </span>&#123;<br>    System.out.println(book);<br>    System.out.println(author);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题</p><p>解决步骤如下:</p><p>1.给接口中的变量取别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/book&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;b&quot;)</span> Book book, <span class="hljs-meta">@ModelAttribute(&quot;a&quot;)</span> Author author)</span> </span>&#123;<br>    System.out.println(book);<br>    System.out.println(author);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.进行请求数据预处理<br>在 @ControllerAdvice 标记的类中添加如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@InitBinder(&quot;b&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;<br>    binder.setFieldDefaultPrefix(<span class="hljs-string">&quot;b.&quot;</span>);<br>&#125;<br><span class="hljs-meta">@InitBinder(&quot;a&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;<br>    binder.setFieldDefaultPrefix(<span class="hljs-string">&quot;a.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>@InitBinder(“b”) 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.</p><p>3.发送请求</p><p>请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.</p><p><img src="https://www.javaboy.org/images/boot/5-1.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Framework</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
      <category>注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java核心类</title>
    <link href="/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
    <url>/2022/01/06/Core/Java/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h1><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">String s1 = <span class="hljs-string">&quot;Hello!&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p><p>Java字符串的一个重要特点就是字符串<em>不可变</em>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         String s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(s.hashCode());<br>        s = s.toUpperCase();<br>        System.out.println(s.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出 <code>69609650</code> <code>68624562</code> 说明已经不是原来那个字符串对象了</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p><p>我们看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        System.out.println(s1 == s2); <span class="hljs-comment">//true</span><br>        System.out.println(s1.equals(s2)); <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p><p>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// String</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;HELLO&quot;</span>.<span class="hljs-built_in">toLowerCase</span>();<br>        System.out.<span class="hljs-built_in">println</span>(s1 == s2); <span class="hljs-comment">//false</span><br>        System.out.<span class="hljs-built_in">println</span>(s1.<span class="hljs-built_in">equals</span>(s2)); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结论：两个字符串比较，必须总是使用<code>equals()</code>方法。</p><p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 是否包含子串:<br><span class="hljs-string">&quot;Hello&quot;</span>.contains(<span class="hljs-string">&quot;ll&quot;</span>); <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><p><strong>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>的父类。</strong></p><p>搜索子串的更多的例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;Hello&quot;</span>.indexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-string">&quot;Hello&quot;</span>.lastIndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><span class="hljs-string">&quot;Hello&quot;</span>.startsWith(<span class="hljs-string">&quot;He&quot;</span>); <span class="hljs-regexp">//</span> true<br><span class="hljs-string">&quot;Hello&quot;</span>.endsWith(<span class="hljs-string">&quot;lo&quot;</span>); <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><p>提取子串的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">&quot;Hello&quot;.<span class="hljs-built_in">substring</span>(<span class="hljs-number">2</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> &quot;llo&quot;<br>&quot;Hello&quot;.<span class="hljs-built_in">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); &quot;ll&quot;<br></code></pre></td></tr></table></figure><p>注意索引号是从<code>0</code>开始的。</p><h3 id="去除首尾空白字符"><a href="#去除首尾空白字符" class="headerlink" title="去除首尾空白字符"></a>去除首尾空白字符</h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-string">&quot;  <span class="hljs-subst">\t</span>Hello<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span> &quot;</span>.trim(); <span class="hljs-comment">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Hello&quot;</span> 删除两边空格,包括中文空格<br><span class="hljs-string">&quot; Hello &quot;</span>.stripLeading(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Hello &quot;</span>  删除前缀空格<br><span class="hljs-string">&quot; Hello &quot;</span>.stripTrailing(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot; Hello&quot;</span> 删除后缀空格<br></code></pre></td></tr></table></figure><p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">.isEmpty</span><span class="hljs-params">()</span>; <span class="hljs-string">//</span> <span class="hljs-literal">true</span>，因为字符串长度为0<br><span class="hljs-string">&quot;  &quot;</span><span class="hljs-string">.isEmpty</span><span class="hljs-params">()</span>; <span class="hljs-string">//</span> <span class="hljs-literal">false</span>，因为字符串长度不为0<br><span class="hljs-string">&quot;  \n&quot;</span><span class="hljs-string">.isBlank</span><span class="hljs-params">()</span>; <span class="hljs-string">//</span> <span class="hljs-literal">true</span>，因为只包含空白字符<br><span class="hljs-string">&quot; Hello &quot;</span><span class="hljs-string">.isBlank</span><span class="hljs-params">()</span>; <span class="hljs-string">//</span> <span class="hljs-literal">false</span>，因为包含非空白字符<br></code></pre></td></tr></table></figure><h3 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h3><p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">String s = <span class="hljs-string">&quot;hello&quot;</span>;<br>s.replace(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;hewwo&quot;</span>，所有字符<span class="hljs-string">&#x27;l&#x27;</span>被替换为<span class="hljs-string">&#x27;w&#x27;</span><br>s.replace(<span class="hljs-string">&quot;ll&quot;</span>, <span class="hljs-string">&quot;~~&quot;</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;he~~o&quot;</span>，所有子串<span class="hljs-string">&quot;ll&quot;</span>被替换为<span class="hljs-string">&quot;~~&quot;</span><br></code></pre></td></tr></table></figure><p>另一种是通过正则表达式替换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">String</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A,,B;C ,D&quot;</span>;<br>s.replaceAll(<span class="hljs-string">&quot;[<span class="hljs-subst">\\</span>,<span class="hljs-subst">\\</span>;<span class="hljs-subst">\\</span>s]+&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">// &quot;A,B,C,D&quot;</span><br></code></pre></td></tr></table></figure><p>上面的代码通过正则表达式**(\s是指空白，包括空格、换行、tab缩进等所有的空白,java中\\表示\)**，把匹配的子串统一替换为<code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p><h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">String s = <span class="hljs-string">&quot;A,B,C,D&quot;</span>;<br>String[] ss = s.split(<span class="hljs-string">&quot;\\,&quot;</span>); <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">String</span>[] arr = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br><span class="hljs-keyword">String</span> s = <span class="hljs-keyword">String</span>.join(<span class="hljs-string">&quot;***&quot;</span>, arr); <span class="hljs-comment">// &quot;A***B***C&quot;</span><br></code></pre></td></tr></table></figure><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p><p><strong>s模板写好了,可以直接用s.formatted(…)</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// String</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> s = <span class="hljs-string">&quot;Hi %s, your score is %d!&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(s.formatted(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">80</span>)); <span class="hljs-comment">//Hi Alice, your score is 80!</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">59.5</span>)); <span class="hljs-comment">// Hi Bob, your score is 59.50!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p><ul><li><code>%s</code>：显示字符串；</li><li><code>%d</code>：显示整数；</li><li><code>%x</code>：显示十六进制整数；</li><li><code>%f</code>：显示浮点数。</li></ul><p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(123)</span>; <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(45.67)</span>; <span class="hljs-comment">// &quot;45.67&quot;</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">true</span>)</span>; <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">new</span> Object()</span>); <span class="hljs-comment">// 类似java.lang.Object@636be97c</span><br></code></pre></td></tr></table></figure><p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> n1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-string">&quot;123&quot;</span>)</span>; <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">int</span> n2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-string">&quot;ff&quot;</span>, 16)</span>; <span class="hljs-comment">// 按十六进制转换，255</span><br></code></pre></td></tr></table></figure><p>把字符串转换为<code>boolean</code>类型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">boolean b1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Boolean</span>.</span></span>parse<span class="hljs-constructor">Boolean(<span class="hljs-string">&quot;true&quot;</span>)</span>; <span class="hljs-comment">// true</span><br>boolean b2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Boolean</span>.</span></span>parse<span class="hljs-constructor">Boolean(<span class="hljs-string">&quot;FALSE&quot;</span>)</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>get<span class="hljs-constructor">Integer(<span class="hljs-string">&quot;java.version&quot;</span>)</span>; <span class="hljs-comment">// 版本号，11</span><br></code></pre></td></tr></table></figure><h3 id="转换为char"><a href="#转换为char" class="headerlink" title="转换为char[]"></a>转换为char[]</h3><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> cs = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>; <span class="hljs-comment">// String -&gt; char[]</span><br>String s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">cs</span>)</span>; <span class="hljs-comment">// char[] -&gt; String</span><br></code></pre></td></tr></table></figure><p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变;</p><p><strong>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</strong></p><p><strong>比如低代码平台中的静态变量CommonColList,使用时需要复制一份</strong></p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>&#39;A&#39;</code>的编码是<code>0x41</code>，字符<code>&#39;1&#39;</code>的编码是<code>0x31</code>。</p><p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>&#39;中&#39;</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p><p>类似的，日文有<code>Shift_JIS</code>编码，韩文有<code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p><p>为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p><p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在<code>ASCII</code>、<code>GB2312</code>和<code>Unicode</code>的编码：</p><p>英文字符<code>&#39;A&#39;</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ascii">         ┌────┐<br>ASCII:   │ 41 │<br>         └────┘<br>         ┌────┬────┐<br>Unicode: │ 00 │ 41 │<br>         └────┴────┘<br></code></pre></td></tr></table></figure><p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p><p>中文字符<code>&#39;中&#39;</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ascii">         ┌────┬────┐<br>GB2312:  │ d6 │ d0 │<br>         └────┴────┘<br>         ┌────┬────┐<br>Unicode: │ 4e │ 2d │<br>         └────┴────┘<br></code></pre></td></tr></table></figure><p>那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。通过<code>UTF-8</code>编码，英文字符<code>&#39;A&#39;</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>&#39;中&#39;</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p><p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b1 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(); <span class="hljs-comment">// 按系统默认编码转换，不推荐</span><br><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>); <span class="hljs-comment">// 按UTF-8编码转换</span><br><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 按GBK编码转换</span><br><span class="hljs-keyword">byte</span>[] b3 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8编码转换</span><br></code></pre></td></tr></table></figure><p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><p><strong>注:经常在文件解析和请求解析时使用</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">byte</span>[] b = ...<br><span class="hljs-keyword">String</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(b, <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 按GBK转换</span><br><span class="hljs-keyword">String</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(b, StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8转换</span><br></code></pre></td></tr></table></figure><p><strong>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</strong></p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">char</span>[] value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> offset;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而较新的JDK版本**(Java9以后)<strong>的<code>String</code>则以<code>byte[]</code>存储：如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了</strong>节省内存(byte一个字节,char两个字节)**，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> coder; <span class="hljs-comment">// 0 = LATIN1, 1 = UTF16</span><br></code></pre></td></tr></table></figure><p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的<code>public</code>方法签名是不变的。</p><p>为啥?因为public方法的权限表示,返回值,参数值,名称都没变,所以外部使用不受影响</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>Java字符串<code>String</code>是不可变对象；</li><li>字符串操作不改变原字符串内容，而是返回新字符串；</li><li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li><li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li><li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li><li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li></ul><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><p><code>StringBuilder</code>还可以进行链式操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">1024</span>);<br>        sb.append(<span class="hljs-string">&quot;Mr &quot;</span>)<br>          .append(<span class="hljs-string">&quot;Bob&quot;</span>)<br>          .append(<span class="hljs-string">&quot;!&quot;</span>)<br>          .insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Hello, &quot;</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p><p>仿照<code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器</p><p><strong>注意(jdk1.5开始)：对于普通的字符串<code>+</code>操作(即字符串中不能有另一个对象,也不能有循环,即在非重复执行的单一表达式中使用字符串拼接没有性能损失)，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</strong></p><p>String 效率是远要比 StringBuffer 快的： String S1 = “This is only a” + “ simple” + “ test”; StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”); 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”;</p><p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p><p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p><p>stringbuffer固然是线程安全的，stringbuffer固然是比stringbuilder更慢，固然，在多线程的情况下，理论上是应该使用线程安全的stringbuffer的。</p><p><strong>然而，然而，然而，有谁给我一个实际的案例来显示你需要一个线程安全的string拼接器？对不起，至少在我浅薄的十几年编程生涯中还没有遇到过，也许，仅仅是也许，这个地球上的确是存在这样的编程需求的，然而，它至少跟99.99…99%的程序员是无关的。</strong></p><p>然后，补充一点，关于线程安全，即使你真的遇到了这样的场景，很不幸的是，恐怕你仍然有99.99….99%的情况下没有必要选择stringbuffer，因为stringbuffer的线程安全，仅仅是保证jvm不抛出异常顺利的往下执行而已，它可不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是<strong>锁</strong>。</p><p><strong>反对:</strong>,当然，当你重复的使用加法拼接字符串的时候，编译器会重复的new stringbuilder对象并append完成字符串拼接，为了保证数据返回的一致性还要重复调用tostring方法，直接用stingbuilder不会有这些额外开销只会有一个stingbuilder对象被创建，不会调用tostring方法，实践出真知</p><h3 id="为什么舍弃StringBuffer"><a href="#为什么舍弃StringBuffer" class="headerlink" title="为什么舍弃StringBuffer"></a>为什么舍弃StringBuffer</h3><p><strong>StringBuffer虽然是线程安全的,但是没有使用场景,因为需要多线程可以用其他比如Srping提供的concurrent容器来做,StringBuffer效率太慢</strong></p><p>每一个学过java的小伙伴都会背，StringBuffer是线程安全的，StringBuilder是非线程安全的；Hashtable是线程安全的，HashMap是非线程安全的。把这几条当成公理在用了，我面试的同学中，不管能力好坏，这几句都能背出来。</p><p>我们看一下StringBuffer的官方注释：</p><p>StringBuffer is A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. At any point in time it contains some particular sequence of characters, but the length and content of the sequence can be changed through certain method calls. String buffers are safe for use by multiple threads. The methods are synchronized where necessary so that all the operations on any particular instance behave as if they occur in some serial order that is consistent with the order of the method calls made by each of the individual threads involved.</p><p>就连官方的注释上也写着，StringBuffer是一个线程安全的可变的字符序列。StringBuffer可以安全的在多线程场景下使用。</p><p>首先咱们得定义什么是线程安全,线程安全就是在多线程运行的环境下，最终输出结果是正确的。其实任何一个类，即便它的所有方法都是synchonized，你也不能无中生有、暗度陈仓、凭空想象、胡作非为。</p><p>通常我们用的比较多的是append、insert、substring这些方法。你好好想一下，这些方法如果在多线程环境运行的情况下，它能保证程序运行结果的正确性和一致性吗？</p><p>•append为例<br>•从参加工作到现在，我遇到的所有append，拼接sql是多较多的，或者是把数据库中的几个字段拼接成一段话。<br>•如果是多线程环境运行，你根本无法预测最终结果是什么，不光是你预测不了，JVM自己都不知道最终出来的是个什么货，只能交给天意了<br>•以insert为例<br>•如果你要insert， 你需要知道自己是要insert到哪一个位置，比如在第一个出现的媳妇前插入一句我爱你三个字，那你写代码的话就是两行代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = stringBuffer.indexOf(“媳妇”);<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> &gt;= <span class="hljs-number">0</span>)&#123;<br> stringBuffer.<span class="hljs-keyword">insert</span>(<span class="hljs-keyword">index</span>,“我爱你”);<br> &#125;<br></code></pre></td></tr></table></figure><p>同志们，发现啥问题没，你要完成这个功能需要三步操作，当你完成第一步操作算出index是多少的时候，这时候很可能出现一个不怀好意的第三者线程从中作梗，最后你发现输出的结果根本不是那么回事。如果你想要这个功能好使，你还是得自己弄把锁，把刚才的方法锁住，确保你的操作是原子性的，其他要操作这个stringBuffer的地方，得拿到这把锁才行。</p><p>说了这么多，你发现了没，你找不到一个用StringBuffer的理由，我工作这么久是没见过，不光我没见过，<strong>Effective java</strong>的作者josh bloch也说没见过，他在书中说：</p><p>StringBuffer instances are almost always used by a single thread, yet they perform internal synchronization. It is for this reason that StringBuffer was supplanted by StringBuilder, which is just an unsynchronized StringBuffer.</p><h1 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">String</span>[] names = &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;;<br>        <span class="hljs-keyword">var</span> sj = <span class="hljs-keyword">new</span> <span class="hljs-type">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> name : <span class="hljs-type">names</span>) &#123;<br>            sj.add(name);<br>        &#125;<br>        System.out.println(sj.toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//用StringJoiner的结果少了前面的&quot;Hello &quot;和结尾的&quot;!&quot;！遇到这种情况，需要给StringJoiner指定“开头”和“结尾”：</span><br><span class="hljs-keyword">var</span> sj = <span class="hljs-keyword">new</span> <span class="hljs-type">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;Hello &quot;</span>, <span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="String-join"><a href="#String-join" class="headerlink" title="String.join()"></a>String.join()</h3><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span>[] names = &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;;<br><span class="hljs-keyword">var</span> s = <span class="hljs-built_in">String</span>.join(<span class="hljs-string">&quot;, &quot;</span>, names);<br></code></pre></td></tr></table></figure><h1 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>我们已经知道，Java的数据类型分两种：</p><ul><li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li><li>引用类型：所有<code>class</code>和<code>interface</code>类型</li></ul><h4 id="int转char的坑"><a href="#int转char的坑" class="headerlink" title="int转char的坑"></a>int转char的坑</h4><p>使用int直接转换为char的方式为什么不对哪？ 嗯，要回答这个问题需要弄明白char的本质了 <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a> char: The char data type is a single 16-bit Unicode character. It has a minimum value of ‘\u0000’ (or 0) and a maximum value of ‘\uffff’ (or 65,535 inclusive). char这种简单的java数据类型特点如下： 1：是java语言中8种基本数据类型中的一种 2：它占两个字节十六位 3：最小值是0，最大值是65535 4：它可以通过单引号包装起来表示，比如：‘1’、‘A’、‘中’，也可以使用0<del>65535十进制（其他进制的数也可以）的整数表示，也可以使用‘\u0000’</del>‘\uffff’表示 5：它的默认值是’\u0000’（或者0） 6：只能是单个字符，多了，没有都不行（空格也是一种字符） 当使用int类型的数据强转为char类型数据的时候，由于int数据类型是占四个字节的数据，（当int的值不在char类型的范围的时候会失去一定位数）此时char类型的数据值是int类型的值所对应的Unicode编码表中所对应的字符。</p><p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> s = <span class="hljs-keyword">null</span>;<br><span class="hljs-built_in">int</span> n = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>那么，如何把一个基本类型视为对象（引用类型）？</p><p>比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Integer</span> n = <span class="hljs-keyword">null</span>;<br><span class="hljs-type">Integer</span> n2 = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">99</span>);<br><span class="hljs-type">int</span> n3 = n2.intValue();<br></code></pre></td></tr></table></figure><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr><th align="left">基本类型</th><th align="left">对应的引用类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">java.lang.Boolean</td></tr><tr><td align="left">byte</td><td align="left">java.lang.Byte</td></tr><tr><td align="left">short</td><td align="left">java.lang.Short</td></tr><tr><td align="left">int</td><td align="left">java.lang.Integer</td></tr><tr><td align="left">long</td><td align="left">java.lang.Long</td></tr><tr><td align="left">float</td><td align="left">java.lang.Float</td></tr><tr><td align="left">double</td><td align="left">java.lang.Double</td></tr><tr><td align="left">char</td><td align="left">java.lang.Character</td></tr></tbody></table><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> i = <span class="hljs-number">100</span>;<br>Integer n = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>;<br><span class="hljs-built_in">int</span> x = n.<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>;<br></code></pre></td></tr></table></figure><p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Integer</span> n = <span class="hljs-number">100</span>; // 编译器自动使用<span class="hljs-keyword">Integer</span>.valueOf(<span class="hljs-built_in">int</span>)<br><span class="hljs-built_in">int</span> x = n; // 编译器自动使用<span class="hljs-keyword">Integer</span>.intValue()<br></code></pre></td></tr></table></figure><p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在<strong>编译阶段</strong>，目的是为了少写代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">100</span>);<br>Integer j = <span class="hljs-number">100</span>;<br>Integer k = <span class="hljs-number">100</span>;<br><br>Integer m1 = <span class="hljs-number">128</span>;<br>Integer m2 = <span class="hljs-number">128</span>;<br><br>System.out.print(i == j); <span class="hljs-comment">//false</span><br>System.out.print(i == <span class="hljs-number">100</span>); <span class="hljs-comment">//true 包装类和基础数据类型比较时,会自动拆箱</span><br>System.out.print(j == k); <span class="hljs-comment">//true 这里的j和k实际上指向缓存中的一个对象</span><br>System.out.print(m1 == m2); <span class="hljs-comment">//false 超出-128~127缓存范围,new一个对象</span><br><br> <span class="hljs-comment">// 在JDK 5.0之前，你从未见过Integer j = 100;的表达式，因为类与字面值是不能通用的，除了    //   String。而在JDK 5.0中，这种表达式是可以的！因为编译器成为Integer j =    Integer.valueOf(100)           </span><br><span class="hljs-comment">//Integer源码</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>        <span class="hljs-comment">//其中IntegerCache维护了一个Integer数组cache[]</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>解析原因： 归结于java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫<strong>享元模式</strong>（flyweight）。<br>\1. 加大对简单数字的重利用，Java定义在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象。<br>\2. 而如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象。</p><p><img src="Java%E6%A0%B8%E5%BF%83%E7%B1%BB.assets/image-20211202155038806.png" alt="image-20211202155038806"></p><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NullPointerException</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer n = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> i = n; <span class="hljs-comment">// NullPointerException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h3><p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Integer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>==</code>比较，较小的两个相同的<code>Integer</code>返回<code>true</code>，较大的两个相同的<code>Integer</code>返回<code>false</code>，这是因为<code>Integer</code>是不变类，编译器把<code>Integer x = 127;</code>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为<code>true</code>，但我们<em>绝不能</em>因为Java标准库的<code>Integer</code>内部有缓存优化就用<code>==</code>比较，必须用<code>equals()</code>方法比较两个<code>Integer</code>。</p><p> 按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code></li></ul><p><strong>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</strong></p><p><strong>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</strong></p><p><strong>即: 创建新对象时，优先选用静态工厂方法而不是new操作符。</strong></p><p>如果我们考察<code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的<code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> x1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-string">&quot;100&quot;</span>)</span>; <span class="hljs-comment">// 100</span><br><span class="hljs-built_in">int</span> x2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-string">&quot;100&quot;</span>, 16)</span>; <span class="hljs-comment">// 256,因为按16进制解析</span><br></code></pre></td></tr></table></figure><p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Main &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(100)</span>); <span class="hljs-comment">// &quot;100&quot;,表示为10进制</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(100, 36)</span>); <span class="hljs-comment">// &quot;2s&quot;,表示为36进制</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">HexString(100)</span>); <span class="hljs-comment">// &quot;64&quot;,表示为16进制 = 6*16+4</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">OctalString(100)</span>); <span class="hljs-comment">// &quot;144&quot;,表示为8进制</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">BinaryString(100)</span>); <span class="hljs-comment">// &quot;1100100&quot;,表示为2进制</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：上述方法的输出都是<code>String</code>，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。<code>int n = 100</code>在内存中总是以4字节的二进制表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌────────┬────────┬────────┬────────┐<br>│00000000│00000000│00000000│01100100│<br>└────────┴────────┴────────┴────────┘<br></code></pre></td></tr></table></figure><p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：**数据的存储和显示要分离(举例,存储时间时,只需要存储一个绝对的时间戳,到了需要显示时,再根据用户需求显示出来)**。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span><br><span class="hljs-keyword">Boolean</span> t = <span class="hljs-keyword">Boolean</span>.<span class="hljs-keyword">TRUE</span>;<br><span class="hljs-keyword">Boolean</span> f = <span class="hljs-keyword">Boolean</span>.<span class="hljs-keyword">FALSE</span>;<br><span class="hljs-comment">// int可表示的最大/最小值:</span><br><span class="hljs-keyword">int</span> max = Integer.MAX_VALUE; <span class="hljs-comment">// 2147483647</span><br><span class="hljs-keyword">int</span> min = Integer.MIN_VALUE; <span class="hljs-comment">// -2147483648</span><br><span class="hljs-comment">// long类型占用的bit和byte数量:</span><br><span class="hljs-keyword">int</span> sizeOfLong = <span class="hljs-keyword">Long</span>.<span class="hljs-keyword">SIZE</span>; <span class="hljs-comment">// 64 (bits)</span><br><span class="hljs-keyword">int</span> bytesOfLong = <span class="hljs-keyword">Long</span>.BYTES; <span class="hljs-comment">// 8 (bytes)</span><br></code></pre></td></tr></table></figure><h3 id="数据转换-非常有用"><a href="#数据转换-非常有用" class="headerlink" title="数据转换(非常有用)"></a>数据转换(非常有用)</h3><p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 向上转型为Number:</span><br>Number num = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(999)</span>;<br><span class="hljs-comment">// 获取byte, int, long, float, double:</span><br>byte b = num.byte<span class="hljs-constructor">Value()</span>;<br><span class="hljs-built_in">int</span> n = num.<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>;<br>long ln = num.long<span class="hljs-constructor">Value()</span>;<br><span class="hljs-built_in">float</span> f = num.<span class="hljs-built_in">float</span><span class="hljs-constructor">Value()</span>;<br>double d = num.double<span class="hljs-constructor">Value()</span>;<br></code></pre></td></tr></table></figure><h3 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h3><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是<code>-128</code><del><code>+127</code>，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code></del><code>255</code>。我们把一个负的<code>byte</code>按无符号整型转换为<code>int</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Byte</span><br>public <span class="hljs-keyword">class</span> Main &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        byte x = -<span class="hljs-number">1</span>;<br>        byte y = <span class="hljs-number">127</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Byte</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">UnsignedInt(<span class="hljs-params">x</span>)</span>); <span class="hljs-comment">// 255</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Byte</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">UnsignedInt(<span class="hljs-params">y</span>)</span>); <span class="hljs-comment">// 127</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>byte</code>的<code>-1</code>的二进制表示是<code>11111111</code>，以无符号整型转换后的<code>int</code>就是<code>255</code>。</p><p>类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code>。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</p><p>包装类型的比较必须使用<code>equals()</code>；</p><p>整数和浮点数的包装类型都继承自<code>Number</code>；</p><p>包装类型提供了大量实用方法。</p><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">private</span> int age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params">int age</span>)</span> &#123; <span class="hljs-built_in">this</span>.age = age; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 读方法:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Type</span> getXyz()<br><span class="hljs-comment">// 写方法:</span><br><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> setXyz(<span class="hljs-keyword">Type</span> value)<br></code></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code></p><p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>;</p><p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p><ul><li>对应的读方法是<code>String getName()</code></li><li>对应的写方法是<code>setName(String)</code></li></ul><p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p><ul><li>对应的读方法是<code>int getAge()</code></li><li>无对应的写方法<code>setAge(int)</code></li></ul><p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p><p>很明显，只读属性很常见，只写属性不常见。</p><p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChild</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age &lt;= <span class="hljs-number">6</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p><h3 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h3><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><h3 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h3><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector(内省器)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        BeanInfo info = Introspector.getBeanInfo(Person.class);<br>        <span class="hljs-keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;<br>            System.out.println(pd.getName());<br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + pd.getReadMethod());<br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + pd.getWriteMethod());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="Java%E6%A0%B8%E5%BF%83%E7%B1%BB.assets/image-20211125161917124.png" alt="image-20211125161917124"></p><p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的。</p><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p><h3 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h3><p>使用<code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以例外。</p><p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例(<strong>即枚举是单例的,也是public static的</strong>)，所以可以直接用<code>==</code>比较：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (day == <span class="hljs-built_in">Weekday</span>.FRI) &#123; <span class="hljs-comment">// ok!</span><br>&#125;<br><span class="hljs-keyword">if</span> (day.equals(<span class="hljs-built_in">Weekday</span>.SUN)) &#123; <span class="hljs-comment">// ok, but more code!</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h3><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p><p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><p>例如，我们定义的<code>Color</code>枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器编译出的<code>class</code>大概就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span> </span>&#123; <span class="hljs-comment">// 继承自Enum，标记为final class</span><br>    <span class="hljs-comment">// 每个实例均为全局唯一:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Color RED = <span class="hljs-keyword">new</span> Color();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Color GREEN = <span class="hljs-keyword">new</span> Color();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Color BLUE = <span class="hljs-keyword">new</span> Color();<br>    <span class="hljs-comment">// private构造方法，确保外部无法调用new操作符:</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Color</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p><p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p><h4 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h4><p>返回常量名，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String s = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Weekday</span>.</span><span class="hljs-module"><span class="hljs-identifier">SUN</span>.</span></span>name<span class="hljs-literal">()</span>; <span class="hljs-comment">// &quot;SUN&quot;</span><br></code></pre></td></tr></table></figure><h4 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h4><p>返回定义的常量的顺序，从0开始计数，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> n = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Weekday</span>.</span><span class="hljs-module"><span class="hljs-identifier">MON</span>.</span></span>ordinal<span class="hljs-literal">()</span>; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Weekday</span> </span>&#123;<br>    SUN, MON, TUE, WED, THU, FRI, SAT;<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Weekday</span> </span>&#123;<br>    MON, TUE, WED, THU, FRI, SAT, SUN;<br>&#125;<br></code></pre></td></tr></table></figure><p>的<code>ordinal</code>就是不同的。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p><p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便？比如这样写：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String task = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Weekday</span>.</span><span class="hljs-module"><span class="hljs-identifier">MON</span>.</span></span>ordinal<span class="hljs-literal">()</span> + <span class="hljs-string">&quot;/ppt&quot;</span>;<br>save<span class="hljs-constructor">ToFile(<span class="hljs-params">task</span>)</span>;<br></code></pre></td></tr></table></figure><p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// enum</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Weekday day = Weekday.SUN;<br>        <span class="hljs-keyword">if</span> (day.dayValue == <span class="hljs-number">6</span> || day.dayValue == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Work at home!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Work at office!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Weekday</span> </span>&#123;<br>    MON(<span class="hljs-number">1</span>), TUE(<span class="hljs-number">2</span>), WED(<span class="hljs-number">3</span>), THU(<span class="hljs-number">4</span>), FRI(<span class="hljs-number">5</span>), SAT(<span class="hljs-number">6</span>), SUN(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dayValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Weekday</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dayValue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dayValue = dayValue;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值。</p><p> 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p><p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p><p><strong>覆写<code>toString()</code>的目的是在输出时更有可读性。</strong></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p><p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p><p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p><p>可以为<code>enum</code>编写构造方法、字段和方法</p><p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p><p><code>enum</code>适合用在<code>switch</code>语句中。</p><h1 id="记录类"><a href="#记录类" class="headerlink" title="记录类"></a>记录类</h1><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ol><li>定义class时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.y;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        ...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写<code>equals()</code>和<code>hashCode()</code>，这里演示<code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p><h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Point p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        System.out.println(p.x());<br>        System.out.println(p.y());<br>        System.out.println(p);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125;<br><br></code></pre></td></tr></table></figure><p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p><p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p><p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p><p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> &#123;<br>    <span class="hljs-keyword">public</span> Point &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>&#123;<br>    public <span class="hljs-type">Point</span>(int x, int y) &#123;<br>        <span class="hljs-comment">// 这是我们编写的Compact Constructor:</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>();<br>        &#125;<br>        <span class="hljs-comment">// 这是编译器继续生成的赋值代码:</span><br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title">of</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title">of</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们可以写出更简洁的代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> z = <span class="hljs-built_in">Point</span>.of();<br><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Point</span>.of(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br></code></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p><ul><li>使用<code>record</code>定义的是不变类；</li><li>可以编写Compact Constructor对参数进行验证；</li><li>可以定义静态方法。</li></ul><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BigInteger bi = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigInteger(<span class="hljs-string">&quot;1234567890&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(bi.pow(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 5次幂 2867971860299718107233761438093672048294900000</span><br></code></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">BigInteger <span class="hljs-type">i1</span> <span class="hljs-operator">=</span> new BigInteger(<span class="hljs-string">&quot;1234567890&quot;</span>)<span class="hljs-comment">;</span><br>BigInteger <span class="hljs-type">i2</span> <span class="hljs-operator">=</span> new BigInteger(<span class="hljs-string">&quot;12345678901234567890&quot;</span>)<span class="hljs-comment">;</span><br>BigInteger sum <span class="hljs-operator">=</span> <span class="hljs-type">i1</span>.<span class="hljs-keyword">add</span>(<span class="hljs-type">i2</span>)<span class="hljs-comment">; // 12345678902469135780</span><br></code></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BigInteger i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigInteger(<span class="hljs-string">&quot;123456789000&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.long<span class="hljs-constructor">Value()</span>); <span class="hljs-comment">// 123456789000</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.multiply(i).long<span class="hljs-constructor">ValueExact()</span>); <span class="hljs-comment">// java.lang.ArithmeticException: BigInteger out of long range</span><br></code></pre></td></tr></table></figure><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><p>如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4x10^38），那么返回的float是什么呢？</p><p>Infinity 无穷大</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// BigInteger to float</span><br><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        BigInteger n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigInteger</span>(<span class="hljs-string">&quot;999999&quot;</span>).<span class="hljs-built_in">pow</span>(<span class="hljs-number">99</span>);<br>        <span class="hljs-keyword">float</span> f = n.<span class="hljs-built_in">floatValue</span>();<br>        System.out.<span class="hljs-built_in">println</span>(f); <span class="hljs-comment">// Infinity</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h3><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p><code>BigInteger</code>用于表示任意大小的整数；</p><p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p><p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BigDecimal bd = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;123.4567&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(bd.multiply(bd)); <span class="hljs-comment">// 15241.55677489</span><br></code></pre></td></tr></table></figure><h3 id="scale-规模-刻度"><a href="#scale-规模-刻度" class="headerlink" title="scale():规模,刻度"></a>scale():规模,刻度</h3><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BigDecimal d1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;123.45&quot;</span>)</span>;<br>BigDecimal d2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;123.4500&quot;</span>)</span>;<br>BigDecimal d3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;1234500&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d1.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// 2,两位小数</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d2.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// 4</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d3.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><strong>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BigDecimal d1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;123.4500&quot;</span>)</span>;<br>BigDecimal d2 = d1.strip<span class="hljs-constructor">TrailingZeros()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d1.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// 4</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d2.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// 2,因为去掉了00</span><br><br>BigDecimal d3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;1234500&quot;</span>)</span>;<br>BigDecimal d4 = d3.strip<span class="hljs-constructor">TrailingZeros()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d3.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d4.scale<span class="hljs-literal">()</span>); <span class="hljs-comment">// -2 把末尾0去掉,变成科学计数法了</span><br></code></pre></td></tr></table></figure><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><span class="hljs-keyword">import</span> java.math.RoundingMode;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BigDecimal d1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;123.456789&quot;</span>);<br>        BigDecimal d2 = d1.setScale(<span class="hljs-number">4</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 四舍五入，123.4568</span><br>        BigDecimal d3 = d1.setScale(<span class="hljs-number">4</span>, RoundingMode.DOWN); <span class="hljs-comment">// 直接截断，123.4567</span><br>        System.out.println(d2);<br>        System.out.println(d3);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1、 ROUND<span class="hljs-emphasis">_UP：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">      2、 ROUND_</span>DOWN：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。<br><br><span class="hljs-code">     3、 ROUND_CEILING：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。</span><br><span class="hljs-code"></span><br><span class="hljs-code">      4、 ROUND_FLOOR：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。</span><br><span class="hljs-code"></span><br><span class="hljs-code">      5、 HALF_UP：最近数字舍入(5进)。这是我们最经典的四舍五入。</span><br><span class="hljs-code"></span><br><span class="hljs-code">      6、 HALF_DOWN：最近数字舍入(5舍)。在这里5是要舍弃的。</span><br><span class="hljs-code"></span><br><span class="hljs-code">      7、 HAIL_EVEN：银行家舍入法。</span><br><span class="hljs-code">      银行家舍入法:</span><br><span class="hljs-code">      舍去位的数值小于5时，直接舍去。</span><br><span class="hljs-code">      舍去位的数值大于5时，进位后舍去。</span><br><span class="hljs-code">      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。</span><br><span class="hljs-code">      对于上面的规则我们举例说明,其中小数点后第三位为舍去位</span><br><span class="hljs-code">         11.556 = 11.56          ------六入,第三位为6</span><br><span class="hljs-code"></span><br><span class="hljs-code">         11.554 = 11.55          -----四舍,第三位为4</span><br><span class="hljs-code"></span><br><span class="hljs-code">         11.5551 = 11.56         -----五后有数进位,第三位为5,后有1,进位</span><br><span class="hljs-code"></span><br><span class="hljs-code">         11.545 = 11.54          -----五后无数，若前位为偶数应舍去,前位为4,舍去</span><br><span class="hljs-code"></span><br><span class="hljs-code">         11.555 = 11.56          -----五后无数，若前位为奇数应进位,前位为6,进位</span><br></code></pre></td></tr></table></figure><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BigDecimal</span> d<span class="hljs-number">1</span> = new BigDecimal(<span class="hljs-string">&quot;123.456&quot;</span>);<br><span class="hljs-attribute">BigDecimal</span> d<span class="hljs-number">2</span> = new BigDecimal(<span class="hljs-string">&quot;23.456789&quot;</span>);<br><span class="hljs-attribute">BigDecimal</span> d<span class="hljs-number">3</span> = d<span class="hljs-number">1</span>.divide(d<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, RoundingMode.HALF_UP); // 保留<span class="hljs-number">10</span>位小数并四舍五入<br><span class="hljs-attribute">BigDecimal</span> d<span class="hljs-number">4</span> = d<span class="hljs-number">1</span>.divide(d<span class="hljs-number">2</span>); // 报错：ArithmeticException，因为除不尽<br></code></pre></td></tr></table></figure><h3 id="除法求余-可以用来判断整数倍"><a href="#除法求余-可以用来判断整数倍" class="headerlink" title="除法求余(可以用来判断整数倍)"></a>除法求余(可以用来判断整数倍)</h3><p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BigDecimal n = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;12.345&quot;</span>);<br>        BigDecimal m = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.12&quot;</span>);<br>        BigDecimal[] dr = n.divideAndRemainder(m);<br>        System.out.println(dr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 102</span><br>        System.out.println(dr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 0.105</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal n = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;12.75&quot;</span>);<br>BigDecimal m = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.15&quot;</span>);<br>BigDecimal[] dr = n.divideAndRemainder(m);<br><span class="hljs-keyword">if</span> (dr[<span class="hljs-number">1</span>].signum() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// n是m的整数倍</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h3><p><strong>用compareTo,不要用equals</strong></p><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BigDecimal d1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;123.456&quot;</span>)</span>;<br>BigDecimal d2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(<span class="hljs-string">&quot;123.45600&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d1.equals(d2)); <span class="hljs-comment">// false,因为scale不同</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d1.equals(d2.strip<span class="hljs-constructor">TrailingZeros()</span>)); <span class="hljs-comment">// true,因为d2去除尾部0后scale变为2</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(d1.compare<span class="hljs-constructor">To(<span class="hljs-params">d2</span>)</span>); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDecimal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">BigDecimal</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger intVal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scale;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p><p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。</p><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">求绝对值：<br>Math.abs(-<span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span><br>Math.abs(-<span class="hljs-number">7.8</span>); <span class="hljs-comment">// 7.8</span><br><br>取最大或最小值：<br>Math.max(<span class="hljs-number">100</span>, <span class="hljs-number">99</span>); <span class="hljs-comment">// 100</span><br>Math.min(<span class="hljs-number">1.2</span>, <span class="hljs-number">2.3</span>); <span class="hljs-comment">// 1.2</span><br><br>计算xy次方：<br>Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 2的10次方=1024</span><br><br>计算√x：<br>Math.sqrt(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1.414...</span><br><br>计算ex次方：<br>Math.exp(<span class="hljs-number">2</span>); <span class="hljs-comment">// 7.389...</span><br><br>计算以e为底的对数：<br>Math.log(<span class="hljs-number">4</span>); <span class="hljs-comment">// 1.386...</span><br><br>计算以<span class="hljs-number">10</span>为底的对数：<br>Math.log10(<span class="hljs-number">100</span>); <span class="hljs-comment">// 2</span><br><br>三角函数：<br>Math.sin(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 0.00159...</span><br>Math.cos(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// -0.9999...</span><br>Math.tan(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// -0.0015...</span><br>Math.asin(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 1.57079...</span><br>Math.acos(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 0.0</span><br><br>数学常量：<br><span class="hljs-keyword">double</span> pi = Math.PI; <span class="hljs-comment">// 3.14159...</span><br><span class="hljs-keyword">double</span> e = Math.E; <span class="hljs-comment">// 2.7182818...</span><br>Math.sin(Math.PI / <span class="hljs-number">6</span>); <span class="hljs-comment">// sin(π/6) = 0.5</span><br><br>生成一个随机数x，x的范围是<span class="hljs-number">0</span> &lt;= x &lt; <span class="hljs-number">1</span>：<br>Math.random(); <span class="hljs-comment">// 0.53907... 每次都不一样</span><br></code></pre></td></tr></table></figure><p><code>StrictMath</code>提供了和<code>Math</code>几乎一模一样的方法,由于浮点数计算存在误差，不同的平台计算的结果可能不一致（指误差不同）,<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Random</span> r = new Random();<br><span class="hljs-attribute">r</span>.nextInt(); // <span class="hljs-number">2071575453</span>,每次都不一样<br><span class="hljs-attribute">r</span>.nextInt(<span class="hljs-number">10</span>); // <span class="hljs-number">5</span>,生成一个[<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)之间的int<br><span class="hljs-attribute">r</span>.nextLong(); // <span class="hljs-number">8811649292570369305</span>,每次都不一样<br><span class="hljs-attribute">r</span>.nextFloat(); // <span class="hljs-number">0</span>.<span class="hljs-number">54335</span>...生成一个[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)之间的float<br><span class="hljs-attribute">r</span>.nextDouble(); // <span class="hljs-number">0</span>.<span class="hljs-number">3716</span>...生成一个[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)之间的double<br></code></pre></td></tr></table></figure><p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p><p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Random r = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">12345</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(r.nextInt(<span class="hljs-number">100</span>));<br>        &#125;<br>        <span class="hljs-comment">// 51, 80, 41, 28, 55...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p><h3 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h3><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SecureRandom sr = <span class="hljs-keyword">new</span> SecureRandom();<br>System.out.println(sr.nextInt(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SecureRandom sr = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sr = SecureRandom.getInstanceStrong(); <span class="hljs-comment">// 获取高强度安全随机数生成器</span><br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            sr = <span class="hljs-keyword">new</span> SecureRandom(); <span class="hljs-comment">// 获取普通的安全随机数生成器</span><br>        &#125;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];<br>        sr.nextBytes(buffer); <span class="hljs-comment">// 用安全随机数填充buffer</span><br>        System.out.println(Arrays.toString(buffer));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p><p><strong>需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Core</category>
      
      <category>Java</category>
      
      <category>1.面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
